[[intro_chapter]]
== Les bases d'Ethereum

Dans ce chapitre nous allons commencer à explorer Ethereum, apprendre comment utiliser un portefeuille, comment créer des transactions, et aussi comment lancer un smart contract.

[[ether_units]]
=== Unité monétaire Ether

((("currency units")))((("Ethereum (generally)","currency units")))L'unité monétaire d'Ethereum s'appelle _ether_, appelée également ETH ou par le symbole &#926; (De la lettre Grecque "Xi" qui ressemble a une version stylisée de la lettre E) ou, moins souvent ,  &#9830;: par exemple, 1 ether, ou 1 ETH, ou &#926;1, ou &#9830;1.'

[TIP]
====
Utilisez le caractère Unicode +U+039E+ pour &#926; et +U+2666+ pour &#9830;.
====

L'Ether est divisible en petites unités, jusqu'á la plus petite unité possible appelée _wei_. Un Ether est égal à 1 trillion de wei (1 * 10^18^ ou 1,000,000,000,000,000,000). Vous pouvez aussi entendre les gens parler de la monnaie "Ethereum", mais c'est une erreur commune. Ethereum est le système, Ether est la monnaie.

La valeur de l'ether est toujours représentée dans Ethereum comme un entier non signé (non négatif), libellé en wei. Lorsque vous transférez 1 ether, la transaction encode 1000000000000000000 wei comme valeur.

Les différentes dénominations de l'Ether ont aussi bien un nom scientifique, utilisant le Système International d'Unités (_SI_), qu'une appellation commune qui rend hommage aux grands esprits de l'informatique et de la cryptographie.

< 1 > montre les différentes unités, noms communs, et leurs appellations tirées du  SI. En accord avec leur valeur, le tableau détaille toutes les équivalents en wei (première ligne), avec l'ether correspondant à 10^18 wei à la 7ème ligne. 

[[ether_denominations]]
.Dénominations et noms des valeurs de l'Ether
[options="header"]
|===
| Valeur (en wei) | Exposant | Nom commun | Nom SI
| 1 | 1 | wei | Wei
| 1,000 | 10^3^ | Babbage | Kilowei ou femtoether
| 1,000,000 | 10^6^ | Lovelace | Megawei ou picoether
| 1,000,000,000 | 10^9^ | Shannon | Gigawei ou nanoether
| 1,000,000,000,000 | 10^12^ | Szabo | Microether ou micro
| 1,000,000,000,000,000 | 10^15^ | Finney | Milliether ou milli
| _1,000,000,000,000,000,000_ | _10^18^_ | _Ether_ | _Ether_
| 1,000,000,000,000,000,000,000 | 10^21^ | Grand | Kiloether
| 1,000,000,000,000,000,000,000,000 | 10^24^ | | Megaether
|===

[[choosing_eth_wallet]]
=== Choisir un portefeuille Ethereum

((("Ethereum (generally)","wallet choices")))((("wallets","choosing")))((("wallets","defined")))Le terme "portefeuille" a plusieurs significations, bien qu'elles soient toutes liées et expriment plus ou moins la même chose. Nous allons utiliser le terme de "portefeuille" pour parler d'une application qui vous permet de gérer votre compte Ethereum. En résumé, un portefeuille Ethereum est une porte d'entrée vers le système Ethereum. Celui-ci garde vos clés et peut créer et envoyer des transactions en votre nom. Choisir un portefeuille Ethereum peut être difficile car il existe différentes options avec des fonctionnalités et designs variés. Certains sont plus adaptés aux débutants et d'autres à des utilisateurs confirmés. La plateforme Ethereum elle-même est en constante amélioration, et les "meilleurs" portefeuilles sont ceux qui s'adaptent aux changements dus à l'amélioration de la plateforme.

Mais ne vous inquiétez pas ! Si vous choisissez un portefeuille et que vous n'aimez pas son fonctionnement&#x2014;ou si vous l'aimiez au début mais voulez essayer quelque-chose d'autre ensuite&#x2014;vous pouvez changer de portefeuille assez facilement. Tout ce que vous avez à faire c'est de faire une transaction qui envoie vos fonds de l'ancien à votre nouveau portefeuille, ou bien exporter vos clés privées et les importer dans le nouveau.

Nous avons sélectionné trois différents types de portefeuille à utiliser comme exemples à travers notre livre: un portefeuille sur mobile, un portefeuille sur ordinateur et un portefeuille sur navigateur Internet. Nous avons choisi ces trois portefeuilles parce qu'ils représentent un large éventail de niveaux de complexité et de fonctionnalités. Cependant, la sélection de ces portefeuilles n'est pas un gage de leur qualité ou de leur sécurité. Ce sont simplement un bon point de départ pour des démonstrations et tests.

((("private keys","wallets and")))Gardez en tête que pour que le portefeuille fonctionne, il doit avoir accès à vos clés privées, par conséquent il est vital que vous ne téléchargiez et utilisiez que des applications portefeuille de sources en qui vous avez confiance. Heureusement, en général, plus une application portefeuille est populaire, plus elle est censée être sûre. Néanmoins, une bonne pratique est d'éviter de mettre tous ses œufs dans le même panier et avoir plusieurs comptes Ethereum répartis sur deux portefeuilles. 

Les propositions suivantes sont de bons portefeuilles pour débuter:

MetaMask:: ((("MetaMask")))MetaMask est un portefeuille via extension de navigateur qui fonctionne sur votre navigateur (Chrome, Firefox, Opera ou Brave Browser). Il est facile à utiliser et pratique pour les tests, car il est capable de se connecter à un grand nombre de nœuds Ethereum et de blockchains de test. MetaMask est un portefeuille Web.

Jaxx est un portefeuille multiplateforme et multidevise qui s'exécute sur divers systèmes d'exploitation, notamment Android, iOS, Windows, macOS et Linux. C'est souvent un bon choix pour les nouveaux utilisateurs car il est conçu pour la simplicité et la facilité d'utilisation. Jaxx est soit un portefeuille sur mobile, soit un portefeuille sur ordinateur, selon où vous l'installez.

MyEtherWallet (MEW):: ((("Ethereum Classic (ETC)","Emerald Wallet and")))((("MyEtherWallet (MEW)")))((("wallets","Emerald Wallet")))((("wallets","MyEtherWallet")))MyEtherWallet est un portefeuille Internet qui fonctionne sur n'importe quel navigateur. Il possède plusieurs fonctionnalités sophistiquées que nous explorerons dans nos exemples. 

Emerald Wallet est conçu pour fonctionner avec la blockchain Ethereum Clasic, mais est également compatible avec les autres blockchains Ethereum-compatibles. C'est une application de bureau open source et fonctionne sur Windows, macOS et Linux. Emerald Wallet peut faire tourner un nœud complet ou se connecter à un nœud distant public, en mode léger. C'est également une application compagnon pour exécuter des opérations de la ligne de commande.

Nous allons commencer par installer MetaMask sur un ordinateur, mais d'abord nous allons brièvement expliquer le contrôle et la gestion des clés.

[[control_responsibility]]
=== Contrôle et responsabilité

Les blockchains publiques comme Ethereum sont importantes car elles opèrent comme un système décentralisé. Ce qui veut dire beaucoup de choses, mais un élément crucial est que chaque utilisateur d'Ethereum peut et devrait contrôler ses clés privées, qui permettent l'accès aux fonds et contrats intelligents (smart contract). Nous appelons souvent la combinaison d'accès aux fonds et au contrats un "compte" ou un "portefeuille". Ces termes sont assez complexes dans leur usage, nous verrons cela en détails plus tard. Cependant, un principe fondamental est aussi simple qu'une clé privée est égale à un compte. Certains utilisateurs choisissent de délaisser le contrôle de leurs clés privées en utilisant une entité tierce, telle qu'une plateforme d'échange en ligne. Dans ce livre, nous vous apprendrons comment avoir le contrôle et la gestion sur ces clés privées.

Le contrôle implique de grandes responsabilités. Si vous perdez vos clés, vous perdez l'accès à vos fonds et à vos contrats. Personne ne peut vous aider à récupérer l'accès, vos fonds seront bloqués à tout jamais. Voici quelques astuces pour vous aidez à gérer cette responsabilité: 

*Soyez vigilants sur la sécurité. Utilisez des techniques utilisées et testées.

Le plus important, le compte (par exemple plus grande est la valeur des fond contrôlés, ou plus l'accessibilité à un contrat intelligent est importante), le plus de mesures de sécurité doivent être prises. 

*La plus grande mesure de sécurité est garantie par un appareil non connecté, mais ce niveau de sécurité n'est pas requis pour tous les comptes. 

*Ne jamais conserver ses clés privées sur un seul support, en particulier numérique. Heureusement, aujourd'hui la plupart des interfaces ne vous laisse pas voir directement la clé privée. 

Les clés privées peuvent être conservées sous forme chiffrée, comme un fichier "keystore" numérique. En étant chiffré, ces fichiers requièrent un mot de passe pour être déverrouillés. Quand on vous demande de choisir un mot de passe, prenez-en un robuste (par exemple long et aléatoire), faites en une sauvegarde et ne le partagez pas. Si vous n'avez pas de gestionnaire de mots de passe, écrivez-le et rangez le dans un endroit sécurisé et secret. Pour accéder à votre compte, vous auriez besoin du fichier "keeystore" et du mot de passe. 

*Ne sauvegardez pas aucun mot de passe sur un document numérique, photos numériques, captures d'écran, stockages en ligne, PDF chiffrés, etc. Une fois encore, soyez vigilants sur la sécurité. Utilisez un gestionnaire de mots de passe ou un stylo et un papier. 

*Quand on vous demande de sauvegardez votre clé sous forme de phrase mnémonique, utilisez un stylo et un papier pour avoir une sauvegarde physique. Ne remettez pas cette tâche "à plus tard", vous ne le ferez pas. Ces sauvegardes peuvent être utilisées pour reconstruire votre clé privée si jamais vous perdez toutes les données sauvegardées sur votre système, ou si vous oubliez ou perdez votre mot de passe. Cependant, elles peuvent aussi être utilisées par un attaquant pour récupérer votre clé privée, donc ne la sauvegardez jamais sous format numérique, et gardez une copie physique rangée de manière sûre dans un tiroir sûr et verrouillé. 

*Avant de transférer n'importe quelle somme importante (en particulier vers de nouvelles adresses), faites d'abord une petite transaction de test (par exemple, moins d'une valeur d'1€) et attendez la confirmation de la réception.

*Quand vous créer un nouveau compte, commencez par envoyer un petit montant à la nouvelle adresse. Une fois la transaction reçue, essayez d'envoyer à nouveau depuis ce compte. La création d'un compte peut mal se faire pour plusieurs raisons, et si c'est le cas, il vaut mieux s'en apercevoir avec une perte minime. Si les tests sont concluants, vous pouvez envoyer tout dessus.

*Les block explorers publics sont un bon moyen de vérifier soi-même si une transaction a été acceptée par le réseau. Cependant, cet usage a un mauvais impact sur votre vie privée, du fait que vous révélez votre adresse aux block explorers, qui peuvent vous tracer.

*N'envoyez pas d'argent à une des adresses affichées dans ce livre. Les clés privées sont détaillées dans cet ouvrage et quelqu'un récupèrera aussitôt l'argent.

Maintenant que nous avons couvert quelques bonnes pratiques éléments au sujet de la gestion de vos clés et de la sécurité, nous allons travailler sur comment utiliser MetaMask: 

[[installing_MetaMask]]
=== Premiers pas avec MetaMask

((("Ethereum (en général )","Bases de MetaMask", id="ix_02intro-asciidoc2", range="startofrange")))((("MetaMask","bases", id="ix_02intro-asciidoc3", range="startofrange")))Ouvrez le navigateur Google Chrome et accédez à https://chrome.google.com/webstore/category/extensions[].

Recherchez "MetaMask" et cliquez sur le logo représentant un renard. Vous devriez avoir un résultat comme ce qui est montré ici <1>.

[[metamask_download]]
*La page détaillée de l'extension Chrome MetaMask
image::images/metamask_download.png["Page de détail MetaMask"]

Il est important de vérifier que vous téléchargez la vraie extension MetaMask, en raison de certains individus capables de proposer des extensions frauduleuses qui contournent les filtres de Google. La vraie extension: 

*Montre l'ID dans la barre d'adresse "nkbihfbeogaeaoehlefnkodbefgpgknn"
*Est proposé ici https://metamask.io
*A plus de 1500 avis
*A plus de 1 000 000 d'utilisateurs

Une fois que vous avez trouvé la bonne extension, cliquez sur "Ajouté à Chrome" pour la télécharger

[[using_MetaMask]]
==== Création d'un portefeuille

((("MetaMask","wallet setup with", id="ix_02intro-asciidoc4", range="startofrange")))Une fois que MetaMask est installé vous devriez voir un nouvel icone (une tête de renard) dans la barre d'outils de votre navigateur. Cliquez dessus pour commencer. Vous devez accepter les termes et conditions et ensuite créer votre nouveau portefeuille Ethereum en entrant un mot de passe (voir <2>).

[[metamask_password]]
*La page du mot de passe sur l'extension Chrome MetaMask
image::images/metamask_password.png["Page de mot de passe MetaMask"]

[TIP]
====
Le mot de passe contrôle l'accès à MetaMask, ainsi il ne peut pas être utilisé par toute personne ayant accès à votre navigateur.
====

((("mnemonic code words","MetaMask and", id="ix_02intro-asciidoc5", range="startofrange")))Une fois votre mot de passe défini, MetaMask va générer un portefeuille pour vous et vous montrer une phrase mnémonique de 12 mots en anglais (see <1>). Ces mots peuvent être utilisés sur n'importe quel portefeuille compatible pour retrouver l'accès à vos fonds si quelque chose arrivait à votre MetaMask ou votre ordinateur. Vous n'avez pas besoin de votre mot de passe pour la récupération; les 12 mots sont suffisants.

[TIP]
====
Sauvegardez votre phrase mnémonique (12 mots) sur un papier, deux fois. Rangez vos deux papiers dans deux endroits sécurisés différents, tels qu'un coffre ignifuge, un tiroir fermé à clé, ou un coffre-fort. Considérez ces papiers comme du liquide ayant la même valeur que ce que vous avez sur votre portefeuille Ethereum. N'importe qui ayant accès à ces mots peut accéder et voler votre argent.
====

[[metamask_mnemonic]]
.La phrase mnémonique de votre portefeuille créée par MetaMask
image::images/metamask_mnemonic.png["Page mnémonique MetaMask"]

Une fois que vous avez confirmé que vous avez rangé votre phrase mnémonique dans un endroit sécurisé, vous pourrez voir les détails de votre compte Ethereum, comme montré dans <1>.(((range="endofrange", startref="ix_02intro-asciidoc5")))

[[metamask_account]]
.Votre compte Ethereum dans MetaMask
image::images/metamask_account.png["Page du compte MetaMask"]

La page de votre compte montre le nom de votre compte ("Account 1" par défaut), une addresse Ethereum (+0x9E713...+ dans cet exemple), et un icone coloré vous aidant à distinguer ce compte des autres. En haut de la page du compte, vous pouvez voir quel réseau Ethereum vous êtes en train d'utiliser ("Main Network" sur l'exemple).

Félicitations ! Vous avez configuré votre premier portefeuille Ethereum.(((range="endofrange", startref="ix_02intro-asciidoc4")))

[[switching_networks]]
==== Commutation de réseaux

((("MetaMask","network choices")))Comme vous pouvez le voir sur la page de votre compte Ethereum, vous pouvez choisir entre plusieurs réseaux Ethereum. Par défaut, MetaMask essaiera de se connecter au réseau principal. Les autres choix sont des réseaux de test publics, n'importe noeud Ethereum de votre choix, ou nœudsde blockchains privées sur votre ordinateur (localhost):

Main Ethereum Network:: La blockchain principale publique Ethereum. Vrai ETH, vraie valeur, et vraies conséquences.

Ropsten Test Network:: Blockchain et réseau Ethereum de test publics. ETH n'a pas de valeur sur ce réseau.

Kovan Test Network:: Blockchain et réseau Ethereum de test publics utilisant le protocole de consens Aura avec la preuve d'authorité (signature fédérée). ETH n'a pas de valeur sur ce réseau. Le réseau de test Kovan est seulement supporté par Parity. Les autres clients Ethereum utilisent le protocole de consensus Clique, qui fut proposé plus tard, avec preuve d'autorité&#x2013;based vérification.

Rinkeby Test Network:: Blockchain et réseau Ethereum de test publics, utilisant le protocole de consensus Clique avec preuve d'autorité (signature fédérée). ETH n'a pas de valeur sur ce réseau. 

Localhost 8545::  Se connecter à un nœud tournant sur le même ordinateur que le navigateur. Le nœud peut faire partie de n'importe quel blockchain (principale ou de test), ou réseau de test privé. 

Custom RPC:: Permet de connecter MetaMask à n'importe quel nœud avec une interface Geth compatible Remote Procedure Call (RPC). Le nœud peut faire partie d'une blockchain publique ou privée. 

[NOTE]
====
Votre portefeuille MetaMask utilise la même clé privée et la même adresse Ethereum sur tous les réseaux auxquels il se connecte. Cependant, le solde de votre adresse Ethereum sera différent sur chaque réseau Ethereum. Vos clés peuvent permettre d'accéder à de l'ether et des contracts sur Ropsten, par exemple, mais pas sur le réseau principal. 
====

[[getting_test_eth]]
==== Obtenir des Ethers de test

((("ether (generally)","testnet")))((("MetaMask","and testnet ether")))((("test ether","obtaining")))((("testnet","ether for")))((("wallets","testnet ether and")))Votre première tâche est d'avoir des fonds sur votre portefeuille. Vous ne feriez pas cela sur le réseau principal parce que le vrai ether coûte de l'argent et requiert un minimum d'expérience. Maintenant, vous allez remplir votre portefeuille avec quelques ether de test. 

((("Ropsten Test Network")))Passez MetaMask sur le réeau de test Ropsten. Cliquez sur Déposer, puis cliquez sur Ropsten Test Faucet. MetaMask ouvrira une nouvelle page web, comme montré sur  <1>.

[[metamask_ropsten_faucet]]
.MetaMask Ropsten Test Faucet
image::images/metamask_ropsten_faucet.png["MetaMask Ropsten Test Faucet"]

Vous avez peut-être remarqué que la page web contient déjà l'adresse Ethereum de votre portefeuille MetaMask. MetaMask intègre les pages web compatibles Ethereum avec votre portefeuille MetaMask et peut "voir"" les adresses Ethereum sur la page web, vous permettant, par exemple, d'envoyer un paiement à un site marchant affichant une adresse Ethereum. MetaMask peut remplir la page web avec votre propre adresse de portefeuille comme adresse de destinataire si la page web le demande. Sur cette page, l'application de faucet demande à MetaMask une adresse de portefeuille sur laquelle envoyer des ether de test.

Cliquez sur le bouton vert "demander 1 ether au faucet. Vous verrez un identifiant (ID) de transaction apparaitre en bas de la page. L'application de fauceet a crée une transaction&#x2014;un paiement pour vous. L'identifiant de transaction ressemble à: 

[[faucet_tx_id]]
----
0x7c7ad5aaea6474adccf6f5c5d6abed11b70a350fbc6f9590109e099568090c57
----

Dans quelques secondes, la nouvelle transaction sera minée par les mineurs du réseau Ropsten et le solde de votre portefeuille MetaMask affichera 1 ETH. Cliquez sur l'ID de transaction et votre navigateur vous amènera sur un explorateur de blockchain (block explorer) qui est un site vous permettant de voir et d'explorer les blocs, adresses, et transactions. MetaMask utilise https://etherscan.io/[Etherscan block explorer], un des explorateurs les plus populaires. La transaction contenant le paiement du Faucet Test Ropste est montrée ici: <1>. 

[[ropsten_block_explorer]]
.Explorateur de blockchain Etherscan Ropsten
image::images/ropsten_block_explorer.png["Etherscan Ropsten Block Explorer"]

La transaction a été enregistrée sur la blockchain Ropsten et peut être consultée à n'importe quel moment par n'importe qui, simplement en cherchant l'ID de transaction, ou en cliquant sur le lien: http://bit.ly/2Q860Wk[visiting the link].

Essayez d'aller sur ce lien, ou entrez le hash de transaction sur ropsten.etherscan.io pour la voir par vous-même.

[[sending_eth_MetaMask]]
==== Envoyer des Ether à partir de MetaMask

((("MetaMask","sending ether from", id="ix_02intro-asciidoc6", range="startofrange")))((("test ether","sending", id="ix_02intro-asciidoc7", range="startofrange"))) Une fois votre premier ether reçu du Faucet Test Ropsten, vous pouvez essayer d'envoyer de l'ether en essayant d'en renvoyer au faucet. Comme vous pouvez le voir sur la page du Faucet Test Ropsten, il est possible de "donner" 1 ETH au Faucet. Cette option est disponible, comme ça une fois vos tests terminés, vous pouvez renvoyer le reste de vos ethers, pour qu'une autre personne puisse les utiliser ensuite. Bien que les ethers de test n'ont pas de valeur, certaines personnes les gardent, ce qui rend l'utilisation des réseaux de test pour tout le monde plus difficile. Garder les ethers de test est mal vu !

Heureusement, nous ne gardons pas ces ethers. Cliquez sur le bouton orange "1 ether" pour dire à MetaMask de créer une transaction qui paie au faucet 1 ether. MetaMask préparera la transaction et une fenêtre apparaitra avec la confirmation, comme montrée sur  <1>.


[[send_to_faucet]]
.Envoyé 1 ether au faucet
image::images/send_to_faucet.png["Sending 1 ether to the faucet"]

Oups ! Vous avez sûrement remarqué que nous n'avions pas effectué la transaction&#x2014;. MetaMask dit que votre solde est insuffisant. Au premier coup d'oeil c'est surprenant: nous avons 1 ETH, nous voulons envoyer 1 ETH, donc pourquoi MetaMask nous dit que nous n'avons pas assez ? 

((("gas","basics")))La réponse est à cause du coût du gaz. Chaque transaction Ethereum nécessite le paiement de frais, qui sont récupérés par les mineurs pour valider la transaction. Les frais sur Ethereum sont affichés dans une monnaie virtuelle appelée le gaz. Vous payez le gaz avec de l'ether, lors de la transaction. 

[NOTE]
====
((("gas","on test networks")))Des frais son également demandés sur les réseaux de test. Sans les frais, un réseau de test fonctionnera différemment du réseau principal, le rendant inadapté pour une plateforme de test. Les frais protègent également les réseaux de test des attaques DoS et des contrats peu élaborés (par exemple les boucles infinies), plus qu'ils ne protègent le réseau principal.
====

Quand vous envoyez la transaction, MetaMask calcule le prix moyen de gaz des récentes  transactions validées à 3 gwei, qui signifie gigawei. Le wei est la plus petite unité de l'ether, comme nous en avions parlé dans le <2>. La limite de gaz est définie comme étant le coût d'une transaction normale, qui est de 21 000 unités de gaz. Par conséquent, le montant maximal d'ETH que vous pouvez dépenser est 3 * 21 000 gwei = 63 000 gwei = 0.000063 ETH. (Ayant conscience que le prix moyen du gaz peut fluctuer, étant majoritairement fixé par les mineurs. Nous verrons dans le dernier chapitre comment vous pouvez augmenter ou réduire la limite de gaz pour vous assurer que votre transaction soit priorisée si besoin). 

Tout ça pour dire: faire une transaction d'1 ETH coûte 1.000063 ETH. MetaMask arrondit à 1 ETH lorsqu'il affiche le total, mais le montant réel dont vous avez besoin est de 1.000063 ETH et vous avez juste 1 ETH. Cliquez sur Rejetez pour annuler cette transaction.

Récupérons plus d'ether de test ! Cliquez sur le bouton vert "demander 1 ether au faucet" à nouveau et attendez quelques secondes. Ne vous inquiétez pas, le faucet doit avoir plein d'ether et vous en donnera si vous demandez.

Une fois que vous avez un solde de 2 ethers, vous pouvez essayer à nouveau. Cette fois, quand vous cliquez sur le bouton orange de donation "1 ether", vous avez un solde suffisant pout finaliser la transaction. Cliquez sur Soumettre quand MetaMask affiche la fenêtre de paiement. Après ça, vous devriez voir un solde de 0.999937 ETH parce que vous avez envoyé 1 ETH au faucet avec  0.000063 ETH de gaz.(((range="endofrange", startref="ix_02intro-asciidoc7")))(((range="endofrange", startref="ix_02intro-asciidoc6")))

[[explore_tx_history]]
==== Exploration de l'historique des transactions d'une adresse

((("addresses","exploring transaction history of", id="ix_02intro-asciidoc8", range="startofrange")))((("MetaMask","exploring transaction history of an address with", id="ix_02intro-asciidoc9", range="startofrange")))Dès à présent vous êtes devenu un expert dans l'utilisation de MetaMask pour envoyer et recevoir des ethers de test. Votre portefeuille a reçu au moins deux paiements et envoyé un. Vous pouvez voir toutes les transactions en utilisant l'explorateur de block  ropsten.etherscan.io. Vous pouvez aussi bien copier l'adresse de votre portefeuille dans la barre de recherche du site, ou ouvrir la page via MetaMask. A côté de l'icone de votre compte dans MetaMask, vous avez un bouton montrant trois points. Cliquiez dessus pour voir le menu d'options relatifs à votre compte. (see <1>).

[[metamask_account_context_menu]]
.Menu contextuel du compte MetaMask
image::images/metamask_account_context_menu.png["Menu contextuel du compte MetaMask"]

Sélectionnez "Voir le compte sur Etherscan" pour ouvrir une page web dans l'explorateur de blocks montrant l'historique de transactions de votre compte, comme montré dans <1>.

[[block_explorer_account_history]]
Historique de transactions de l'adresse sur Etherscan
image::images/block_explorer_account_history.png["Address Transaction History on Etherscan"]

Vous pouvez voir l'historique complet de transactions de votre adresse Ethereum. Cela montre toutes les transactions enregistrées sur la blockchain Ropsten où votre adresse est l'envoyeur et le destinataire. Cliquez sur certaines de ces transactions pour voir plus de détails.

Vous pouvez explorer l'historique de transactions de n'importe quelle adresse. Jetez un oeil à l'historique de transactions du Faucet Test Ropsten (indice: c'est l'adresse de l'envoyeur de votre plus vieux paiement sur votre adresse). Vous pouvez voir tous les ethers de test envoyés depuis le faucet vers vous et d'autres adresses. Vous allez vite être perdus dans un labyrinthe de données interconnectées. Les blockchains publiques contiennent une énorme quantité d'information, toutes pouvant être explorées via programmation, comme nous le verrons par la suite. examples(((range="endofrange", startref="ix_02intro-asciidoc9")))(((range="endofrange", startref="ix_02intro-asciidoc8"))).(((range="endofrange", startref="ix_02intro-asciidoc3")))(((range="endofrange", startref="ix_02intro-asciidoc2")))

[[intro_world_computer]]
=== Introduction à l'Ordinateur Universel

((("Ethereum (generally)","and EVM")))((("EVM (Ethereum Virtual Machine)","as world computer")))((("world computer, Ethereum as")))Vous avez maintenant crée un portefeuille, envoyé et reçu des ethers. Jusqu'à maintenant, nous avons considéré Ethereum comme une  monnaie. En réalité, la fonction de cryptomonnaie découle de la fonction d'Ethereum comme ordinateur universel décentralisé. ((("smart contracts","ether and")))Ether est défini pour être utilisé pour payer le fonctionnement de contrats intelligents (smart contracts) qui sont des programmes qui tournent sur un ordinateur émulé appelé Machine Virtuelle Ethereum (MVE ou EVM en anglais).

La MVE est une entité mondiale, signifiant qu'elle fonctionne comme si c'était un seul ordinateur mondial fonctionnait n'importe où. Chaque nœud sur le réseau Ethereum exécute une copie locale de la MVE pour valider l'exécution des contrats, tandis que la blockchain Ethereum enregistre le changement d'état de cet ordinateur mondial étant donné qu'il exécute des transactions et des contrats intelligents. Nous parlerons de ceci plus en détails au  <1>.

[[EOA_contracts]]
=== Contrats et Comptes Détenus en Externe

((("contract accounts", seealso="smart contracts")))((("EOA (Externally Owned Account)","basics")))((("Ethereum (generally)","EOAs and contracts")))((("smart contracts","basics")))Le type de compte que vous avez crée dans le portefeuille MetaMask est appelé un compte détenu en externe (CDE). Les comptes détenus en externe sont ceux qui possèdent une clé privée; avoir les clés privées signifie avoir le contrôle des fonds et des contrats. Maintenant, vous devenez probablement qu'il existe un autre type de contrat. Cet autre type est le compte de contrat. Un compte de contrat contient le code d'un contrat intelligent, ce qu'un simple CDE ne peut avoir. De plus, un compte de contrat n'a pas de clé privée. A la place, il est détenu (et contrôlé) par la logique du code du contrat intelligent: le programme enregistré sur la blockchain Ethereum surle compte du contrat et est exécuté par la MVE.

Les contrats ont des adresses, tout comme les CDE. Les contrats peuvent aussi envoyer et recevoir de l'ether, tout comme les CDE. Cependant, quand l'adresse de destination est l'adresse d'un contrat, cela déclenche l'exécution de ce contrat sur la MVE, utilisant la transaction, et les données de cette transaction, comme une valeur d'entrée. En plus de l'ether, la transaction contient des données indiquant quelle fonction spécifique dans le contrat à exécuter et quels paramètres sont à transmettre à cette fonction. De cette façon, les transactions peuvent appeler des fonctions de contrats.

Notez que parce qu'un compte de contrat n'a pas de clé privée, il ne peut pas initier une transaction. Seuls les CDE peuvent initier une transaction, mais les contrats peuvent réagir à ces transactions en appelant d'autres contrats, débouchant sur de complexes exécutions. Une utilisation typique est un CDE envoyant une demande de transaction à un contrat de portefeuille multi-signature d'envoyer quelques ETH à une autre adresse. Un schéma typique de programmation d'une DApp est d'avoir un contrat A appelant un contrat B afin de maintenir un statut commun parmi les utilisateurs du contrat A.

Dans les prochaines parties, nous allons écrire notre premier contrat intelligent. Vous allez ensuite apprendre à créer, alimenter et utiliser ce contrat avec votre portefeuille MetaMask et des ethers sur le réseau de test Ropsten.

[[simple_contract_example]]
=== Un contrat simple: un Ether de test Faucet

((("contract accounts","creating", seealso="Faucet.sol contract", id="ix_02intro-asciidoc10", range="startofrange")))((("Faucet.sol contract (test example)","creating", id="ix_02intro-asciidoc11", range="startofrange")))Ethereum possède différents langages de haut-niveau tous pouvant servir à écrire un contrat ou produire du code pour la MVE. Vous pouvez lire parmi les plus importants et intéressants à  <1>. Un langage de haut-niveau est de loin le meilleur choix pour programmer un contrat intelligent: Solidity. ((("Wood, Dr. Gavin","and Solidity")))Solidity a été créé par le Dr. Gavin Wood, co-auteur de ce livre, et il est devenu le langage le plus utilisé sur Ethereum (et ailleurs). Nous utilisons tous Solidity pour créer notre premier contrat. 

((("Solidity","faucet.sol and")))Pour notre premier exemple (<1>), nous allons écrire un contrat qui contrôle un faucet. Vous avez déjà utilisé un faucet pour obtenir des ethers sur le réseau de test Ropsten. Un faucet est particulièrement simple: il donne de l'ether à n'importe quelle adresse qui le demande, et peut être rechargé périodiquement. Vous pouvez définir un faucet comme un portefeuille contrôlé par un humain ou un serveur web. 

[[solidity_faucet_example]]
.Faucet.sol: Un contrat Solidity créant un faucet
====
[source,solidity,linenums]
----
include::code/Solidity/Faucet.sol[]
----
====

[NOTE]
====
Vous trouverez dans ce livre tous les exemples de code dan le fichier de code à l'adresse: https://github.com/ethereumbook/ethereumbook/[the book's GitHub repository]. En particulier, notre contrat 'Faucet.sol' se trouve: 

----
code/Solidity/Faucet.sol
----
====

C'est un contrat très simple, aussi simple que possible. C'est également un contrat défectueux, qui met en avant un certain nombre de mauvaises pratiques et de brèches de sécurité. Nous apprendrons à étudier ces erreurs dans les prochaines parties. Pour l'instant, étudions qu'est-ce que le contrat fait et comment il fonctionne, ligne par ligne. Vous allons vous apercevoir que beaucoup d'éléments dans Solidity sont similaires à d'autres langages, tels que JavaScript, Java ou C++.

La première ligne est un commentaire:

[[comment]]
[source,solidity]
----
// Notre premier contrat est un faucet!
----

Les commentaires se destinent aux humains et ne sont pas inclus dans le code exécuté par la MVE. Habituellement, nous les inscrivons sur la ligne précédant le code que nous souhaitons expliquer, ou parfois sur la même ligne. Les commentaires commencent avec deux slash tel que "//". Tout ce qui se trouve entre le premier slash jusqu'à la fin de la ligne est considéré comme une ligne vide et est ignoré.

La ligne suivante est où notre contrat commence:

[[contract_definition]]
[source,solidity]
----
contract Faucet {
----

Cette ligne déclare l'objet "contract", similaire à la déclarations de "class" dans d'autres langages orientés objet. Le code du contrat inclut tout ce qui se trouve dans les accolades "{}", définissant ainsi l'étendue du contrat, tout comme les accolades sont utilisées dans d'autres langages de programmation. 

Ensuite, nous déclarons la premier fonction du contrat "Faucet"

[[withdraw_function]]
[source,solidity]
----
function withdraw(uint withdraw_amount) public {
----

La fonction est appelée "retrait" (withdraw en anglais) et elle contient comme argument un entier non-signé ("uint") appelé "withdraw_amount". Elle est déclarée comme fonction publique, ce qui signifie qu'elle peut être appelée par d'autres contrats. La définition de la fonction est contenue entre deux accolades. La première partie de la fonction "withdraw" définit la limite de retraits: 

[[withdraw_limit]]
[source,solidity]
----
require(withdraw_amount <= 100000000000000000);
----

La fonction utilise l'intégrateur Solidity ("built-in" en anglais) "require" comme pré-requis, qui vérifie que le montant retiré ''withdraw_amount' est plus petit ou égal à  100,000,000,000,000,000 wei, qui est la plus petite unité de l'ether (voir à <1>) et équivaut à 0,1 ether. Si la fonction "withdraw" est appelée avec un montant "withdraw_amount" plus que ce montant, la fonction "require" arrêtera l'exécution du contrat et provoquera une erreur "execption". Notez que les déclarations doivent être achevées d'un point-virgule.

Cette partie du contrat est la clé de voûte du faucet. Elle contrôle les flux sortants du contrat en fixant une limite de retraits. C'est un contrôle très simple qui peut vous donner un aperçu du pouvoir de la programmation sur la blockchain: un programme décentralisé contrôlant de l'argent. 

Ensuite vient la vraie fonction retrait: 

[[withdraw_command]]
[source,solidity]
----
msg.sender.transfer(withdraw_amount);
----

Plusieurs points intéressants se produisent à ce moment. L'objet message "msg" est une des valeurs d'entrée à laquelle les contrats peuvent accéder. Cela représente la transaction qui déclenche l'exécution du contrat. L'attribut "envoyeur" ("sender" en anglais) est l'adresse de l'envoyeur de la transaction.  La fonction "transférer" ("transfer en anglais) est une fonction intégratrice qui transfère les ethers du contrat vers l'adresse de l'envoyeur. En lisant à l'envers, cela signfie qu'il y a un "transfert" à "l'envoyeur" du "message" qui a déclenché l'exécution du contrat. La fonction "transfer" prend en seul argument le montant. Nous passons sur la valeur "withdraw_amount" qui est le paramètre de la fonction "withdraw" décrit quelques lignes plus haut. 

La prochaine ligne est une accolade de clôture, qui indique la fin de la définition de la fonction "withdraw".

Ensuitre, nous déclarons une fonction de plus: 

[[fallback_function]]
[source,solidity]
----
function () external payable {}
----

((("fallback function")))This function is a so-called _fallback_ or _default_ function, which is called if the transaction that triggered the contract didn't name any of the declared functions in the contract, or any function at all, or didn't contain data. Contracts can have one such default function (without a name) and it is usually the one that receives ether. That's why it is defined as an external and payable function, which means it can accept ether into the contract. It doesn't do anything, other than accept the ether, as indicated by the empty definition in the curly braces pass:[(<code>{}</code>)]. If we make a transaction that sends ether to the contract address, as if it were a wallet, this function will handle it.

Juste en-dessous de notre fonction par défaut se trouve l'accolade de fermeture, qui ferme la définition du contrat "Faucet". C'est tout !

[[compile_faucet_contract]]
=== Compilation du contrat Faucet

((("compiling","Faucet.sol contract", id="ix_02intro-asciidoc12", range="startofrange")))((("Faucet.sol contract (test example)","compiling", id="ix_02intro-asciidoc13", range="startofrange")))Now that we have our first example contract, we need to use a Solidity compiler to convert the Solidity code into EVM bytecode so it can be executed by the EVM on the blockchain itself.

The Solidity compiler comes as a standalone executable, as part of various frameworks, and bundled in Integrated Development Environments (IDEs). To keep things simple, we will use one of the more popular IDEs, called _Remix_.

((("Remix IDE")))Use your Chrome browser (with the MetaMask wallet you installed earlier) to navigate to the Remix IDE at https://remix.ethereum.org[].

When you first load Remix, it will start with a sample contract called _ballot.sol_. We don't need that, so close it by clicking the +x+ on the corner of the tab, as seen in <<remix_close_tab>>.

[[remix_close_tab]]
.Close the default example tab
image::images/remix_close_tab.png["Close the default example tab"]

Maintenant, ajoutez un nouvel onglet en cliquant sur le signe plus sur la barre d'outils en haut à gauche, comme montré dans <1>. Nommez le nouveau fichier "Faucet.sol"

[[remix_toolbar]]
*Cliquez sur le signe plus pour ouvrir un nouvel onglet
image::images/remix_toolbar.png["Click the plus sign to open a new tab"]

Une fois que vous avez le nouvel onglet ouvert, copier et coller le code depuis l'exemple "Faucet.sol", comme montré dans <1>.

[[remix_faucet_load]]
.Copy the Faucet example code into the new tab
image::images/remix_faucet_load.png["Copy the Faucet example code into the new tab"]

Once you have loaded the _Faucet.sol_ contract into the Remix IDE, the IDE will automatically compile the code. If all goes well, you will see a green box with "Faucet" in it appear on the right, under the Compile tab, confirming the successful compilation (see <<remix_compile>>).

[[remix_compile]]
.Remix successfully compiles the Faucet.sol contract
image::images/remix_compile.png[""]

If something goes wrong, the most likely problem is that the Remix IDE is using a version of the Solidity compiler that is different from 0.5.12. In that case, our pragma directive will prevent _Faucet.sol_ from compiling. To change the compiler version, go to the Settings tab, set the version to 0.5.12, and try again.

The Solidity compiler has now compiled our _Faucet.sol_ into EVM bytecode. If you are curious, the bytecode looks like this:

[[faucet_bytecode]]
----
PUSH1 0x60 PUSH1 0x40 MSTORE CALLVALUE ISZERO PUSH2 0xF JUMPI PUSH1 0x0 DUP1
REVERT JUMPDEST PUSH1 0xE5 DUP1 PUSH2 0x1D PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN
STOP PUSH1 0x60 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT PUSH1 0x3F JUMPI
PUSH1 0x0 CALLDATALOAD PUSH29
0x100000000000000000000000000000000000000000000000000000000
SWAP1 DIV PUSH4 0xFFFFFFFF AND DUP1 PUSH4 0x2E1A7D4D EQ PUSH1 0x41 JUMPI
JUMPDEST STOP JUMPDEST CALLVALUE ISZERO PUSH1 0x4B JUMPI PUSH1 0x0 DUP1 REVERT
JUMPDEST PUSH1 0x5F PUSH1 0x4 DUP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1
SWAP2 SWAP1 POP POP PUSH1 0x61 JUMP JUMPDEST STOP JUMPDEST PUSH8
0x16345785D8A0000 DUP2 GT ISZERO ISZERO ISZERO PUSH1 0x77 JUMPI PUSH1 0x0 DUP1
REVERT JUMPDEST CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND
PUSH2 0x8FC DUP3 SWAP1 DUP2 ISZERO MUL SWAP1 PUSH1 0x40 MLOAD PUSH1 0x0 PUSH1
0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP6 DUP9 DUP9 CALL SWAP4 POP POP POP POP ISZERO
ISZERO PUSH1 0xB6 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP JUMP STOP LOG1 PUSH6
0x627A7A723058 KECCAK256 PUSH9 0x13D1EA839A4438EF75 GASLIMIT CALLVALUE LOG4 0x5f
PUSH24 0x7541F409787592C988A079407FB28B4AD000290000000000
----

Aren't you glad you are using a high-level language like Solidity instead of programming directly in EVM bytecode? Me too!(((range="endofrange", startref="ix_02intro-asciidoc13")))(((range="endofrange", startref="ix_02intro-asciidoc12")))

[[create_contract]]
=== Création du contrat sur la blockchain

((("blockchain","creating contract on", id="ix_02intro-asciidoc14", range="startofrange")))((("Faucet.sol contract (test example)","on the blockchain", id="ix_02intro-asciidoc15", range="startofrange")))So, we have a contract. We've compiled it into bytecode. Now, we need to "register" the contract on the Ethereum blockchain. We will be using the Ropsten testnet to test our contract, so that's the blockchain we want to submit it to.

((("zero address","contract registration")))Registering a contract on the blockchain involves creating a special transaction whose destination is the address +0x0000000000000000000000000000000000000000+, also known as the _zero address_. The zero address is a special address that tells the Ethereum blockchain that you want to register a contract. Fortunately, the Remix IDE will handle all of that for you and send the transaction to MetaMask.

((("Remix IDE", id="ix_02intro-asciidoc16", range="startofrange")))First, switch to the Run tab and select Injected Web3 in the Environment drop-down selection box. This connects the Remix IDE to the MetaMask wallet, and through MetaMask to the Ropsten test network. Once you do that, you can see Ropsten under Environment. Also, in the Account selection box it shows the address of your wallet (see <<remix_run>>).

[[remix_run]]
.Remix IDE Run tab, with Injected Web3 environment selected
image::images/remix_run.png["Remix IDE Run tab, with Injected Web3 environment selected"]

Right below the Run settings you just confirmed is the +Faucet+ contract, ready to be created. Click on the Deploy button shown in <<remix_run>>.

Remix will construct the special "creation" transaction and MetaMask will ask you to approve it, as shown in <<remix_metamask_create>>. You'll notice the contract creation transaction has no ether in it, but it has 262 bytes of data (the compiled contract) and will consume 10 gwei in gas. Click Submit to approve it.

[[remix_metamask_create]]
.MetaMask showing the contract creation transaction
image::images/remix_metamask_create.png["MetaMask showing the contract creation transaction"]

Now you have to wait. It will take about 15 to 30 seconds for the contract to be mined on Ropsten. Remix won't appear to be doing much, but be patient.

Once the contract is created, it appears at the bottom of the Run tab (see <<remix_contract_interact>>).

[[remix_contract_interact]]
.The Faucet contract is ALIVE!
image::images/remix_contract_interact.png["The Faucet contract is ALIVE!"]

Notice that the +Faucet+ contract now has an address of its own: Remix shows it as &#x201c;Faucet at 0x72e...c7829&#x201d; (although your address, the random letters and numbers, will be different). The small clipboard symbol to the right allows you to copy the contract address to your clipboard. We will use that in the next section.(((range="endofrange", startref="ix_02intro-asciidoc16")))(((range="endofrange", startref="ix_02intro-asciidoc15")))

[[interact_contract]]
=== Interagir avec le contrat

((("Faucet.sol contract (test example)","interacting with", id="ix_02intro-asciidoc17", range="startofrange")))Let's recap what we've learned so far: Ethereum contracts are programs that control money, which run inside a virtual machine called the EVM. They are created by a special transaction that submits their bytecode to be recorded on the blockchain. Once they are created on the blockchain, they have an Ethereum address, just like wallets. Anytime someone sends a transaction to a contract address it causes the contract to run in the EVM, with the transaction as its input. Transactions sent to pass:[<span class="keep-together">contract</span>] addresses may have ether or data or both. If they contain ether, it is "deposited" to the contract balance. If they contain data, the data can specify a named function in the contract and call it, passing arguments to the function.

[[view_contract_address]]
==== Affichage de l'adresse du contrat dans un explorateur de blocs

((("Faucet.sol contract (test example)","viewing contract address in a block explorer")))We now have a contract recorded on the blockchain, and we can see it has an Ethereum address. Let's check it out in the _ropsten.etherscan.io_ block explorer and see what a contract looks like. In the Remix IDE, copy the address of the contract by clicking the clipboard icon next to its name (see <<remix_contract_address>>).

[[remix_contract_address]]
.Copy the contract address from Remix
image::images/remix_contract_address.png["Copy the contract address from Remix"]

Keep Remix open; we'll come back to it again later. Now, navigate your browser to _ropsten.etherscan.io_ and paste the address into the search box. You should see the contract's Ethereum address history, as shown in <<etherscan_contract_address>>.(((range="endofrange", startref="ix_02intro-asciidoc17")))

[[etherscan_contract_address]]
.View the Faucet contract address in the Etherscan block explorer
image::images/etherscan_contract_address.png["View the Faucet contract address in the etherscan block explorer"]

[[fund_contract]]
==== Financement du contrat

((("Faucet.sol contract (test example)","sending ether to", id="ix_02intro-asciidoc18", range="startofrange")))For now, the contract only has one transaction in its history: the contract creation transaction. As you can see, the contract also has no ether (zero balance). That's because we didn't send any ether to the contract in the creation transaction, even though we could have.

Our faucet needs funds! Our first project will be to use MetaMask to send ether to the contract. You should still have the address of the contract in your clipboard (if not, copy it again from Remix). Open MetaMask, and send 1 ether to it, exactly as you would to any other Ethereum address (see <<metamask_send_to_contract>>).

[[metamask_send_to_contract]]
.Send 1 ether to the contract address
image::images/metamask_send_to_contract.png[""]

In a minute, if you reload the Etherscan block explorer, it will show another transaction to the contract address and an updated balance of 1 ether.

Remember the unnamed default external payable function in our _Faucet.sol_ code? It looked like this:

[[fallback_function_review]]
[source,solidity]
----
function () external payable {}
----

When you sent a transaction to the contract address, with no data specifying which function to call, it called this default function. Because we declared it as +payable+, it accepted and deposited the 1 ether into the contract's account balance. Your transaction caused the contract to run in the EVM, updating its balance. You have funded your faucet!(((range="endofrange", startref="ix_02intro-asciidoc18")))

[[withdraw_from_contract]]
==== Résiliation de notre contrat

((("Faucet.sol contract (test example)","withdrawing funds from", id="ix_02intro-asciidoc19", range="startofrange")))((("withdrawal of funds from contract", id="ix_02intro-asciidoc20", range="startofrange")))Next, let's withdraw some funds from the faucet. To withdraw, we have to construct a transaction that calls the +withdraw+ function and passes a +withdraw_amount+ argument to it. To keep things simple for now, Remix will construct that transaction for us and MetaMask will present it for our approval.

Return to the Remix tab and look at the contract on the Run tab. You should see a orange box labeled +withdraw+ with a field entry labeled +uint256 withdraw_amount+ (see <<remix_contract_withdraw>>).

[[remix_contract_withdraw]]
.The withdraw function of Faucet.sol, in Remix
image::images/remix_contract_interact.png["The withdraw function of Faucet.sol, in Remix"]

This is the Remix interface to the contract. It allows us to construct transactions that call the functions defined in the contract. We will enter a +withdraw_amount+ and click the withdraw button to generate the transaction.

First, let's figure out the +withdraw_amount+. We want to try and withdraw 0.1 ether, which is the maximum amount allowed by our contract. Remember that all currency values in Ethereum are denominated in wei internally, and our +withdraw+ function expects the +withdraw_amount+ to be denominated in wei too. The amount we want is 0.1 ether, which is 100,000,000,000,000,000 wei (a 1 followed by 17 zeros).



[TIP]
====
Due to a limitation in JavaScript, a number as large as 10^17 cannot be processed by Remix. Instead, we enclose it in double quotes, to allow Remix to receive it as a string and manipulate it as a +BigNumber+. If we don't enclose it in quotes, the Remix IDE will fail to process it and display "Error encoding arguments: Error: Assertion failed."
====

Type "100000000000000000" (with the quotes) into the +withdraw_amount+ box and click on the withdraw button (see <<remix_withdraw>>).

[[remix_withdraw]]
.Click "withdraw" in Remix to create a withdrawal transaction
image::images/remix_withdraw.png[""]

MetaMask will pop up a transaction window for you to approve. Click Confirm to send your withdrawal call to the contract (see <<metamask_withdraw>>).

[[metamask_withdraw]]
.MetaMask transaction to call the withdraw function
image::images/metamask_withdraw.png["MetaMask transaction to call the withdraw function"]

Wait a minute and then reload the Etherscan block explorer to see the transaction reflected in the +Faucet+ contract address history (see <<etherscan_withdrawal_tx>>).

[[etherscan_withdrawal_tx]]
.Etherscan shows the transaction calling the withdraw function
image::images/etherscan_withdrawal_tx.png["Etherscan shows the transaction calling the withdraw function"]


We now see a new transaction with the contract address as the destination and a value of 0 ether. The contract balance has changed and is now 0.9 ether because it sent us 0.1 ether as requested. But we don't see an "OUT" transaction in the _contract address history_.

Where's the outgoing withdrawal? A new tab has appeared on the contract's address history page, named Internal Transactions. ((("internal transaction (message)")))Because the 0.1 ether transfer originated from the contract code, it is an internal transaction (also called a _message_). Click on that tab to see it (see <<etherscan_withdrawal_internal>>).


This "internal transaction" was sent by the contract in this line of code (from the pass:[<code><span class="keep-together">withdraw</span></code>] function in _Faucet.sol_):

[[withdraw_command_review]]
[source,solidity]
----
msg.sender.transfer(withdraw_amount);
----

To recap: you sent a transaction from your MetaMask wallet that contained data instructions to call the +withdraw+ function with a +withdraw_amount+ argument of 0.1 ether. That transaction caused the contract to run inside the EVM. As the EVM ran the +Faucet+ contract's +withdraw+ function, first it called the +require+ function and validated that the requested amount was less than or equal to the maximum allowed withdrawal of 0.1 ether. Then it called the +transfer+ function to send you the ether. Running the +transfer+ function generated an internal transaction that deposited 0.1 ether into your wallet address, from the contract's balance. That's the one shown on the Internal Transactions tab in Etherscan(((range="endofrange", startref="ix_02intro-asciidoc20")))(((range="endofrange", startref="ix_02intro-asciidoc19"))).(((range="endofrange", startref="ix_02intro-asciidoc14")))

[[etherscan_withdrawal_internal]]
.Etherscan shows the internal transaction transferring ether out from the contract
image::images/etherscan_withdrawal_internal.png["Etherscan shows the internal transaction transferring ether out from the contract"]

[[intro_conclusion]]
=== Conclusions

In this chapter, you set up a wallet using MetaMask and funded it using a faucet on the Ropsten test network. You received ether into your wallet's Ethereum address, then you sent ether to the faucet's Ethereum address.

Next, you wrote a faucet contract in Solidity. You used the Remix IDE to compile the contract into EVM bytecode, then used Remix to form a transaction and created the +Faucet+ contract on the Ropsten blockchain. Once created, the +Faucet+ contract had an Ethereum address, and you sent it some ether. Finally, you constructed a transaction to call the +withdraw+ function and successfully asked for 0.1 ether. The contract checked the request and sent you 0.1 ether with an internal transaction.

It may not seem like much, but you've just successfully interacted with software that controls money on a decentralized world computer.

We will do a lot more smart contract programming in <<smart_contracts_chapter>> and learn about best practices and security considerations in <<smart_contract_security>>.(((range="endofrange", startref="ix_02intro-asciidoc0")))