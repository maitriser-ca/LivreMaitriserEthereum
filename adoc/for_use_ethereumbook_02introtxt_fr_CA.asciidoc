[[intro_chapter]]
== Les bases d'Ethereum

((("Ethereum (généralement)","basics", id="ix_02intro-asciidoc0", range="startofrange"))) Dans ce chapitre, nous commencerons à explorer Ethereum, à apprendre à utiliser les portefeuilles, à créer des transactions, et aussi comment exécuter un contrat intelligent de base.

[[ether_units]]
=== L'ether comme unité monétaire

((("unités monétaires")))((("Ethereum (généralement)","unités monétaires")))L'unité monétaire d'Ethereum est appelée _ether_, également identifiée par "ETH" ou avec les symboles &#926; (de la lettre grecque « Xi » qui ressemble à un E majuscule stylisé) ou, moins souvent, &#9830;: par exemple, 1 ether, ou 1 ETH, ou &#926;1, ou &#9830;1.

[TIP]
====
Utilisez le caractère Unicode +U+039E+ pour &#926; et +U+2666+ pour &#9830;.
====

L'ether est subdivisé en unités plus petites, jusqu'à la plus petite unité possible, qui est nommée _wei_. Un ether est égal à 1 quintillion de wei (1 * 10^18^ ou 1 000 000 000 000 000 000). Vous entendrez peut-être aussi les gens se référer à la devise "Ethereum", mais c'est une erreur courante pour les débutants. Ethereum est le système, ether est la monnaie.

La valeur de l'ether est toujours représentée en interne dans Ethereum sous la forme d'une valeur entière non signée libellée en wei. Lorsque vous traitez 1 ether, la transaction encode 1000000000000000000 wei comme valeur.

Les différentes dénominations d'ether ont à la fois un _nom scientifique_ utilisant le Système international d'unités (_SI_) et un nom familier qui rend hommage à de nombreux grands esprits de l'informatique et de la cryptographie.

<<ether_denominations>> montre les différentes unités, leurs noms familiers (communs) et leurs noms SI. Conformément à la représentation interne de la valeur, le tableau montre toutes les dénominations en wei (première ligne), avec l'ether indiqué par 10^18^ wei dans la 7e ligne.

[[ether_denominations]]
.Dénominations d'ether et noms d'unités
[options="header"]
|===
| Valeur (en wei) | Exposant | Nom commun | Nom SI
| 1 | 1 | wei | Wei
| 1 000 | 10^3^ | Babbage | Kilowei ou femtoether
| 1 000 000 | 10^6^ | Lovelace | Mégawei ou picoether
| 1 000 000 000 | 10^9^ | Shanon | Gigawei ou nanoether
| 1 000 000 000 000 | 10^12^ | Szabo | Microether ou micro
| 1 000 000 000 000 000 | 10^15^ | Finney | Milliether ou milli
| _1 000 000 000 000 000 000_ | _10^18^_ | _Ether_ | _Ether_
| 1 000 000 000 000 000 000 000 | 10^21^ | grandiose | Kiloether
| 1 000 000 000 000 000 000 000 000 | 10^24^ | | Mégaether
|===

[[choosing_eth_wallet]]
=== Choisir un portefeuille Ethereum

((("Ethereum (généralement)","choix de portefeuille")))((("portefeuilles","choix")))((("portefeuilles","défini")))Le terme "portefeuille" est venu signifier beaucoup de choses, bien qu'elles soient toutes liées et qu'elles se résument au quotidien à peu près à la même chose. Nous utiliserons le terme "portefeuille" pour désigner une application logicielle qui vous aide à gérer votre compte Ethereum. En bref, un portefeuille Ethereum est votre passerelle vers le système Ethereum. Il détient vos clés et peut créer et diffuser des transactions en votre nom. Choisir un portefeuille Ethereum peut être difficile car il existe de nombreuses options différentes avec des caractéristiques et des conceptions différentes. Certains sont plus adaptés aux débutants et certains sont plus adaptés aux experts. La plate-forme Ethereum elle-même est toujours en cours d'amélioration, et les "meilleurs" portefeuilles sont souvent ceux qui s'adaptent aux changements qui accompagnent les mises à niveau de la plate-forme.

Mais ne vous inquiétez pas ! Si vous choisissez un portefeuille et que vous n'aimez pas son fonctionnement, ou si vous l'aimez au début, mais que vous souhaitez ensuite essayer autre chose, vous pouvez changer de portefeuille assez facilement. Tout ce que vous avez à faire est d'effectuer une transaction qui envoie vos fonds de l'ancien portefeuille vers le nouveau portefeuille, ou d'exporter vos clés privées et de les importer dans le nouveau.

Nous avons sélectionné trois types de portefeuilles différents à utiliser comme exemples tout au long du livre : un portefeuille mobile, un portefeuille de bureau et un portefeuille Web. Nous avons choisi ces trois portefeuilles car ils représentent un large éventail de complexité et de fonctionnalités. Cependant, la sélection de ces portefeuilles n'est pas une approbation de leur qualité ou de leur sécurité. Ils sont simplement un bon point de départ pour des démonstrations et des tests.

((("clés privées","portefeuilles et")))N'oubliez pas que pour qu'une application de portefeuille fonctionne, elle doit avoir accès à vos clés privées, il est donc essentiel que vous ne téléchargiez et n'utilisiez que des applications de portefeuille provenant de sources de confiance. Heureusement, en général, plus une application de portefeuille est populaire, plus elle est susceptible d'être fiable. Néanmoins, il est recommandé d'éviter de "mettre tous vos œufs dans le même panier" et de répartir vos comptes Ethereum sur plusieurs portefeuilles.

Voici quelques bons portefeuilles de démarrage :

MetaMask:: ((("MetaMask")))MetaMask est un portefeuille d'extension de navigateur qui s'exécute dans votre navigateur (Chrome, Firefox, Opera ou Brave Browser). Il est facile à utiliser et pratique pour les tests, car il est capable de se connecter à une variété de nœuds Ethereum et de tester des chaînes de blocs. MetaMask est un portefeuille basé sur le Web.

Jaxx:: ((("Jaxx")))((("wallets","Jaxx")))Jaxx est un portefeuille multiplateforme et multidevise qui fonctionne sur une variété de systèmes d'exploitation, y compris Android, iOS, Windows, macOS, et Linux. C'est souvent un bon choix pour les nouveaux utilisateurs car il est conçu pour la simplicité et la facilité d'utilisation. Jaxx est soit un portefeuille mobile, soit un portefeuille de bureau, selon l'endroit où vous l'installez.

MyEtherWallet (MEW):: ((("Ethereum Classic (ETC)","Portefeuille Emerald et")))((("MyEtherWallet (MEW)")))((("portefeuilles","Emerald Wallet")))((("portefeuilles","MyEtherWallet")))MyEtherWallet est un portefeuille Web qui s'exécute dans n'importe quel navigateur. Il possède de multiples fonctionnalités sophistiquées que nous explorerons dans plusieurs de nos exemples. MyEtherWallet est un portefeuille basé sur le Web.

Emerald Wallet:: ((("Emerald Wallet")))Emerald Wallet est conçu pour fonctionner avec la chaîne de blocs Ethereum Classic, mais est compatible avec d'autres chaînes de blocs basées sur Ethereum. C'est une application de bureau à source libre et fonctionne sous Windows, macOS et Linux. Emerald Wallet peut exécuter un nœud complet ou se connecter à un nœud distant public, fonctionnant en mode "léger". Il dispose également d'un outil compagnon pour effectuer toutes les opérations à partir de la ligne de commande.

Nous commencerons par installer MetaMask sur un bureau, mais nous aborderons d'abord brièvement le contrôle et la gestion des clés.

[[control_responsibility]]
=== Contrôle et responsabilité

((("Ethereum (généralement)","contrôle et responsabilité", id="ix_02intro-asciidoc1", range="startofrange")))Les chaînes de blocs ouvertes comme Ethereum sont importantes car elles fonctionnent comme un système _décentralisé_. Cela signifie beaucoup de choses, mais un aspect crucial est que chaque utilisateur d'Ethereum peut et doit contrôler ses propres clés privées, qui contrôlent l'accès aux fonds et aux contrats intelligents. Nous appelons parfois la combinaison de l'accès aux fonds et des contrats intelligents un "compte" ou un "portefeuille". Ces termes peuvent devenir assez complexes dans leur fonctionnalité, nous y reviendrons donc plus en détail plus tard. En tant que principe fondamental, cependant, c'est aussi simple qu'une clé privée équivaut à un "compte". Certains utilisateurs choisissent de renoncer au contrôle de leurs clés privées en utilisant un dépositaire tiers, tel qu'un échange en ligne. Dans ce livre, nous vous apprendrons à prendre le contrôle et à gérer vos propres clés privées.

Avec le contrôle vient une grande responsabilité. Si vous perdez vos clés privées, vous perdez l'accès à vos fonds et contrats. Personne ne peut vous aider à retrouver l'accès - vos fonds seront verrouillés pour toujours. Voici quelques conseils pour vous aider à gérer cette responsabilité :

* N'improvisez pas la sécurité. Utilisez des approches standardisées.

* Plus le compte est important (par exemple, plus la valeur des fonds contrôlés est élevée, ou plus les contrats intelligents accessibles sont importants), plus les mesures de sécurité doivent être prises.

* La sécurité la plus élevée est obtenue à partir d'un appareil isolé, mais ce niveau n'est pas requis pour tous les comptes.

* Ne stockez jamais votre clé privée en clair, en particulier sous forme numérique. Heureusement, la plupart des interfaces utilisateur actuelles ne vous permettent même pas de voir la clé privée brute.

* ((("clés privées","portefeuilles et")))Les clés privées peuvent être stockées sous forme cryptée, en tant que fichier "keystore" numérique. Étant cryptés, ils ont besoin d'un mot de passe pour se déverrouiller. Lorsque vous êtes invité à choisir un mot de passe, rendez-le fort (c'est-à-dire long et aléatoire), sauvegardez-le et ne le partagez pas. Si vous n'avez pas de gestionnaire de mots de passe, écrivez-le et conservez-le dans un endroit sûr et secret. Pour accéder à votre compte, vous avez besoin à la fois du fichier keystore et du mot de passe.

* Ne stockez aucun mot de passe dans des documents numériques, des photos numériques, des captures d'écran, des lecteurs en ligne, des PDF cryptés, etc. Encore une fois, n'improvisez pas la sécurité. Utilisez un gestionnaire de mots de passe ou un stylo et du papier.

* Lorsque vous êtes invité à sauvegarder une clé sous forme de séquence de mots mnémoniques, utilisez un stylo et du papier pour effectuer une sauvegarde physique. Ne laissez pas cette tâche "pour plus tard" ; vous oublierez. Ces sauvegardes peuvent être utilisées pour reconstruire votre clé privée au cas où vous perdriez toutes les données enregistrées sur votre système, ou si vous oubliez ou perdez votre mot de passe. Cependant, ils peuvent également être utilisés par des attaquants pour obtenir vos clés privées. Ne les stockez donc jamais sous forme numérique et conservez la copie physique en toute sécurité dans un tiroir ou un coffre-fort verrouillé.

* Avant de transférer des montants importants (en particulier vers de nouvelles adresses), effectuez d'abord une petite transaction test (par exemple, une valeur inférieure à 1 $) et attendez la confirmation de réception.

* Lorsque vous créez un nouveau compte, commencez par n'envoyer qu'une petite transaction test à la nouvelle adresse. Une fois que vous avez reçu la transaction de test, essayez de renvoyer à partir de ce compte. Il existe de nombreuses raisons pour lesquelles la création d'un compte peut mal tourner, et si cela a mal tourné, il vaut mieux le découvrir avec une petite perte. Si les tests fonctionnent, tout va bien.

* Les explorateurs de blocs publics sont un moyen simple de voir indépendamment si une transaction a été acceptée par le réseau. Cependant, cette commodité a un impact négatif sur votre vie privée, car vous révélez vos adresses pour bloquer les explorateurs, qui peuvent vous suivre.

* N'envoyez pas d'argent à l'une des adresses indiquées dans ce livre. Les clés privées sont répertoriées dans le livre et quelqu'un prendra immédiatement cet argent.

Maintenant que nous avons couvert quelques bonnes pratiques de base pour la gestion des clés et la sécurité, passons au travail avec MetaMask !(((range="endofrange", startref="ix_02intro-asciidoc1")))

[[installing_MetaMask]]
=== Premiers pas avec MetaMask

((("Ethereum (généralement)","Bases de MetaMask", id="ix_02intro-asciidoc2", range="startofrange")))((("MetaMask","bases", id="ix_02intro-asciidoc3", range="startofrange")))Ouvrez le navigateur Google Chrome et accédez à https://chrome.google.com/webstore/category/extensions[].

Recherchez "MetaMask" et cliquez sur le logo d'un renard. Vous devriez voir quelque chose comme le résultat affiché dans <<metamask_download>>.

[[metamask_download]]
.La page de détail de l'extension MetaMask Chrome
image::images/metamask_download.png["Page de détails du métamasque"]

Il est important de vérifier que vous téléchargez la véritable extension MetaMask, car parfois les gens sont capables de passer furtivement des extensions malveillantes au-delà des filtres de Google. Le vrai:

* Affiche l'ID +nkbihfbeogaeaoehlefnkodbefgpgknn+ dans la barre d'adresse
* Est offert par https://metamask.io
* A plus de 1 500 avis
* A plus de 1 000 000 d'utilisateurs

Une fois que vous avez confirmé que vous recherchez la bonne extension, cliquez sur "Ajouter à Chrome" pour l'installer.

[[using_MetaMask]]
==== Création d'un portefeuille

((("MetaMask","création d'un portefeuille", id="ix_02intro-asciidoc4", range="startofrange")))Une fois MetaMask installé, vous devriez voir une nouvelle icône (la tête d'un renard) dans la barre d'outils de votre navigateur. Cliquez dessus pour commencer. Il vous sera demandé d'accepter les termes et conditions puis de créer votre nouveau portefeuille Ethereum en saisissant un mot de passe (voir <<metamask_password>>).

[[metamask_password]]
.La page de mot de passe de l'extension MetaMask Chrome
image::images/metamask_password.png["Page de mot de passe du métamasque"]

[TIP]
====
Le mot de passe contrôle l'accès à MetaMask, de sorte qu'il ne peut être utilisé par personne ayant accès à votre navigateur.
====

((("mots de code mnémonique","MetaMask and", id="ix_02intro-asciidoc5", range="startofrange")))Une fois que vous avez défini un mot de passe, MetaMask générera un portefeuille pour vous et vous montrera un _mnémonique de sauvegarde_ composé de 12 mots anglais (voir <<metamask_mnemonic>>). Ces mots peuvent être utilisés dans n'importe quel portefeuille compatible pour récupérer l'accès à vos fonds si quelque chose arrivait à MetaMask ou à votre ordinateur. Vous n'avez pas besoin du mot de passe pour cette récupération ; les 12 mots suffisent.

[TIP]
====
Sauvegardez votre mnémonique (12 mots) sur papier, deux fois. Conservez les deux sauvegardes papier dans deux emplacements sécurisés distincts, tels qu'un coffre-fort résistant au feu, un tiroir verrouillé ou un coffre-fort. Traitez les sauvegardes papier comme de l'argent de valeur équivalente à ce que vous stockez dans votre portefeuille Ethereum. Toute personne ayant accès à ces mots peut y accéder et voler votre argent.
====

[[metamask_mnemonic]]
.La sauvegarde mnémonique de votre portefeuille, créée par MetaMask
image::images/metamask_mnemonic.png["Page Mnémonique MetaMask"]

Une fois que vous avez confirmé que vous avez stocké le mnémonique en toute sécurité, vous pourrez voir les détails de votre compte Ethereum, comme indiqué dans <<metamask_account>>.(((range="endofrange", startref="ix_02intro-asciidoc5")))

[[metamask_account]]
.Votre compte Ethereum dans MetaMask
image::images/metamask_account.png["Page de compte MetaMask"]

La page de votre compte affiche le nom de votre compte ("Account 1" par défaut), une adresse Ethereum (+0x9E713...+ dans l'exemple), et une icône colorée pour vous aider à distinguer visuellement ce compte des autres comptes. En haut de la page du compte, vous pouvez voir sur quel réseau Ethereum vous travaillez actuellement ("Main Network" dans l'exemple).

Toutes nos félicitations! Vous avez configuré votre premier portefeuille Ethereum.(((range="endofrange", startref="ix_02intro-asciidoc4")))

[[switching_networks]]
==== Changer le réseau

((("MetaMask","choix de réseau")))Comme vous pouvez le voir sur la page du compte MetaMask, vous pouvez choisir entre plusieurs réseaux Ethereum. Par défaut, MetaMask essaiera de se connecter au réseau principal. Les autres choix sont des réseaux de test publics, tout nœud Ethereum de votre choix ou des nœuds exécutant des chaînes de blocs privées sur votre propre ordinateur (localhost) :

Réseau principal Ethereum:: La principale chaîne de blocs publique Ethereum. Véritable ETH, valeur réelle et conséquences réelles.

Réseau de test Ropsten:: Chaîne de blocs et réseau de test public Ethereum. l'ETH sur ce réseau n'a aucune valeur.

Réseau de test Kovan:: Chaîne de blocs et réseau de test public Ethereum utilisant le protocole de consensus Aura avec preuve d'autorité (signature fédérée). ETH sur ce réseau n'a aucune valeur. Le réseau de test Kovan est uniquement pris en charge par Parity. D'autres clients Ethereum utilisent le protocole de consensus Clique, qui a été proposé plus tard, pour la preuve de la vérification basée sur l'autorité.

Réseau de test Rinkeby:: Chaîne de blocs et réseau de test public Ethereum, utilisant le protocole de consensus Clique avec preuve d'autorité (signature fédérée). ETH sur ce réseau n'a aucune valeur.

Localhost 8545:: Se connecte à un nœud exécuté sur le même ordinateur que le navigateur. Le nœud peut faire partie de n'importe quelle chaîne de blocs publique (principale ou testnet) ou d'un testnet privé.

RPC personnalisé:: vous permet de connecter MetaMask à n'importe quel nœud avec une interface d'appel de procédure distante (RPC) compatible Geth. Le nœud peut faire partie de n'importe quelle chaîne de blocs publique ou privée.

[NOTE]
====
Votre portefeuille MetaMask utilise la même clé privée et la même adresse Ethereum sur tous les réseaux auxquels il se connecte. Cependant, votre solde d'adresses Ethereum sur chaque réseau Ethereum sera différent. Vos clés peuvent contrôler l'ether et les contrats sur Ropsten, par exemple, mais pas sur le réseau principal.
====

[[getting_test_eth]]
==== Obtenir de l'ether de test

((("ether (généralement)","testnet")))((("MetaMask","et ether testnet")))((("ether test","obtention")))((("testnet","ether pour")))((("portefeuilles","ether testnet et")))Votre première tâche est de financer votre portefeuille. Vous ne ferez pas cela sur le réseau principal car l'ether réel coûte de l'argent et sa manipulation nécessite un peu plus d'expérience. Pour l'instant, vous allez charger votre portefeuille avec de l'ether testnet.

((("Réseau de test Ropsten")))Passez MetaMask au _Réseau test Ropsten_. Cliquez sur Deposit, puis sur Ropsten Test Faucet. MetaMask ouvrira une nouvelle page Web, comme indiqué dans <<metamask_ropsten_faucet>>.

[[metamask_ropsten_faucet]]
.MetaMask et le robinet du réseau test Ropsten
image::images/metamask_ropsten_faucet.png["MetaMask et le robinet du réseau test Ropsten"]

Vous remarquerez peut-être que la page Web contient déjà l'adresse Ethereum de votre portefeuille MetaMask. MetaMask intègre les pages Web compatibles Ethereum avec votre portefeuille MetaMask et peut "voir" les adresses Ethereum sur la page Web, vous permettant, par exemple, d'envoyer un paiement à une boutique en ligne affichant une adresse Ethereum. MetaMask peut également remplir la page Web avec l'adresse de votre propre portefeuille en tant qu'adresse de destinataire si la page Web le demande. Sur cette page, l'application du robinet demande à MetaMask une adresse de portefeuille à laquelle envoyer de l'ether de test.

Cliquez sur le bouton vert "demander 1 ether au robinet". Vous verrez un ID de transaction apparaître dans la partie inférieure de la page. L'application robinet ou "faucet" a créé une transaction, un paiement qui vous est destiné. L'ID de transaction ressemble à ceci :

[[faucet_tx_id]]
----
0x7c7ad5aaea6474adccf6f5c5d6abed11b70a350fbc6f9590109e099568090c57
----

Dans quelques secondes, la nouvelle transaction sera exploitée par les mineurs de Ropsten et votre portefeuille MetaMask affichera un solde de 1 ETH. Cliquez sur l'ID de transaction et votre navigateur vous amènera à un _explorateur de bloc_, qui est un site Web qui vous permet de visualiser et d'explorer des blocs, des adresses et des transactions. MetaMask utilise https://etherscan.io/[Explorateur de blocs Etherscan], l'un des explorateurs de blocs Ethereum les plus populaires. La transaction contenant le paiement du Ropsten Test Faucet est affichée dans <<ropsten_block_explorer>>.

[[ropsten_block_explorer]]
.Explorateur de blocs Ropsten sur Etherscan
image::images/ropsten_block_explorer.png["Explorateur de blocs Ropsten sur Etherscan"]

La transaction a été enregistrée sur la chaîne de blocs Ropsten et peut être consultée à tout moment par n'importe qui, simplement en recherchant l'ID de transaction, ou http://bit.ly/2Q860Wk[en visitant le lien].

Essayez de visiter ce lien ou de saisir le hachage de la transaction sur le site Web _ropsten.etherscan.io_ pour le voir par vous-même.

[[sending_eth_MetaMask]]
==== Envoi d'ether depuis MetaMask

((("MetaMask","envoi d'ether depuis", id="ix_02intro-asciidoc6", range="startofrange")))((("ether test","envoi", id="ix_02intro-asciidoc7", range ="startofrange")))Une fois que vous avez reçu votre premier test d'ether du Ropsten Test Faucet, vous pouvez expérimenter l'envoi d'ether en essayant d'en renvoyer au robinet. Comme vous pouvez le voir sur la page Ropsten Test Faucet, il existe une option pour "donner" 1 ETH au robinet. Cette option est disponible pour qu'une fois que vous avez terminé les tests, vous puissiez retourner le reste de votre ether de test, afin que quelqu'un d'autre puisse l'utiliser ensuite. Même si l'ether de test n'a aucune valeur, certaines personnes l'accumulent, ce qui rend difficile pour tout le monde d'utiliser les réseaux de test. L'accumulation de l'ether de test est mal vue !

Heureusement, nous ne sommes pas des accumulateurs d'ether de test. Cliquez sur le bouton orange "1 ether" pour dire à MetaMask de créer une transaction payant le robinet 1 ether. MetaMask préparera une transaction et ouvrira une fenêtre avec la confirmation, comme indiqué dans <<send_to_faucet>>.


[[send_to_faucet]]
.Envoi de 1 ether au robinet
image::images/send_to_faucet.png["Envoi d'1 ether au robinet"]

Oups! Vous avez probablement remarqué que vous ne pouvez pas terminer la transaction - MetaMask indique que vous avez un solde insuffisant. À première vue, cela peut sembler déroutant : vous avez 1 ETH, vous voulez envoyer 1 ETH, alors pourquoi MetaMask dit-il que vous avez des fonds insuffisants ?

((("gas","basics")))La réponse est à cause du coût de _gaz_. Chaque transaction Ethereum nécessite le paiement d'une redevance, qui est perçue par les mineurs pour valider la transaction. Les frais d'Ethereum sont facturés dans une monnaie virtuelle appelée gaz. Vous payez le gaz avec de l'ether, dans le cadre de la transaction.

[NOTE]
====
((("gaz","sur les réseaux de test")))Des frais sont également exigés sur les réseaux de test. Sans frais, un réseau de test se comporterait différemment du réseau principal, ce qui en ferait une plate-forme de test inadéquate. Les frais protègent également les réseaux de test des attaques DoS et des contrats mal construits (par exemple, des boucles infinies), tout comme ils protègent le réseau principal.
====

Lorsque vous avez envoyé la transaction, MetaMask a calculé le prix moyen du gaz des récentes transactions réussies à 3 gwei, ce qui signifie gigawei. Wei est la plus petite pass:[<span class="keep-together">subdivision</span>] de la monnaie ether, comme nous l'avons vu dans <<ether_units>>. La limite de gaz est fixée au prix de l'envoi d'une transaction de base, soit 21 000 unités de gaz. Par conséquent, le montant maximum d'ETH que vous dépenserez est de 3 * 21 000 gwei = 63 000 gwei = 0,000063 ETH. (Sachez que les prix moyens du gaz peuvent fluctuer, car ils sont principalement déterminés par les mineurs. Nous verrons dans un chapitre ultérieur comment vous pouvez augmenter/diminuer votre limite de gaz pour vous assurer que votre transaction a la priorité si nécessaire.)

Tout cela pour dire : faire une transaction à 1 ETH coûte 1,000063 ETH. MetaMask arrondit de manière confuse au _plancher_ d'1 ETH lors de l'affichage du total, mais le montant réel dont vous avez besoin est de 1,000063 ETH et vous n'avez que 1 ETH. Cliquez sur Reject pour annuler cette transaction.

Prenons un peu plus d'ether de test ! Cliquez à nouveau sur le bouton vert "request 1 ether from the faucet" et attendez quelques secondes. Ne vous inquiétez pas, le robinet devrait avoir beaucoup d'ether et vous en donnera plus si vous le demandez.

Une fois que vous avez un solde de 2 ETH, vous pouvez réessayer. Cette fois, lorsque vous cliquez sur le bouton de don orange "1 ether", vous disposez d'un solde suffisant pour finaliser la transaction. Cliquez sur Soumettre lorsque MetaMask apparaît dans la fenêtre de paiement. Après tout cela, vous devriez voir un solde de 0,999937 ETH car vous avez envoyé 1 ETH au robinet avec 0,000063 ETH en gaz.(((range="endofrange", startref="ix_02intro-asciidoc7")))(((range ="endofrange", startref="ix_02intro-asciidoc6")))

[[explore_tx_history]]
==== Explorer l'historique des transactions d'une adresse

((("addresses","exploration de l'historique des transactions des", id="ix_02intro-asciidoc8", range="startofrange")))((("MetaMask","exploration de l'historique des transactions d'une adresse avec", id=" ix_02intro-asciidoc9", range="startofrange")))Vous êtes maintenant devenu un expert dans l'utilisation de MetaMask pour envoyer et recevoir de l'ether de test. Votre portefeuille a reçu au moins deux paiements et en a envoyé au moins un. Vous pouvez afficher toutes ces transactions à l'aide de l'explorateur de blocs _ropsten.etherscan.io_. Vous pouvez soit copier l'adresse de votre portefeuille et la coller dans la zone de recherche de l'explorateur de blocs, soit demander à MetaMask d'ouvrir la page pour vous. À côté de l'icône de votre compte dans MetaMask, vous verrez un bouton affichant trois points. Cliquez dessus pour afficher un menu d'options liées au compte (voir <<metamask_account_context_menu>>).

[[metamask_account_context_menu]]
.Menu contextuel du compte MetaMask
image::images/metamask_account_context_menu.png["Menu contextuel du compte MetaMask"]

Sélectionnez "View account on Etherscan" pour ouvrir une page Web dans l'explorateur de blocs affichant l'historique des transactions de votre compte, comme indiqué dans <<block_explorer_account_history>>.

[[block_explorer_account_history]]
.Historique des transactions d'une adresse sur Etherscan
image::images/block_explorer_account_history.png["Historique des transactions d'adresses sur Etherscan"]

Ici, vous pouvez voir l'historique complet des transactions de votre adresse Ethereum. Il montre toutes les transactions enregistrées sur la chaîne de blocs Ropsten où votre adresse est l'expéditeur ou le destinataire. Cliquez sur quelques-unes de ces transactions pour voir plus de détails.

Vous pouvez explorer l'historique des transactions de n'importe quelle adresse. Jetez un œil à l'historique des transactions de l'adresse Ropsten Test Faucet (indice : il s'agit de l'adresse « expéditeur » répertoriée dans le plus ancien paiement à votre adresse). Vous pouvez voir tout l'ether de test envoyé par le robinet à vous et à d'autres adresses. Chaque transaction que vous voyez peut vous mener à plus d'adresses et plus de transactions. D'ici peu, vous serez perdu dans le labyrinthe de données interconnectées. Les chaînes de blocs publiques contiennent une énorme richesse d'informations, qui peuvent toutes être explorées par programmation, comme nous le verrons dans de futurs exemples(((range="endofrange", startref="ix_02intro-asciidoc9")))(((range="endofrange ", startref="ix_02intro-asciidoc8"))).(((range="endofrange", startref="ix_02intro-asciidoc3")))(((range="endofrange", startref="ix_02intro-asciidoc2")))

[[intro_world_computer]]
=== Présentation de l'ordinateur mondial

((("Ethereum (généralement)","et EVM")))((("EVM (Ethereum Virtual Machine)","comme ordinateur mondial")))((("ordinateur mondial, Ethereum comme"))) Vous avez maintenant créé un portefeuille et envoyé et reçu de l'ether. Jusqu'à présent, nous avons traité Ethereum comme une cryptomonnaie. Mais Ethereum est bien plus que cela. En fait, la fonction de cryptomonnaie est subordonnée à la fonction d'Ethereum en tant qu'ordinateur mondial décentralisé. ((("contrats intelligents","ether et")))L'ether est destiné à être utilisé pour payer l'exécution de _contrats intelligents_ aussi, qui sont des programmes informatiques qui s'exécutent sur un ordinateur émulé appelé _Ethereum Virtual Machine_ (EVM).

L'EVM est un singleton global, ce qui signifie qu'il fonctionne comme s'il s'agissait d'un ordinateur global à instance unique, fonctionnant partout. Chaque nœud du réseau Ethereum exécute une copie locale de l'EVM pour valider l'exécution du contrat, tandis que la chaîne de blocs Ethereum enregistre l'état changeant de cet ordinateur mondial lorsqu'il traite les transactions et les contrats intelligents. Nous en discuterons plus en détail dans <<evm_chapter>>.

[[EOA_contracts]]
=== Comptes détenus en externe (EOA ou Externally Owned Accounts) et contrats

((("comptes contractuels", voir aussi="contrats intelligents")))((("EOA (compte détenu en externe)","bases")))((("Ethereum (généralement)","EOA et contrats" )))((("contrats intelligents","bases")))Le type de compte que vous avez créé dans le portefeuille MetaMask est appelé un _compte détenu par une personne externe_ (EOA ou Externally Owned Accounts). Les comptes détenus en externe sont ceux qui ont une clé privée ; avoir la clé privée signifie contrôler l'accès aux fonds ou aux contrats. Maintenant, vous devinez probablement qu'il existe un autre type de compte. Cet autre type de compte est un _compte de contrat_. Un compte de contrat a un code de contrat intelligent, ce qu'un simple EOA ne peut pas avoir. De plus, un compte contractuel ne possède pas de clé privée. Au lieu de cela, il est détenu (et contrôlé) par la logique de son code de contrat intelligent : le programme logiciel enregistré sur la chaîne de blocs Ethereum lors de la création du compte de contrat et exécuté par l'EVM.

Les contrats ont des adresses, tout comme les EOA. Les contrats peuvent également envoyer et recevoir de l'ether, tout comme les EOA. Cependant, lorsqu'une destination de transaction est une adresse de contrat, cela provoque l'exécution de ce contrat dans l'EVM, en utilisant la transaction et les données de la transaction comme entrée. En plus d'ether, les transactions peuvent contenir des _données_ indiquant quelle fonction spécifique du contrat exécuter et quels paramètres transmettre à cette fonction. De cette façon, les transactions peuvent _appeler_ des fonctions dans les contrats.

Notez qu'étant donné qu'un compte de contrat n'a pas de clé privée, il ne peut pas _initier_ une transaction. Seuls les EOA peuvent initier des transactions, mais les contrats peuvent _réagir_ aux transactions en appelant d'autres contrats, en créant des chemins d'exécution complexes. Une utilisation typique de ceci est un EOA envoyant une transaction de demande à un portefeuille de contrats intelligents multisignatures pour envoyer des ETH à une autre adresse. Un modèle de programmation DApp typique consiste à ce que le contrat A appelle le contrat B afin de maintenir un état partagé entre les utilisateurs du contrat A.

Dans les prochaines sections, nous rédigerons notre premier contrat. Vous apprendrez ensuite comment créer, financer et utiliser ce contrat avec votre portefeuille MetaMask et tester l'ether sur le réseau de test Ropsten.

[[exemple_contrat_simple]]
=== Un contrat simple : un robinet test d'ether

((("comptes de contrat","création", seealso="Contrat Faucet.sol", id="ix_02intro-asciidoc10", range="startofrange")))((("Contrat Faucet.sol (exemple de test)" ,"création", id="ix_02intro-asciidoc11", range="startofrange"))) Ethereum possède de nombreux langages de haut niveau différents, qui peuvent tous être utilisés pour écrire un contrat et produire un code intermédiaire ou bytecode EVM. Vous pouvez lire sur bon nombre des plus importantes et des plus intéressantes dans <<high_level_languages>>. Un langage de haut niveau est de loin le choix dominant pour la programmation de contrats intelligents : Solidity. ((("Wood, Dr. Gavin","et Solidity")))Solidity a été créé par le Dr Gavin Wood, le co-auteur de ce livre, et est devenu le langage le plus largement utilisé dans Ethereum (et au-delà). Nous utiliserons Solidity pour rédiger notre premier contrat.

((("Solidity","faucet.sol et")))Pour notre premier exemple (<<solidity_faucet_example>>), nous allons écrire un contrat qui contrôle un _robinet_. Vous avez déjà utilisé un robinet pour obtenir de l'ether de test sur le réseau de test de Ropsten. Un robinet est une chose relativement simple: il donne de l'ether à toute adresse qui le demande et peut être rempli périodiquement. Vous pouvez implémenter un robinet comme un portefeuille contrôlé par un humain ou un serveur Web.

[[solidity_faucet_example]]
.Faucet.sol: Un contrat Solidity mettant en place un robinet
====
[source,solidity,linenums]
----
include::code/Solidity/Faucet.sol[]
----
====

[NOTE]
====
Vous trouverez tous les exemples de code pour ce livre dans le sous-répertoire _code_ de https://github.com/ethereumbook/ethereumbook/[le référentiel GitHub du livre]. Concrètement, notre contrat _Faucet.sol_ est en:

----
code/Solidity/Faucet.sol
----
====

Il s'agit d'un contrat très simple, à peu près aussi simple que possible. Il s'agit également d'un contrat _faussé_, démontrant un certain nombre de mauvaises pratiques et de failles de sécurité. Nous apprendrons en examinant tous ses défauts dans les sections suivantes. Mais pour l'instant, regardons ce que fait ce contrat et comment il fonctionne, ligne par ligne. Vous remarquerez rapidement que de nombreux éléments de Solidity sont similaires aux langages de programmation existants, tels que JavaScript, Java ou Cpass:[++].

La première ligne est un commentaire :

[[comment]]
[source,solidity]
----
// Notre premier contrat est un robinet (faucet) !
----

Les commentaires sont destinés à être lus par des humains et ne sont pas inclus dans le code intermédiaire exécutable de l'EVM. Nous les plaçons généralement sur la ligne avant le code que nous essayons d'expliquer, ou parfois sur la même ligne. Les commentaires commencent par deux barres obliques : `+//+`.Tout, depuis la première barre oblique jusqu'à la fin de cette ligne, est traité comme une ligne vide et ignoré.

La ligne suivante est l'endroit où notre contrat réel commence :

[[contract_definition]]
[source,solidity]
----
contract Faucet {
----

Cette ligne déclare un objet `+contract+`,similaire à une déclaration +class+ dans d'autres langages orientés objet. La définition du contrat inclut toutes les lignes entre les accolades (pass:[<code>{}</code>]), qui définissent une _portée_, un peu comme la façon dont les accolades sont utilisées dans de nombreux autres langages de programmation.

Ensuite, nous déclarons la première fonction du contrat +Faucet+ :

[[withdraw_function]]
[source,solidity]
----
function withdraw(uint withdraw_amount) public {
----

La fonction est nommée `+withdraw+`,et elle prend un argument entier non signé (`+uint+`)nommé `+withdraw_amount+`.Elle est déclarée fonction publique, c'est-à-dire qu'elle peut être appelée par d'autres contrats. La définition de la fonction suit, entre accolades. La première partie de la fonction +retirer+ fixe une limite aux retraits :

[[withdraw_limit]]
[source,solidity]
----
require(withdraw_amount <= 100000000000000000);
----

Il utilise la fonction intégrée Solidity +require+ pour tester une condition préalable, que le +withdraw_amount+ est inférieur ou égal à 100 000 000 000 000 000 wei, qui est l'unité de base de l'ether (voir <<ether_denominations>>) et équivalent à 0,1 ether. Si la fonction +withdraw+ est appelée avec un +withdraw_amount+ supérieur à ce montant, la fonction +require+ provoquera ici l'arrêt et l'échec de l'exécution du contrat avec une _exception_. Notez que les instructions doivent se terminer par un point-virgule dans Solidity.

Cette partie du contrat est la logique principale de notre robinet. Il contrôle le flux de fonds hors du contrat en imposant une limite aux retraits. C'est un contrôle très simple mais qui peut vous donner un aperçu de la puissance d'une chaîne de blocs programmable : un logiciel décentralisé contrôlant l'argent.

Vient ensuite le retrait proprement dit :

[[withdraw_command]]
[source,solidity]
----
msg.sender.transfer(withdraw_amount);
----

Quelques choses intéressantes se passent ici. L'objet +msg+ est l'une des entrées auxquelles tous les contrats peuvent accéder. Il représente la transaction qui a déclenché l'exécution de ce contrat. L'attribut +sender+ est l'adresse de l'expéditeur de la transaction. La fonction +transfer+ est une fonction intégrée qui transfère l'ether du contrat actuel à l'adresse de l'expéditeur. En le lisant à l'envers, cela signifie +transfert+ vers l'+expéditeur+ du +msg+ qui a déclenché l'exécution de ce contrat. La fonction +transfer+ prend un montant comme seul argument. Nous passons la valeur +withdraw_amount+ qui était le paramètre à la fonction +withdraw+ déclarée quelques lignes plus tôt.

La ligne suivante est l'accolade fermante, indiquant la fin de la définition de notre fonction +withdraw+.

Ensuite, nous déclarons une autre fonction :

[[fallback_function]]
[source,solidity]
----
function () external payable {}
----

((("fallback function")))Cette fonction est une fonction dite de _secours_ ou de _fallback_ (ou _default_), qui est appelée si la transaction qui a déclenché le contrat n'a nommé aucune des fonctions déclarées dans le contrat, ou aucune fonction du tout , ou ne contenait pas de données. Les contrats peuvent avoir une telle fonction par défaut (sans nom) et c'est généralement celle qui reçoit l'ether. C'est pourquoi il est défini comme une fonction externe et payante, ce qui signifie qu'il peut accepter de l'ether dans le contrat. Il ne fait rien d'autre que d'accepter l'ether, comme indiqué par la définition vide entre les accolades pass:[(<code>{}</code>)]. Si nous effectuons une transaction qui envoie de l'ether à l'adresse du contrat, comme s'il s'agissait d'un portefeuille, cette fonction s'en chargera.

Juste en dessous de notre fonction par défaut se trouve l'accolade fermante finale, qui ferme la définition du contrat `+Faucet+`.C'est tout !(((range="endofrange", startref="ix_02intro-asciidoc11")))(((range="endofrange", startref="ix_02intro-asciidoc10")))

[[compile_faucet_contract]]
=== Compilation du contrat de robinet

((("compilation","Contrat Faucet.sol", id="ix_02intro-asciidoc12", range="startofrange")))((("Contrat Faucet.sol (exemple de test)","compilation", id= "ix_02intro-asciidoc13", range="startofrange")))Maintenant que nous avons notre premier exemple de contrat, nous devons utiliser un compilateur Solidity pour convertir le code Solidity en code intermédiaire/bytecode EVM afin qu'il puisse être exécuté par l'EVM sur la chaîne de blocs elle-même .

Le compilateur Solidity se présente sous la forme d'un exécutable autonome, dans le cadre de divers frameworks, et regroupé dans des environnements de développement intégrés (IDE). Pour garder les choses simples, nous utiliserons l'un des IDE les plus populaires, appelé _Remix_.

((("Remix IDE")))Utilisez votre navigateur Chrome (avec le portefeuille MetaMask que vous avez installé précédemment) pour accéder à l'IDE Remix à l'adresse https://remix.ethereum.org[].

Lorsque vous chargez Remix pour la première fois, il démarre avec un exemple de contrat appelé _ballot.sol_. Nous n'en avons pas besoin, alors fermez-le en cliquant sur le `+x+` dans le coin de l'onglet, comme indiqué dans <<remix_close_tab>>.

[[remix_close_tab]]
.Fermer l'onglet d'exemple par défaut
image::images/remix_close_tab.png["Fermer l'onglet d'exemple par défaut"]

Maintenant, ajoutez un nouvel onglet en cliquant sur le signe plus circulaire dans la barre d'outils en haut à gauche, comme indiqué dans <<remix_toolbar>>. Nommez le nouveau fichier _Faucet.sol_.

[[remix_toolbar]]
.Cliquez sur le signe plus pour ouvrir un nouvel onglet
image::images/remix_toolbar.png["Cliquez sur le signe plus pour ouvrir un nouvel onglet"]

Une fois que vous avez ouvert le nouvel onglet, copiez et collez le code de notre exemple _Faucet.sol_, comme indiqué dans <<remix_faucet_load>>.

[[remix_faucet_load]]
.Copiez l'exemple de code Faucet dans le nouvel onglet
image::images/remix_faucet_load.png["Copiez l'exemple de code Faucet dans le nouvel onglet"]

Une fois que vous avez chargé le contrat _Faucet.sol_ dans l'IDE Remix, l'IDE compilera automatiquement le code. Si tout se passe bien, vous verrez une boîte verte avec "Faucet" dedans apparaître à droite, sous l'onglet Compiler, confirmant la compilation réussie (voir <<remix_compile>>).

[[remix_compile]]
.Remix compile avec succès le contrat Faucet.sol
image::images/remix_compile.png[""]

Si quelque chose ne va pas, le problème le plus probable est que l'IDE Remix utilise une version du compilateur Solidity différente de 0.5.12. Dans ce cas, notre directive pragma empêchera _Faucet.sol_ de se compiler. Pour modifier la version du compilateur, accédez à l'onglet Paramètres, définissez la version sur 0.5.12 et réessayez.

Le compilateur Solidity a maintenant compilé notre _Faucet.sol_ en code intermédiaire EVM. Si vous êtes curieux, le code intermédiaire ressemble à ceci :

[[faucet_bytecode]]
----
PUSH1 0x60 PUSH1 0x40 MSTORE CALLVALUE ISZERO PUSH2 0xF JUMPI PUSH1 0x0 DUP1
REVERT JUMPDEST PUSH1 0xE5 DUP1 PUSH2 0x1D PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN
STOP PUSH1 0x60 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT PUSH1 0x3F JUMPI
PUSH1 0x0 CALLDATALOAD PUSH29
0x100000000000000000000000000000000000000000000000000000000
SWAP1 DIV PUSH4 0xFFFFFFFF AND DUP1 PUSH4 0x2E1A7D4D EQ PUSH1 0x41 JUMPI
JUMPDEST STOP JUMPDEST CALLVALUE ISZERO PUSH1 0x4B JUMPI PUSH1 0x0 DUP1 REVERT
JUMPDEST PUSH1 0x5F PUSH1 0x4 DUP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1
SWAP2 SWAP1 POP POP PUSH1 0x61 JUMP JUMPDEST STOP JUMPDEST PUSH8
0x16345785D8A0000 DUP2 GT ISZERO ISZERO ISZERO PUSH1 0x77 JUMPI PUSH1 0x0 DUP1
REVERT JUMPDEST CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND
PUSH2 0x8FC DUP3 SWAP1 DUP2 ISZERO MUL SWAP1 PUSH1 0x40 MLOAD PUSH1 0x0 PUSH1
0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP6 DUP9 DUP9 CALL SWAP4 POP POP POP POP ISZERO
ISZERO PUSH1 0xB6 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP JUMP STOP LOG1 PUSH6
0x627A7A723058 KECCAK256 PUSH9 0x13D1EA839A4438EF75 GASLIMIT CALLVALUE LOG4 0x5f
PUSH24 0x7541F409787592C988A079407FB28B4AD000290000000000
----

N'êtes-vous pas content d'utiliser un langage de haut niveau comme Solidity au lieu de programmer directement en code intermédiaire EVM ? Moi aussi !(((range="endofrange", startref="ix_02intro-asciidoc13")))(((range="endofrange", startref="ix_02intro-asciidoc12")))

[[create_contract]]
=== Création du contrat sur la chaîne de blocs

((("chaîne de blocs","création de contrat sur", id="ix_02intro-asciidoc14", range="startofrange")))((("Contrat Faucet.sol (exemple de test)","sur la chaîne de blocs", id ="ix_02intro-asciidoc15", range="startofrange")))Donc, nous avons un contrat. Nous l'avons compilé en code intermédiaire. Maintenant, nous devons "enregistrer" le contrat sur la chaîne de blocs Ethereum. Nous utiliserons le testnet de Ropsten pour tester notre contrat, c'est donc la chaîne de blocs à laquelle nous voulons le soumettre.

((("adresse zéro","enregistrement d'un contrat")))L'enregistrement d'un contrat sur la chaîne de blocs implique la création d'une transaction spéciale dont la destination est l'adresse `+0x00000000000000000000000000000000000000+`,également appelée _zero address_ ou l'_adresse zéro_. L'adresse zéro est une adresse spéciale qui indique à la chaîne de blocs Ethereum que vous souhaitez enregistrer un contrat. Heureusement, l'IDE Remix s'occupera de tout cela pour vous et enverra la transaction à MetaMask.

((("IDE Remix", id="ix_02intro-asciidoc16", range="startofrange")))Tout d'abord, passez à l'onglet Run et sélectionnez Injected Web3 dans la zone de sélection déroulante Environment. Cela connecte l'IDE Remix au portefeuille MetaMask et, via MetaMask, au réseau de test Ropsten. Une fois que vous faites cela, vous pouvez voir Ropsten sous Environment. De plus, dans la zone de sélection du compte, il indique l'adresse de votre portefeuille (voir <<remix_run>>).

[[remix_run]]
.Onglet Run du IDE Remix, avec l'environnement Injected Web3 sélectionné
image::images/remix_run.png["Onglet Run du IDE Remix, avec l'environnement Injected Web3 sélectionné"]

Juste en dessous des paramètres d'exécution que vous venez de confirmer se trouve le contrat `+Faucet+`,prêt à être créé. Cliquez sur le bouton Deploy affiché dans <<remix_run>>.

Remix construira la transaction spéciale "création" et MetaMask vous demandera de l'approuver, comme indiqué dans <<remix_metamask_create>>. Vous remarquerez que la transaction de création de contrat ne contient pas d'ether, mais qu'elle contient 262 octets de données (le contrat compilé) et consommera 10 gwei en gaz. Cliquez sur Soumettre pour l'approuver.

[[remix_metamask_create]]
.MetaMask montrant la transaction de création de contrat
image::images/remix_metamask_create.png["MetaMask montrant la transaction de création de contrat"]

Maintenant, vous devez attendre. Il faudra environ 15 à 30 secondes pour que le contrat soit miné sur Ropsten. Remix ne semblera pas faire grand-chose, mais soyez patient.

Une fois le contrat créé, il apparaît en bas de l'onglet Run (voir <<remix_contract_interact>>).

[[remix_contract_interact]]
.Le contrat Faucet est VIVANT !
image::images/remix_contract_interact.png["Le contrat Faucet est VIVANT !"]

Notez que le contrat +Faucet+ a maintenant sa propre adresse : Remix l'affiche comme "Faucet à 0x72e...c7829" (bien que votre adresse, les lettres et les chiffres aléatoires, soient différents). Le petit symbole de presse-papiers à droite vous permet de copier l'adresse du contrat dans votre presse-papiers. Nous l'utiliserons dans la section suivante.(((range="endofrange", startref="ix_02intro-asciidoc16")))(((range="endofrange", startref="ix_02intro-asciidoc15")))

[[interact_contract]]
=== Interagir avec le contrat

((("Contrat Faucet.sol (exemple de test)","interagir avec", id="ix_02intro-asciidoc17", range="startofrange")))Récapitulons ce que nous avons appris jusqu'à présent : les contrats Ethereum sont des programmes qui contrôler l'argent, qui s'exécutent à l'intérieur d'une machine virtuelle appelée EVM. Ils sont créés par une transaction spéciale qui soumet leur code intermédiaire à enregistrer sur la chaîne de blocs. Une fois créés sur la chaîne de blocs, ils ont une adresse Ethereum, tout comme les portefeuilles. Chaque fois que quelqu'un envoie une transaction à une adresse de contrat, le contrat s'exécute dans l'EVM, avec la transaction en entrée. Transactions envoyées pour les adresses de pass:[<span class="keep-together">contrat</span>] peuvent contenir de l'ether ou des données ou les deux. S'ils contiennent de l'ether, il est "déposé" sur le solde du contrat. S'ils contiennent des données, les données peuvent spécifier une fonction nommée dans le contrat et l'appeler, en transmettant des arguments à la fonction.

[[view_contract_address]]
==== Affichage de l'adresse du contrat dans un explorateur de blocs

((("Contrat Faucet.sol (exemple de test)","affichage de l'adresse du contrat dans un explorateur de blocs")))Nous avons maintenant un contrat enregistré sur la chaîne de blocs, et nous pouvons voir qu'il a une adresse Ethereum. Vérifions-le dans l'explorateur de blocs _ropsten.etherscan.io_ et voyons à quoi ressemble un contrat. Dans l'IDE Remix, copiez l'adresse du contrat en cliquant sur l'icône du presse-papiers à côté de son nom (voir <<remix_contract_address>>).

[[remix_contract_address]]
.Copiez l'adresse du contrat de Remix
image::images/remix_contract_address.png["Copier l'adresse du contrat depuis Remix"]

Gardez Remix ouvert ; nous y reviendrons plus tard. Maintenant, naviguez dans votre navigateur jusqu'à _ropsten.etherscan.io_ et collez l'adresse dans le champ de recherche. Vous devriez voir l'historique des adresses Ethereum du contrat, comme indiqué dans <<etherscan_contract_address>>.(((range="endofrange", startref="ix_02intro-asciidoc17")))

[[etherscan_contract_address]]
.Afficher l'adresse du contrat Faucet dans l'explorateur de blocs Etherscan
image::images/etherscan_contract_address.png["Afficher l'adresse du contrat Faucet dans l'explorateur de blocs etherscan"]

[[fund_contract]]
==== Financement du contrat

((("Faucet.sol contract (exemple de test)","envoyer de l'ether à", id="ix_02intro-asciidoc18", range="startofrange")))Pour l'instant, le contrat n'a qu'une seule transaction dans son historique : l'opération de création de contrat. Comme vous pouvez le voir, le contrat n'a pas non plus d'ether (solde nul). C'est parce que nous n'avons pas envoyé d'ether au contrat dans la transaction de création, même si nous aurions pu le faire.

Notre robinet a besoin de fonds ! Notre premier projet sera d'utiliser MetaMask pour envoyer de l'ether au contrat. Vous devriez toujours avoir l'adresse du contrat dans votre presse-papiers (sinon, copiez-la à nouveau depuis Remix). Ouvrez MetaMask et envoyez-lui 1 ether, exactement comme vous le feriez à n'importe quelle autre adresse Ethereum (voir <<metamask_send_to_contract>>).

[[metamask_send_to_contract]]
.Envoyer 1 ether à l'adresse du contrat
image::images/metamask_send_to_contract.png[""]

Dans une minute, si vous rechargez l'explorateur de blocs Etherscan, il affichera une autre transaction à l'adresse du contrat et un solde mis à jour de 1 ether.

Vous souvenez-vous de la fonction de paiement externe par défaut sans nom dans notre code _Faucet.sol_ ? Ça ressemblait à ça :

[[fallback_function_review]]
[source,solidity]
----
function () external payable {}
----

Lorsque vous avez envoyé une transaction à l'adresse du contrat, sans données spécifiant la fonction à appeler, elle a appelé cette fonction par défaut. Parce que nous l'avons déclaré comme `+payable+`,il a accepté et déposé le 1 ether dans le solde du compte du contrat. Votre transaction a entraîné l'exécution du contrat dans l'EVM, mettant à jour son solde. Vous avez financé votre robinet !(((range="endofrange", startref="ix_02intro-asciidoc18")))

[[withdraw_from_contract]]
==== Faire un retrait sur notre contrat

((("Contrat Faucet.sol (exemple de test)","retrait de fonds de", id="ix_02intro-asciidoc19", range="startofrange")))((("retrait de fonds du contrat", id=" ix_02intro-asciidoc20", range="startofrange")))Ensuite, retirons des fonds du robinet. Pour retirer, nous devons construire une transaction qui appelle la fonction +withdraw+ et lui passe un argument `+withdraw_amount+`.Pour garder les choses simples pour le moment, Remix construira cette transaction pour nous et MetaMask la présentera pour notre approbation.

Revenez à l'onglet Remix et consultez le contrat dans l'onglet Run. Vous devriez voir une boîte orange intitulée +wthdraw+ (retrait) avec une entrée de champ intitulée +uint256 withdraw_amount+ (voir <<remix_contract_withdraw>>).

[[remix_contract_withdraw]]
.La fonction de retrait (withdraw) de Faucet.sol, dans Remix
image::images/remix_contract_interact.png["La fonction de retrait (withdraw) de Faucet.sol, dans Remix"]

Il s'agit de l'interface Remix du contrat. Il nous permet de construire des transactions qui appellent les fonctions définies dans le contrat. Nous entrerons un +withdraw_amount+ et cliquerons sur le bouton de retrait pour générer la transaction.

Tout d'abord, déterminons le +withdraw_amount+ (montant de retrait). Nous voulons essayer de retirer 0,1 ether, qui est le montant maximum autorisé par notre contrat. N'oubliez pas que toutes les valeurs monétaires d'Ethereum sont libellées en wei en interne, et notre fonction +withdraw+ s'attend à ce que le +withdraw_amount+ soit également libellé en wei. La quantité que nous voulons est de 0,1 ether, soit 100 000 000 000 000 000 wei (un 1 suivi de 17 zéros).



[TIP]
====
En raison d'une limitation de JavaScript, un nombre aussi grand que 10^17^ ne peut pas être traité par Remix. Au lieu de cela, nous l'entourons de guillemets doubles, pour permettre à Remix de le recevoir sous forme de chaîne et de le manipuler comme un `+BigNumber+`.Si nous ne le mettons pas entre guillemets, l'IDE Remix ne parviendra pas à le traiter et affichera "Error encoding arguments: Error: Assertion failed."
====

Tapez "100000000000000000" (avec les guillemets) dans la case +withdraw_amount+ et cliquez sur le bouton de retrait (voir <<remix_withdraw>>).

[[remix_withdraw]]
.Cliquez sur "withdraw" dans Remix pour créer une transaction de retrait
image::images/remix_withdraw.png[""]

MetaMask fera apparaître une fenêtre de transaction que vous devrez approuver. Cliquez sur Confirmer pour envoyer votre appel de retrait au contrat (voir <<metamask_withdraw>>).

[[metamask_withdraw]]
.Transaction MetaMask pour appeler la fonction de retrait
image::images/metamask_withdraw.png["Transaction MetaMask pour appeler la fonction de retrait"]

Attendez une minute, puis rechargez l'explorateur de blocs Etherscan pour voir la transaction reflétée dans l'historique des adresses de contrat + Faucet + (voir <<etherscan_withdrawal_tx>>).

[[etherscan_withdrawal_tx]]
.Etherscan montre la transaction appelant la fonction de retrait
image::images/etherscan_withdrawal_tx.png["Etherscan affiche la transaction appelant la fonction de retrait"]


Nous voyons maintenant une nouvelle transaction avec l'adresse du contrat comme destination et une valeur de 0 ether. Le solde du contrat a changé et est maintenant de 0,9 ether car il nous a envoyé 0,1 ether comme demandé. Mais nous ne voyons pas de transaction "OUT" dans l'_historique des adresses de contrat_.

Où est le retrait sortant ? Un nouvel onglet est apparu sur la page d'historique des adresses du contrat, nommé Transactions internes. ((("transaction interne (message)")))Parce que le transfert d'ether 0.1 provient du code de contrat, il s'agit d'une transaction interne (également appelée _message_). Cliquez sur cet onglet pour le voir (voir <<etherscan_withdrawal_internal>>).


Cette "transaction interne" a été envoyée par le contrat dans cette ligne de code (à partir de la fonction pass:[<code><span class="keep-together">withdraw</span></code>] dans _Faucet.sol_) :

[[withdraw_command_review]]
[source,solidity]
----
msg.sender.transfer(withdraw_amount);
----

Pour récapituler : vous avez envoyé une transaction depuis votre portefeuille MetaMask contenant des instructions de données pour appeler la fonction +withdraw+ avec un argument +withdraw_amount+ de 0,1 ether. Cette transaction a entraîné l'exécution du contrat à l'intérieur de l'EVM. Lorsque l'EVM a exécuté la fonction +withdraw+ du contrat `+Faucet+`,il a d'abord appelé la fonction +require+ et validé que le montant demandé était inférieur ou égal au retrait maximal autorisé de 0,1 ether. Ensuite, il a appelé la fonction +transfer+ pour vous envoyer l'ether. L'exécution de la fonction +transfer+ a généré une transaction interne qui a déposé 0,1 ether dans votre adresse de portefeuille, à partir du solde du contrat. C'est celui affiché sur l'onglet Internal Transactions dans Etherscan(((range="endofrange", startref="ix_02intro-asciidoc20")))(((range="endofrange", startref="ix_02intro-asciidoc19"))). (((range="endofrange", startref="ix_02intro-asciidoc14")))

[[etherscan_withdrawal_internal]]
.Etherscan montre la transaction interne transférant l'ether du contrat
image::images/etherscan_withdrawal_internal.png["Etherscan montre la transaction interne transférant l'ether hors du contrat"]

[[intro_conclusion]]
=== Conclusion

Dans ce chapitre, vous avez configuré un portefeuille à l'aide de MetaMask et l'avez financé à l'aide d'un robinet sur le réseau de test Ropsten. Vous avez reçu de l'ether dans l'adresse Ethereum de votre portefeuille, puis vous avez envoyé de l'ether à l'adresse du robinet Ethereum.

Ensuite, vous avez écrit un contrat de robinet dans Solidity. Vous avez utilisé l'IDE Remix pour compiler le contrat en code intermédiaire EVM, puis utilisé Remix pour former une transaction et créé le contrat +Faucet+ sur la chaîne de blocs Ropsten. Une fois créé, le contrat +Faucet+ avait une adresse Ethereum, et vous lui avez envoyé de l'ether. Enfin, vous avez construit une transaction pour appeler la fonction +withdraw+ et demandé avec succès 0,1 ether. Le contrat a vérifié la demande et vous a envoyé 0,1 ether avec une transaction interne.

Cela peut ne pas sembler beaucoup, mais vous venez d'interagir avec succès avec un logiciel qui contrôle l'argent sur un ordinateur mondial décentralisé.

Nous ferons beaucoup plus de programmation de contrats intelligents dans <<smart_contracts_chapter>> et découvrirons les meilleures pratiques et les considérations de sécurité dans <<smart_contract_security>>.(((range="endofrange", startref="ix_02intro-asciidoc0")))