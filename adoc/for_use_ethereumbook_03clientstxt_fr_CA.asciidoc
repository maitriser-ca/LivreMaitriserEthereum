[[ethereum_clients_chapter]]
== Clients Ethereum

((("clients, Ethereum", id="ix_03clients-asciidoc0", range="startofrange")))Un client Ethereum est une application logicielle qui implémente la spécification Ethereum et communique sur le réseau pair à pair avec d'autres clients Ethereum. Différents clients Ethereum _interopèrent_ s'ils respectent la spécification de référence et les protocoles de communication standardisés. Bien que ces différents clients soient implémentés par des équipes différentes et dans des langages de programmation différents, ils « parlent » tous le même protocole et suivent les mêmes règles. En tant que tels, ils peuvent tous être utilisés pour fonctionner et interagir avec le même réseau Ethereum.

Ethereum est un projet à source libre, et le code source de tous les principaux clients est disponible sous des licences à source libre (par exemple, LGPL v3.0), téléchargeable et utilisable à n'importe quelle fin. _Source libre_ signifie cependant plus que simplement libre d'utilisation. Cela signifie également qu'Ethereum est développé par une communauté ouverte de volontaires et peut être modifié par n'importe qui. Plus d'yeux signifie un code plus fiable.

((("Spécification du papier jaune")))Ethereum est défini par une spécification formelle appelée le "Papier jaune" (voir <<references>>).

((("Bitcoin","Définition d'Ethereum par rapport à")))Cela contraste avec, par exemple, Bitcoin, qui n'est pas défini de manière formelle. Là où la "spécification" de Bitcoin est l'implémentation de référence de Bitcoin Core, la spécification d'Ethereum est documentée dans un article qui combine une spécification anglaise et une spécification mathématique (formelle). Cette spécification formelle, en plus de diverses propositions d'amélioration Ethereum, définit le comportement standard d'un pass:[<span class="keep-together">client</span>] Ethereum. Le livre jaune est périodiquement mis à jour au fur et à mesure que des modifications majeures sont apportées à pass:[<span class="keep-together">Ethereum</span>].

En raison de la spécification formelle claire d'Ethereum, il existe un certain nombre d'implémentations logicielles développées indépendamment, mais interopérables, d'un client Ethereum. Ethereum a une plus grande diversité d'implémentations fonctionnant sur le réseau que toute autre chaîne de blocs, ce qui est généralement considéré comme une bonne chose. En effet, il s'est avéré, par exemple, être un excellent moyen de se défendre contre les attaques sur le réseau, car l'exploitation de la stratégie de mise en œuvre d'un client particulier ne fait qu'embêter les développeurs pendant qu'ils corrigent l'exploit, tandis que d'autres clients maintiennent le réseau en marche presque sans être affecté.

=== Réseaux Ethereum

((("clients, Ethereum","réseaux basés sur Ethereum et", id="ix_03clients-asciidoc1", range="startofrange")))((("réseaux (Ethereum)","clients et", id= "ix_03clients-asciidoc2", range="startofrange")))Il existe une variété de réseaux basés sur Ethereum qui sont largement conformes à la spécification formelle définie dans le livre jaune Ethereum, mais qui peuvent ou non interagir les uns avec les autres.

Parmi ces réseaux basés sur Ethereum figurent Ethereum, Ethereum Classic, Ella, Expanse, Ubiq, Musicoin et bien d'autres. Bien qu'ils soient généralement compatibles au niveau du protocole, ces réseaux ont souvent des fonctionnalités ou des attributs qui obligent les mainteneurs du logiciel client Ethereum à apporter de petites modifications afin de prendre en charge chaque réseau. Pour cette raison, toutes les versions du logiciel client Ethereum n'exécutent pas toutes les chaînes de blocs basées sur Ethereum.

Actuellement, il existe six implémentations principales du protocole Ethereum, écrites dans six langages différents :

* Parity, écrite en Rust
* Geth, écrit en Go
* +cpp-ethereum+, écrit en Cpass:[++]
* +pyethereum+, écrit en Python
* Mantis, écrit en Scala
* Harmony, écrit en Java

Dans cette section, nous examinerons les deux clients les plus courants, Parity et Geth. Nous montrerons comment configurer un nœud à l'aide de chaque client et explorerons certaines de leurs options de ligne de commande et interfaces de programmation d'application (API).

[[full_node_importance]]
==== Dois-je exécuter un nœud complet ?

((("noeud complet","réseaux basés sur Ethereum et", id="ix_03clients-asciidoc3", range="startofrange")))((("réseaux (Ethereum)","noeuds complets et", id="ix_03clients-asciidoc4", range="startofrange")))La santé, la résilience et la résistance à la censure des chaînes de blocs dépendent de leur nombre de nœuds complets exploités indépendamment et dispersés géographiquement. Chaque nœud complet peut aider d'autres nouveaux nœuds à obtenir les données de bloc pour amorcer leur fonctionnement, tout en offrant à l'opérateur une vérification faisant autorité et indépendante de toutes les transactions et contrats.

Cependant, l'exécution d'un nœud complet entraînera un coût en ressources matérielles et en bande passante. Un nœud complet doit télécharger 80 à 300 Go de données (à compter de janvier 2020, selon la configuration du client) et les stocker sur un disque dur local. Cette charge de données augmente assez rapidement chaque jour à mesure que de nouvelles transactions et de nouveaux blocs sont ajoutés. Nous abordons ce sujet plus en détail dans <<requirements>>.

Un nœud complet fonctionnant sur un réseau _mainnet_ en direct n'est pas nécessaire pour le développement d'Ethereum. Vous pouvez faire presque tout ce que vous devez faire avec un nœud _testnet_ (qui vous connecte à l'une des plus petites chaînes de blocs de test publiques), avec une chaîne de blocs privée locale comme Ganache, ou avec un client Ethereum basé sur le cloud proposé par un fournisseur de services comme Infura.

Vous avez également la possibilité d'exécuter un client distant, qui ne stocke pas de copie locale de la chaîne de blocs ni ne valide les blocs et les transactions. Ces clients offrent la fonctionnalité d'un portefeuille et peuvent créer et diffuser des transactions. Les clients distants peuvent être utilisés pour se connecter à des réseaux existants, tels que votre propre nœud complet, une chaîne de blocs publique, un testnet public ou autorisé (preuve d'autorité), ou une chaîne de blocs locale privée. En pratique, vous utiliserez probablement un client distant tel que MetaMask, Emerald Wallet, pass:[<span class="keep-together">MyEtherWallet</span>] ou MyCrypto comme moyen pratique de basculer entre toutes les différentes options de nœud.

((("clients distants","portefeuille comparé à")))((("portefeuilles","clients distants comparé à")))Les termes "client distant" et "portefeuille" sont utilisés de manière interchangeable, bien qu'il existe certains différences. Habituellement, un client distant propose une API (telle que l'API web3.js) en plus de la fonctionnalité de transaction d'un portefeuille.

((("client léger/léger")))Ne confondez pas le concept de portefeuille distant dans Ethereum avec celui d'un _client léger_ (qui est analogue à un client de vérification simplifiée des paiements dans Bitcoin). Les clients légers valident les en-têtes de bloc et utilisent les preuves Merkle pour valider l'inclusion des transactions dans la chaîne de blocs et déterminer leurs effets, leur donnant un niveau de sécurité similaire à un nœud complet. Inversement, les clients distants Ethereum ne valident pas les en-têtes de bloc ou les transactions. Ils font entièrement confiance à un client complet pour leur donner accès à la chaîne de blocs, et perdent ainsi d'importantes garanties de sécurité et d'anonymat. Vous pouvez atténuer ces problèmes en utilisant un client complet que vous exécutez vous-même.

[[full_node_adv_disadv]]
==== Avantages et désavantages du nœud complet

((("nœud complet","avantages/inconvénients"))) Choisir d'exécuter un nœud complet facilite le fonctionnement des réseaux auxquels vous le connectez, mais entraîne également des coûts légers à modérés pour vous. Regardons quelques-uns des avantages et des inconvénients.

*Avantages:*

* Prend en charge la résilience et la résistance à la censure des réseaux basés sur Ethereum
* Valide avec autorité toutes les transactions
* Peut interagir avec n'importe quel contrat sur la chaîne de blocs publique sans intermédiaire
* Peut déployer directement des contrats dans la chaîne de blocs publique sans intermédiaire
* Peut interroger (lecture seule) le statut de la chaîne de blocs (comptes, contrats, etc.) hors ligne
* Peut interroger la chaîne de blocs sans laisser un tiers connaître les informations que vous lisez

*Désavantages:*

* Nécessite des ressources matérielles et de bande passante importantes et croissantes
* Peut nécessiter plusieurs jours pour une synchronisation complète lors du premier démarrage
* Doit être maintenu, mis à jour et maintenu en ligne pour rester synchronisé(((range="endofrange", startref="ix_03clients-asciidoc4")))(((range="endofrange", startref="ix_03clients-asciidoc3")))

[[pub_test_adv_disadv]]
==== Avantages et désavantages du testnet public

((("réseaux (Ethereum)","avantages/inconvénients du réseau de test public")))((("réseaux de test publics")))((("réseau de test","public")))Que vous choisissiez ou non d'exécuter un nœud complet, vous souhaiterez probablement exécuter un nœud testnet public. Examinons quelques-uns des avantages et des inconvénients de l'utilisation d'un testnet public.

*Avantages:*

* Un nœud testnet doit synchroniser et stocker beaucoup moins de données - environ 45 Go selon le réseau.
* Un nœud testnet peut se synchroniser complètement en quelques heures.
* Le déploiement de contrats ou la réalisation de transactions nécessite un test d'ether, qui n'a aucune valeur et peut être acquis gratuitement à partir de plusieurs "robinets".
* Les réseaux de test sont des chaînes de blocs publiques avec de nombreux autres utilisateurs et contrats, fonctionnant "en direct".

*Désavantages:*

* Vous ne pouvez pas utiliser d'argent "réel" sur un testnet ; il fonctionne sur l'ether de test. Par conséquent, vous ne pouvez pas tester la sécurité contre de vrais adversaires, car il n'y a rien en jeu.
* Il y a certains aspects d'une chaîne de blocs publique que vous ne pouvez pas tester de manière réaliste sur un testnet. Par exemple, les frais de transaction, bien que nécessaires pour envoyer des transactions, ne sont pas pris en compte sur un testnet, car le gaz est gratuit. De plus, les réseaux de test ne connaissent pas de congestion du réseau comme le fait parfois le réseau principal public.

[[localtest_adv_dis]]
==== Avantages et désavantages de la simulation chaîne de blocs locale

((("Ganache","avantages/inconvénients")))((("simulation chaîne de blocs locale")))((("réseaux (Ethereum)","simulation chaîne de blocs locale avantages/inconvénients")))((( "chaîne de blocs privée")))((("chaîne de blocs privée à instance unique")))À de nombreuses fins de test, la meilleure option consiste à lancer une chaîne de blocs privée à instance unique. Ganache (anciennement nommé +testrpc+) est l'une des simulations de chaîne de blocs locales les plus populaires avec lesquelles vous pouvez interagir, sans aucun autre participant. Il partage de nombreux avantages et inconvénients du testnet public, mais présente également quelques différences.

*Avantages:*

* Aucune synchronisation et presque aucune donnée sur le disque ; vous minez vous-même le premier bloc
* Pas besoin d'obtenir de l'ether de test ; vous vous "attribuez" des récompenses minières que vous pouvez utiliser pour tester
* Aucun autre utilisateur, juste vous
* Aucun autre contrat, juste ceux que vous déployez après le lancement

*Désavantages:*

* Ne pas avoir d'autres utilisateurs signifie qu'il ne se comporte pas de la même manière qu'une chaîne de blocs publique. Il n'y a pas de concurrence pour l'espace de transaction ou le séquençage des pass:[<span class="keep-together">transactions</span>].
* Aucun mineur autre que vous signifie que l'exploitation minière est plus prévisible ; par conséquent, vous ne pouvez pas tester certains scénarios qui se produisent sur une chaîne de blocs publique.
* L'absence d'autres contrats signifie que vous devez déployer tout ce que vous souhaitez tester, y compris les dépendances et les bibliothèques de contrats.
* Vous ne pouvez pas recréer certains contrats publics et leurs adresses pour tester certains scénarios (par exemple, le contrat DAO).(((range="endofrange", startref="ix_03clients-asciidoc2")))(((range= "fin de gamme", startref="ix_03clients-asciidoc1")))


[[running_client]]
=== Exécuter un client Ethereum

((("clients, Ethereum","exécuter un", id="ix_03clients-asciidoc5", range="startofrange")))Si vous avez le temps et les ressources, vous devriez essayer d'exécuter un nœud complet, même si ce n'est que pour en savoir plus sur le processus. Dans cette section, nous expliquons comment télécharger, compiler et exécuter les clients Ethereum Parity et Geth. Cela nécessite une certaine familiarité avec l'utilisation de l'interface de ligne de commande sur votre système d'exploitation. Cela vaut la peine d'installer ces clients, que vous choisissiez de les exécuter en tant que nœuds complets, en tant que nœuds testnet ou en tant que clients d'une chaîne de blocs privée locale.

[[requirements]]
==== Configuration matérielle requise pour un nœud complet

((("clients, Ethereum","configuration matérielle requise pour le nœud complet")))((("nœud complet","configuration matérielle requise")))Avant de commencer, vous devez vous assurer que vous disposez d'un ordinateur doté de ressources suffisantes pour fonctionner un nœud complet Ethereum. Vous aurez besoin d'au moins 300 Go d'espace disque pour stocker une copie complète de la chaîne de blocs Ethereum. Si vous souhaitez également exécuter un nœud complet sur le testnet Ethereum, vous aurez besoin d'au moins 45 Go supplémentaires. Le téléchargement de 345 Go de données de la chaîne de blocs peut prendre beaucoup de temps, il est donc recommandé de travailler sur une connexion Internet rapide.

La synchronisation de la chaîne de blocs Ethereum est très intensive en entrée/sortie (E/S). Il est préférable d'avoir un disque statique électronique (SSD). Si vous avez un disque dur mécanique (HDD), vous aurez besoin d'au moins 8 Go de RAM à utiliser comme cache. Sinon, vous découvrirez peut-être que votre système est trop lent pour suivre et synchroniser complètement.

*Exigences minimales:*

* Processeur avec 2+ cœurs
* Au moins 300 Go d'espace de stockage libre
* 4 Go de RAM minimum avec un SSD, 8 Go+ si vous avez un HDD
* Service Internet de téléchargement de 8 Mbit/s

Ce sont les exigences minimales pour synchroniser une copie complète (mais élaguée) d'une chaîne de blocs basée sur Ethereum.

Au moment de la rédaction, la base de code Parity est plus légère sur les ressources, donc si vous utilisez un matériel limité, vous obtiendrez probablement de meilleurs résultats en utilisant Parity.

Si vous souhaitez synchroniser dans un délai raisonnable et stocker tous les outils de développement, bibliothèques, clients et chaînes de blocs dont nous parlons dans ce livre, vous voudrez un ordinateur plus performant.

*Spécifications recommandées :*

* Processeur rapide avec 4+ cœurs
* 16 Go + RAM
* SSD rapide avec au moins 500 Go d'espace libre
* Service Internet de téléchargement de plus de 25 Mbit/s

Il est difficile de prédire à quelle vitesse la taille d'une chaîne de blocs augmentera et quand plus d'espace disque sera nécessaire, il est donc recommandé de vérifier la dernière taille de la chaîne de blocs avant de commencer la synchronisation.

[NOTE]
====
Les exigences de taille de disque répertoriées ici supposent que vous exécuterez un nœud avec les paramètres par défaut, où la chaîne de blocs est "élaguée" des anciennes données d'état. Si vous exécutez à la place un nœud "d'archivage" complet, où tout l'état est conservé sur le disque, il nécessitera probablement plus de 1 To d'espace disque.
====

Ces liens fournissent des estimations à jour de la taille de la chaîne de blocs :

* https://bitinfocharts.com/ethereum/[Ethereum]

* https://bitinfocharts.com/ethereum%20classic/[Ethereum classique]

[[sw_reqs]]
==== Configuration logicielle requise pour créer et exécuter un client (nœud)

((("clients, Ethereum","logiciels requis pour la construction/l'exécution", id="ix_03clients-asciidoc6", range="startofrange")))Cette section couvre les logiciels clients Parity et Geth. Il suppose également que vous utilisez un environnement de ligne de commande de type Unix. Les exemples montrent les commandes et la sortie telles qu'elles apparaissent sur un système d'exploitation Ubuntu GNU/Linux exécutant le shell bash (environnement d'exécution en ligne de commande).

En règle générale, chaque chaîne de blocs aura sa propre version de Geth, tandis que Parity prend en charge plusieurs chaînes de blocs basées sur Ethereum (Ethereum, Ethereum Classic, pass:[<span class="keep-together">Ellaism</span>], Expanse, Musicoin) avec le même client téléchargé.

[TIP]
=====
((("symbole $")))((("interface de ligne de commande")))((("commandes shell")))((("applications de terminal")))Dans de nombreux exemples de ce chapitre , nous utiliserons l'interface de ligne de commande du système d'exploitation (également appelée "shell"), accessible via une application "terminal". Le shell affichera une invite ; vous tapez une commande et le shell répond avec du texte et une nouvelle invite pour votre prochaine commande. L'invite peut sembler différente sur votre système, mais dans les exemples suivants, elle est indiquée par un symbole +$+. Dans les exemples, lorsque vous voyez du texte après un symbole +$+, ne tapez pas le symbole +$+ mais tapez la commande qui le suit immédiatement (en gras), puis appuyez sur Entrée pour exécuter la commande. Dans les exemples, les lignes sous chaque commande sont les réponses du système d'exploitation à cette commande. Lorsque vous verrez le prochain préfixe +$+, vous saurez qu'il s'agit d'une nouvelle commande et vous devrez répéter le processus.
=====

Avant de commencer, vous devrez peut-être installer certains logiciels. Si vous n'avez jamais fait de développement logiciel sur l'ordinateur que vous utilisez actuellement, vous devrez probablement installer quelques outils de base. Pour les exemples qui suivent, vous devrez installer +git+, le système de gestion du code source ; +golang+, le langage de programmation Go et les bibliothèques standard ; et Rust, un langage de programmation système.

((("git")))Git peut être installé en suivant les instructions sur https://git-scm.com[].

((("Go", seealso="Geth (Go-Ethereum)")))Go peut être installé en suivant les instructions sur https://golang.org[], ou https://github.com/golang/ go/wiki/Ubuntu[] si vous utilisez Ubuntu.

[NOTE]
=====
((("Geth (Go-Ethereum)")))Les exigences de Geth varient, mais si vous vous en tenez à Go version 1.10 ou supérieure, vous devriez pouvoir compiler n'importe quelle version de Geth que vous souhaitez. Bien sûr, vous devriez toujours vous référer à la documentation de la version de Geth que vous avez choisie.

La version de +golang+ installée sur votre système d'exploitation ou disponible à partir du gestionnaire de packages de votre système peut être bien antérieure à la 1.10. Si tel est le cas, supprimez-le et installez la dernière version à partir de https://golang.org/[].
=====

((("Rust")))Rust peut être installé en suivant les instructions sur https://www.rustup.rs/[].

[NOTE]
=====
Parity nécessite Rust version 1.27 ou supérieure.
=====

((("Parity","bibliothèques pour")))Parity nécessite également certaines bibliothèques logicielles, telles que OpenSSL et +libudev+. Pour les installer sur un système compatible Ubuntu ou Debian GNU/Linux, utilisez la  pass:[<span class="keep-together">commande</span>] suivante :

++++
<pre data-type="programlisting">
$ <strong>sudo apt-get install openssl libssl-dev libudev-dev cmake clang</strong>

</pre>
++++

Pour les autres systèmes d'exploitation, utilisez le gestionnaire d'applications de votre système d'exploitation ou suivez les https://github.com/paritytech/parity/wiki/Setup [instructions Wiki] pour installer les bibliothèques requises.

Maintenant que vous avez installé +git+, +golang+, Rust et les bibliothèques nécessaires, mettons-nous au travail !

[[parity]]
==== Parity

((("clients, Ethereum","Parity et")))((("Parity","bases")))Parity est une implémentation d'un client Ethereum à nœud complet et d'un navigateur DApp. Il a été écrit « à partir de zéro » en Rust, un langage de programmation système, dans le but de créer un client Ethereum modulaire, sécurisé et évolutif. Parity est développé par Parity Tech, une société britannique, et est publié sous la licence de logiciel libre GPLv3.

[NOTE]
=====
Divulgation: L'un des auteurs de ce livre, le Dr Gavin Wood, est le fondateur de Parity Tech et a écrit une grande partie du client Parity. Parity représente environ 25% de la base des clients Ethereum installés.
=====

Pour installer Parity, vous pouvez utiliser le gestionnaire d'applications Rust +cargo+ ou télécharger le code source depuis GitHub. Le gestionnaire d'applications télécharge également le code source, il n'y a donc pas beaucoup de différence entre les deux options. Dans la section suivante, nous vous montrerons comment télécharger et compiler Parity vous-même.

[[install_parity]]
===== Installation de Parity

((("Parity","installation")))Le https://wiki.parity.io/Setup[Parity Wiki] propose des instructions pour créer Parity dans différents environnements et conteneurs. Nous allons vous montrer comment créer Parity à partir de la source. Cela suppose que vous avez déjà installé Rust en utilisant +rustup+ (voir <<sw_reqs>>).

Tout d'abord, récupérez le code source sur GitHub :

++++
<pre data-type="programlisting">
$ <strong>git clone https://github.com/paritytech/parity</strong>

</pre>
++++

Passez ensuite au répertoire _parity_ et utilisez +cargo+ pour créer l'exécutable :

++++
<pre data-type="programlisting">
$ <strong>cd parity</strong>
$ <strong>cargo install --path .</strong>

</pre>
++++

Si tout se passe bien, vous devriez voir quelque chose comme :

++++
<pre data-type="programlisting">
$ <strong>cargo install --path .</strong>
Installing parity-ethereum v2.7.0 (/root/parity)
Updating crates.io index
Updating git repository `https://github.com/paritytech/rust-ctrlc.git`
Updating git repository `https://github.com/paritytech/app-dirs-rs`   Updating git repository 

[...]

Compiling parity-ethereum v2.7.0 (/root/parity)
Finished release [optimized] target(s) in 10m 16s
Installing /root/.cargo/bin/parity
Installed package `parity-ethereum v2.7.0 (/root/parity)` (executable `parity`)
$

</pre>
++++

Essayez d'exécuter +parity+ pour voir s'il est installé, en invoquant l'option +--version+ :


++++
<pre data-type="programlisting">
$ <strong>parity --version</strong>
Parity Ethereum Client.
  version Parity-Ethereum/v2.7.0-unstable-b69a33b3a-20200124/x86_64-unknown-linux-gnu/rustc1.40.0
Copyright 2015-2020 Parity Technologies (UK) Ltd.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

By Wood/Paronyan/Kotewicz/Drwięga/Volf/Greeff
   Habermeier/Czaban/Gotchac/Redman/Nikolsky
   Schoedon/Tang/Adolfsson/Silva/Palm/Hirsz et al.
$

</pre>
++++

Génial! Maintenant que Parity est installé, vous pouvez synchroniser la chaîne de blocs et commencer avec quelques options de ligne de commande de base.

[[go_ethereum_geth]]
==== Go-Ethereum (Geth)

((("clients, Ethereum","Geth et", id="ix_03clients-asciidoc7", range="startofrange")))((("Geth (Go-Ethereum)","bases", id="ix_03clients-asciidoc8", range="startofrange")))Geth est l'implémentation avec le langage Go activement développée par la Fondation Ethereum, elle est donc considérée comme l'implémentation "officielle" du client Ethereum. En règle générale, chaque chaîne de blocs basée sur Ethereum aura sa propre implémentation Geth. Si vous utilisez Geth, assurez-vous de récupérer la bonne version pour votre chaîne de blocs en utilisant l'un des liens de référentiel suivants :


* https://github.com/ethereum/go-ethereum[Ethereum] (or https://geth.ethereum.org/)

* https://github.com/etclabscore/go-ethereum[Ethereum Classic]

* https://github.com/ellaism/go-ellaism[Ellaism]

* https://github.com/expanse-org/go-expanse[Expanse] 

* https://github.com/Musicoin/go-musicoin[Musicoin] 

* https://github.com/ubiq/go-ubiq[Ubiq] 

[NOTE]
=====
Vous pouvez également ignorer ces instructions et installer un binaire précompilé pour la plate-forme de votre choix. Les versions précompilées sont beaucoup plus faciles à installer et peuvent être trouvées dans la section "versions" de l'un des référentiels répertoriés ici. Cependant, vous pouvez en apprendre davantage en téléchargeant et en compilant le logiciel vous-même.
=====

[[cloning_repo]]
===== Cloner le référentiel

((("Geth (Go-Ethereum)","clonage du référentiel Git pour")))La première étape consiste à cloner le référentiel Git, pour obtenir une copie du code source.

Pour créer un clone local de votre référentiel choisi, utilisez la commande +git+ comme suit, dans votre répertoire personnel ou sous n'importe quel répertoire que vous utilisez pour le développement :

++++
<pre data-type="programlisting">
$ <strong>git clone &lt;Lien vers le référentiel&gt;</strong>

</pre>
++++

Vous devriez voir un rapport de progression au fur et à mesure que le référentiel est copié sur votre système local :

[[cloning_status]]
----
Cloning into 'go-ethereum'...
remote: Enumerating objects: 86915, done.
remote: Total 86915 (delta 0), reused 0 (delta 0), pack-reused 86915
Receiving objects: 100% (86915/86915), 134.73 MiB | 29.30 MiB/s, done.
Resolving deltas: 100% (57590/57590), done.
----

Génial! Maintenant que vous avez une copie locale de Geth, vous pouvez compiler un exécutable pour votre plate-forme.

[[build_geth_src]]
===== Construire Geth à partir du code source

((("Geth (Go-Ethereum)","construire à partir du code source")))Pour compiler Geth, allez dans le répertoire où le code source a été téléchargé et utilisez la commande +make+ :

++++
<pre data-type="programlisting">
$ <strong>cd go-ethereum</strong>
$ <strong>make geth</strong>

</pre>
++++

Si tout se passe bien, vous verrez le compilateur Go construire chaque composant jusqu'à ce qu'il produise l'exécutable +geth+ :

[[making_geth_status]]
----
build/env.sh go run build/ci.go install ./cmd/geth
>>> /usr/local/go/bin/go install -ldflags -X main.gitCommit=58a1e13e6dd7f52a1d...
github.com/ethereum/go-ethereum/common/hexutil
github.com/ethereum/go-ethereum/common/math
github.com/ethereum/go-ethereum/crypto/sha3
github.com/ethereum/go-ethereum/rlp
github.com/ethereum/go-ethereum/crypto/secp256k1
github.com/ethereum/go-ethereum/common
[...]
github.com/ethereum/go-ethereum/cmd/utils
github.com/ethereum/go-ethereum/cmd/geth
Done building.
Exécutez "build/bin/geth" pour exécuter geth.
$
----

Assurons-nous que +geth+ fonctionne sans l'excuter :

++++
<pre data-type="programlisting">
$ <strong>./build/bin/geth version</strong>

Geth
Version: 1.9.11-unstable
Git Commit: 0b284f6c6cfc6df452ca23f9454ee16a6330cb8e
Git Commit Date: 20200123
Architecture: amd64
Protocol Versions: [64 63]
Go Version: go1.13.4
Operating System: linux
[...]

</pre>
++++

Votre commande +geth version+ peut afficher des informations légèrement différentes, mais vous devriez voir un rapport de version similaire à celui présenté ici.

Les sections suivantes expliquent le défi avec la synchronisation initiale de la chaîne de blocs d'Ethereum(((range="endofrange", startref="ix_03clients-asciidoc6"))).(((range="endofrange", startref="ix_03clients-asciidoc5")))


[[first_sync]]
=== La première synchronisation des chaînes de blocs basées sur Ethereum

((("chaîne de blocs","première synchronisation de", id="ix_03clients-asciidoc9", range="startofrange")))((("clients, Ethereum","première synchronisation des chaînes de blocs basées sur Ethereum", id= "ix_03clients-asciidoc10", range="startofrange")))((("première synchronisation","des chaînes de blocs basées sur Ethereum", id="ix_03clients-asciidoc11", range="startofrange")))Traditionnellement, lors de la synchronisation d'une chaîne de blocs Ethereum, votre client téléchargerait et validerait chaque bloc et chaque transaction depuis le tout début, c'est-à-dire depuis le bloc de genèse.

Bien qu'il soit possible de synchroniser entièrement la chaîne de blocs de cette façon, ce type de synchronisation prendra très longtemps et nécessite beaucoup de ressources (il nécessitera beaucoup plus de RAM, et prendra en effet très longtemps si vous n'avez pas stockage).

De nombreuses chaînes de blocs basées sur Ethereum ont été victimes d'attaques par déni de service fin 2016. Les chaînes de blocs concernées auront tendance à se synchroniser lentement lors d'une synchronisation complète.

Par exemple, sur Ethereum, un nouveau client progressera rapidement jusqu'à atteindre le bloc 2 283 397. Ce bloc a été miné le 18 septembre 2016 et marque le début des attaques DoS. De ce bloc au bloc 2 700 031 (26 novembre 2016), la validation des transactions devient extrêmement lente, gourmande en mémoire et gourmande en E/S. Cela se traduit par des temps de validation supérieurs à 1 minute par bloc. Ethereum a mis en œuvre une série de mises à niveau, à l'aide d'embranchements divergents, pour remédier aux vulnérabilités sous-jacentes qui ont été exploitées dans les attaques DoS. Ces mises à niveau ont également nettoyé la chaîne de blocs en supprimant quelque 20 millions de comptes vides créés par des transactions de spam.

Si vous synchronisez avec une validation complète, votre client ralentira et peut prendre plusieurs jours, voire plus, pour valider les blocs affectés par les attaques DoS.

((("synchronisation rapide")))Heureusement, la plupart des clients Ethereum effectuent désormais par défaut une synchronisation "rapide" qui ignore la validation complète des transactions jusqu'à ce qu'elle soit synchronisée avec la pointe de la chaîne de blocs, puis reprend la validation complète.

Geth effectue une synchronisation rapide par défaut pour Ethereum. Vous devrez peut-être vous référer aux instructions spécifiques pour l'autre chaîne Ethereum choisie.

Parity effectue également une synchronisation rapide par défaut.

[NOTE]
=====
Geth ne peut opérer une synchronisation rapide que lorsqu'il démarre avec une base de données de blocs vide. Si vous avez déjà commencé la synchronisation sans mode rapide, Geth ne peut pas basculer de mode. Il est plus rapide de supprimer le répertoire de données de la chaîne de blocs et de commencer la synchronisation rapide depuis le début que de continuer la synchronisation avec une validation complète. Veillez à ne supprimer aucun portefeuille lors de la suppression des données de la chaîne de blocs !
=====

==== Exécuter Geth ou Parity

((("première synchronisation","Geth ou Parity pour")))((("Geth (Go-Ethereum)","pour la première synchronisation")))((("Parity","pour la première synchronisation")))Maintenant que vous comprenez les défis de la "première synchronisation", vous êtes prêt à démarrer un client Ethereum et à synchroniser la chaîne de blocs. Pour Geth et Parity, vous pouvez utiliser l'option +--help+ pour voir tous les paramètres de configuration. Les paramètres par défaut sont généralement judicieux et appropriés pour la plupart des utilisations. Choisissez comment configurer les paramètres facultatifs en fonction de vos besoins, puis démarrez Geth ou Parity pour synchroniser la chaîne. Puis attendre...

[TIP]
====
La synchronisation de la chaîne de blocs Ethereum prendra entre une demi-journée sur un système très rapide avec beaucoup de RAM et plusieurs jours sur un système plus lent.
====

[[json_rpc]]
==== L'interface JSON-RPC

((("clients, Ethereum","et API JSON-RPC", id="ix_03clients-asciidoc12", range="startofrange")))((("première synchronisation","et API JSON-RPC", id ="ix_03clients-asciidoc13", range="startofrange")))((("JSON-RPC API", id="ix_03clients-asciidoc14", range="startofrange")))Les clients Ethereum offrent une interface de programmation d'application et un ensemble de commandes Remote Procedure Call (RPC), qui sont encodées en JavaScript Object Notation (JSON). Vous verrez cela appelé _API JSON-RPC_. Essentiellement, l'API JSON-RPC est une interface qui nous permet d'écrire des programmes qui utilisent un client Ethereum comme _passerelle_ vers un réseau Ethereum et une chaîne de blocs.

Habituellement, l'interface RPC est proposée en tant que service HTTP sur le port 8545. Pour des raisons de sécurité, il est restreint, par défaut, de n'accepter que les connexions de localhost (l'adresse IP de votre propre ordinateur, qui est 127.0.0.1).

Pour accéder à l'API JSON-RPC, vous pouvez utiliser une bibliothèque spécialisée (écrite dans le langage de programmation de votre choix) qui fournit des appels de fonction "stub" correspondant à chaque commande RPC disponible, ou vous pouvez construire manuellement des requêtes HTTP et envoyer/recevoir des requêtes codées en JSON. Vous pouvez même utiliser un client HTTP de ligne de commande générique, comme +curl+, pour appeler l'interface RPC. Essayons ça. Tout d'abord, assurez-vous que Geth est opérationnel, configuré avec --rpc pour autoriser l'accès HTTP à l'interface RPC, puis passez à une nouvelle fenêtre de terminal (par exemple, avec Ctrl-Maj-N ou Ctrl-Maj-T dans un fenêtre de terminal) comme indiqué ici :

++++
<pre data-type="programlisting">
$ <strong>curl -X POST -H "Content-Type: application/json" --data \
  '{"jsonrpc":"2.0","method":"web3_clientVersion","params":[],"id":1}' \
  http://localhost:8545</strong>

{"jsonrpc":"2.0","id":1,
"result":"Geth/v1.9.11-unstable-0b284f6c-20200123/linux-amd64/go1.13.4"}

</pre>
++++

Dans cet exemple, nous utilisons +curl+ pour établir une connexion HTTP à l'adresse _http://localhost:8545_. Nous exécutons déjà +geth+, qui propose l'API JSON-RPC en tant que service HTTP sur le port 8545. Nous demandons à +curl+ d'utiliser la commande HTTP +POST+ et d'identifier le contenu en tant que type +application/json+. Enfin, nous transmettons une requête encodée en JSON en tant que composant +data+ de notre requête HTTP. La majeure partie de notre ligne de commande consiste simplement à configurer +curl+ pour établir correctement la connexion HTTP. La partie intéressante est la commande JSON-RPC que nous émettons :

[[JSON_RPC_command]]
----
{"jsonrpc":"2.0","method":"web3_clientVersion","params":[],"id":1}
----

La requête JSON-RPC est formatée conformément à la https://www.jsonrpc.org/specification [spécification JSON-RPC 2.0]. Chaque demande contient quatre éléments :

++jsonrpc++ :: Version du protocole JSON-RPC. Cela DOIT être exactement ++"2.0"++.

++method++ :: Le nom de la méthode à invoquer.

++params++ :: Une valeur structurée qui contient les valeurs de paramètre à utiliser lors de l'invocation de la méthode. Ce membre PEUT être omis.

++id++ :: Un identifiant établi par le client qui DOIT contenir une valeur +String+, +Number+ ou +NULL+ si elle est incluse. Le serveur DOIT répondre avec la même valeur dans l'objet de réponse s'il est inclus. Ce membre est utilisé pour corréler le contexte entre les deux objets.

[TIP]
====
((("batching")))Le paramètre +id+ est principalement utilisé lorsque vous effectuez plusieurs requêtes dans un seul appel JSON-RPC, une pratique appelée _batching_. Le traitement par lots est utilisé pour éviter la surcharge d'une nouvelle connexion HTTP et TCP pour chaque requête. Dans le contexte Ethereum, par exemple, nous utiliserions le traitement par lots si nous voulions récupérer des milliers de transactions sur une seule connexion HTTP. Lors du traitement par lots, vous définissez un +id+ différent pour chaque demande, puis le faites correspondre au +id+ dans chaque réponse du serveur JSON-RPC. Le moyen le plus simple d'implémenter ceci est de maintenir un compteur et d'incrémenter la valeur pour chaque demande.
====


La réponse que nous recevons est :

----
{"jsonrpc":"2.0","id":1,
"result":"Geth/v1.9.11-unstable-0b284f6c-20200123/linux-amd64/go1.13.4"}
----

Cela nous indique que l'API JSON-RPC est servie par la version 1.13.4 du client Geth.

Essayons quelque chose d'un peu plus intéressant. Dans l'exemple suivant, nous demandons à l'API JSON-RPC le prix actuel du gaz en wei :

++++
<pre data-type="programlisting">
$ <strong>curl -X POST -H "Content-Type: application/json" --data \
  '{"jsonrpc":"2.0","method":"eth_gasPrice","params":[],"id":4213}' \
  http://localhost:8545</strong>

{"jsonrpc":"2.0","id":4213,"result":"0x430e23400"}

</pre>
++++

La réponse, +0x430e23400+, nous indique que le prix actuel du gaz est de 18 gwei (gigawei ou milliard de wei). Si, comme nous, vous ne pensez pas en hexadécimal, vous pouvez le convertir en décimal sur la ligne de commande avec un petit bash-fu :

++++
<pre data-type="programlisting">
$ <strong>echo $((0x430e23400))</strong>

18000000000

</pre>
++++

L'API JSON-RPC complète peut être étudiée sur le https://github.com/ethereum/wiki/wiki/JSON-RPC[wiki Ethereum].

[[parity_compatibility_mode]]
===== Mode de compatibilité Geth de Parity

Parity a un "mode de compatibilité Geth" spécial, où il offre une API JSON-RPC identique à celle offerte par Geth. Pour exécuter Parity dans ce mode, utilisez le commutateur +--geth+(((range="endofrange", startref="ix_03clients-asciidoc14")))(((range="endofrange", startref="ix_03clients-asciidoc13")))(((range="endofrange", startref="ix_03clients-asciidoc12"))):(((range="endofrange", startref="ix_03clients-asciidoc11")))(((range="endofrange", startref="ix_03clients-asciidoc10")))(((range="endofrange", startref="ix_03clients-asciidoc9")))

++++
<pre data-type="programlisting">
$ <strong>parity --geth</strong>

</pre>
++++

[[lw_eth_clients]]
=== Clients Ethereum distants

((("clients, Ethereum","distant", id="ix_03clients-asciidoc15", range="startofrange")))((("clients distants", id="ix_03clients-asciidoc16", range="startofrange")))Les clients distants offrent un sous-ensemble des fonctionnalités d'un client complet. Ils ne stockent pas la chaîne de blocs Ethereum complète, ils sont donc plus rapides à configurer et nécessitent beaucoup moins de stockage de données.

[role="pagebreak-before"]
Ces clients offrent généralement la possibilité d'effectuer une ou plusieurs des actions suivantes :

* Gérer les clés privées et les adresses Ethereum dans un portefeuille.
* Créer, signer et diffuser des transactions.
* Interagir avec les contrats intelligents, en utilisant la charge utile des données.
* Naviguer et interagir avec les DApps.
* Offrir des liens vers des services externes tels que des explorateurs de blocs.
* Convertir les unités d'ether et récupérer les taux de change à partir de sources externes.
* Injecter une instance web3 dans le navigateur Web en tant qu'objet JavaScript.
* Utiliser une instance web3 fournie/injectée dans le navigateur par un autre client.
* Accéder aux services RPC sur un nœud Ethereum local ou distant.

Certains clients distants, par exemple les portefeuilles mobiles (smartphones), n'offrent que des fonctionnalités de portefeuille de base. Les autres clients distants sont des navigateurs DApp à part entière. Les clients distants offrent généralement certaines des fonctions d'un client Ethereum à nœud complet sans synchroniser une copie locale de la chaîne de blocs Ethereum en se connectant à un nœud complet exécuté ailleurs, par exemple, par vous localement sur votre machine ou sur un serveur Web, ou par un tiers sur leurs serveurs.

Examinons certains des clients distants les plus populaires et les fonctions qu'ils offrent.

[[mobile_wallets]]
==== Portefeuilles mobiles (Smartphone)

((("portefeuilles mobiles (smartphones)")))((("clients distants","portefeuilles mobiles")))((("portefeuilles","mobile")))Tous les portefeuilles mobiles sont des clients distants, car les téléphones intelligents ne disposent pas des ressources adéquates pour exécuter un client Ethereum complet. Les clients légers sont en développement et ne sont pas généralement utilisés pour Ethereum. Dans le cas de Parity, le client léger est marqué "expérimental" et peut être utilisé en exécutant +parity+ avec l'option +--light+.

Les portefeuilles mobiles populaires incluent les éléments suivants (nous les énumérons simplement à titre d'exemples ; il ne s'agit pas d'une approbation ou d'une indication de la sécurité ou de la fonctionnalité de ces portefeuilles) :

https://jaxx.io[Jaxx]:: ((("Jaxx","version mobile")))((("portefeuilles","Jaxx")))Un portefeuille mobile multidevises basé sur les valeurs mnémoniques BIP-39, avec prise en charge de Bitcoin, Litecoin, Ethereum, Ethereum Classic, ZCash, une variété de jetons ERC20 et de nombreuses autres devises. Jaxx est disponible sur Android et iOS, en tant que portefeuille de plug-in de navigateur et en tant que portefeuille de bureau pour une variété de systèmes d'exploitation.

https://status.im[Status]:: ((("Status (portefeuille mobile)")))Un portefeuille mobile et un navigateur DApp, avec prise en charge d'une variété de jetons et de DApps populaires. Disponible pour iOS et Android.

https://trustwalletapp.com/[Trust Wallet]:: ((("Trust Wallet")))((("portefeuilles","Trust")))Un portefeuille mobile multi-devises qui prend en charge Ethereum et Ethereum Classic ainsi que les jetons ERC20 et ERC223. Trust Wallet est disponible pour iOS et Android.

https://www.cipherbrowser.com[Cipher Browser]:: ((("Cipher Browser"))) Un navigateur et un portefeuille DApp mobile complet compatible avec Ethereum qui permet l'intégration avec les applications et les jetons Ethereum. Disponible pour iOS et Android.

[[browser_wallets]]
==== Portefeuilles de navigateur

((("portefeuilles de navigateur")))((("clients distants","portefeuilles de navigateur")))((("portefeuilles","portefeuilles de navigateur")))Une variété de portefeuilles et de navigateurs DApp sont disponibles en tant que plug-ins ou extensions de navigateurs Web tels que Chrome et Firefox. Ce sont des clients distants qui s'exécutent dans votre navigateur.

Certains des plus populaires sont MetaMask, Jaxx, MyEtherWallet et MyCrypto.

[[MetaMask]]
===== MetaMask

https://metamask.io/[MetaMask], ((("MetaMask","comme portefeuille de navigateur")))introduit dans <<intro_chapter>>, est un portefeuille polyvalent basé sur un navigateur, un client RPC et un explorateur de contrats de base. Il est disponible sur Chrome, Firefox, Opera et Brave Browser.

Contrairement aux autres portefeuilles de navigateur, MetaMask injecte une instance web3 dans le contexte JavaScript du navigateur, agissant comme un client RPC qui se connecte à une variété de chaînes de blocs Ethereum (mainnet, Ropsten testnet, Kovan testnet, nœud RPC local, etc.). La possibilité d'injecter une instance web3 et d'agir comme une passerelle vers des services RPC externes fait de MetaMask un outil très puissant pour les développeurs et les utilisateurs. Il peut être combiné, par exemple, avec MyEtherWallet ou MyCrypto, agissant comme un fournisseur web3 et une passerelle RPC pour ces outils.

[[Jaxx]]
===== Jaxx

https://jaxx.io[Jaxx], ((("Jaxx","version de bureau")))((("portefeuilles","Jaxx")))qui a été présenté comme un portefeuille mobile dans la section précédente, est également disponible en tant qu'extension Chrome et Firefox et en tant que portefeuille de bureau.

[[MEW]]
===== MyEtherWallet (MEW)

https://www.myetherwallet.com/[MyEtherWallet] ((("MyEtherWallet (MEW)")))((("portefeuilles","MyEtherWallet"))) est un client distant JavaScript basé sur un navigateur qui offre :

* Un pont vers les portefeuilles matériels populaires tels que Trezor et Ledger
* Une interface web3 pouvant se connecter à une instance web3 injectée par un autre client (par exemple, MetaMask)
* Un client RPC pouvant se connecter à un client complet Ethereum
* Une interface de base qui peut interagir avec des contrats intelligents, étant donné l'adresse d'un contrat et l'interface binaire d'application (ABI)
* Une application mobile, MEWConnect, qui permet d'utiliser un appareil Android ou iOS compatible pour stocker des fonds, de la même manière qu'un portefeuille matériel.
* Un portefeuille logiciel fonctionnant en JavaScript

[WARNING]
====
Vous devez être très prudent lorsque vous accédez à MyEtherWallet et à d'autres portefeuilles JavaScript basés sur un navigateur, car ils sont des cibles fréquentes pour le phishing. Utilisez toujours un signet et non un moteur de recherche ou un lien pour accéder à l'URL Web correcte.
====

[[MyCrypto]]
===== MyCrypto

((("MyCrypto (portefeuille)")))((("portefeuilles","MyCrypto")))Début 2018, le ((("MyEtherWallet (MEW)")))((("portefeuilles"," MyEtherWallet"))) projet MyEtherWallet s'est scindé en deux implémentations concurrentes, guidées par deux équipes de développement indépendantes : une "fourche" ou "fork", comme on l'appelle dans le développement à source libre. Les deux projets s'appellent MyEtherWallet (la marque originale) et https://mycrypto.com/[MyCrypto]. MyCrypto offre des fonctionnalités presque identiques à MyEtherWallet, mais au lieu d'utiliser MEWConnect, il offre une connexion à l'application mobile Parity Signer. Comme MEWConnect, Parity Signer stocke les clés sur le téléphone et s'interface avec MyCrypto de la même manière qu'un portefeuille matériel.

[[Mist]]
===== Mist (obsolète)

https://github.com/ethereum/mist[Mist] ((("Mist (portefeuille basé sur un navigateur)")))((("portefeuilles","Mist")))était le premier navigateur compatible avec Ethereum, construit par la Fondation Ethereum. Il contenait un portefeuille basé sur un navigateur qui était la première implémentation de la norme de jeton ERC20 (Fabian Vogelsteller, auteur d'ERC20, était également le principal développeur de Mist). Mist a également été le premier portefeuille à introduire la somme de contrôle camelCase (EIP-55). Depuis mars 2019, Mist est obsolète et ne doit plus être utilisé.

=== Conclusion

Dans ce chapitre, nous avons exploré les clients Ethereum. Vous avez téléchargé, installé et synchronisé un client, devenant un participant au réseau Ethereum et contribuant à la santé et à la stabilité du système en répliquant la chaîne de blocs sur votre propre ordinateur.(((range="endofrange", startref="ix_03clients -asciidoc0")))